starting proving server with connection through their stdin
using textmode optiontext
starting proving server with connection through their stdin
using textmode optiontext
starting proving server with connection through their stdin
using textmode optiontext
starting proving server with connection through their stdin
using textmode optiontext
starting proving server with connection through their stdin
using textmode optiontext
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
Un : (nat -> R) |- (Un_growing -> forall l : R, is_lub EUn l -> Un_cv l)
----
Un : (nat -> R) |- (Un_growing -> forall l : R, is_lub EUn l -> Un_cv l) OUTPUT
intros ?
intros
unfold Un_cv
induction 1
unfold Un_growing
unfold is_lub
unfold l
induction l
unfold ll
unfold Un_decreasing
Prediction takes 3.2648448944091797 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold Un_cv",
      confidence = 0.5 ),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    ( tacticText = "unfold Un_growing",
      confidence = 0.5 ),
    ( tacticText = "unfold is_lub",
      confidence = 0.5 ),
    (tacticText = "unfold l", confidence = 0.5),
    ( tacticText = "induction l",
      confidence = 0.5 ),
    (tacticText = "unfold ll", confidence = 0.5),
    ( tacticText = "unfold Un_decreasing",
      confidence = 0.5 ) ] )
STATE
Un : (nat -> R), H : Un_growing |- (forall l : R, is_lub EUn l -> Un_cv l)
----
Un : (nat -> R), H : Un_growing |- (forall l : R, is_lub EUn l -> Un_cv l) OUTPUT
intros ?
intros
induction 1
unfold Un_cv
unfold is_lub
induction l
unfold Un_growing
unfold l
exact H
unfold is_lub in H
Prediction takes 0.12264895439147949 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    ( tacticText = "unfold Un_cv",
      confidence = 0.5 ),
    ( tacticText = "unfold is_lub",
      confidence = 0.5 ),
    ( tacticText = "induction l",
      confidence = 0.5 ),
    ( tacticText = "unfold Un_growing",
      confidence = 0.5 ),
    (tacticText = "unfold l", confidence = 0.5),
    (tacticText = "exact H", confidence = 0.5),
    ( tacticText = "unfold is_lub in H",
      confidence = 0.5 ) ] )
STATE
Un : (nat -> R), H : Un_growing, l : R |- (is_lub EUn l -> Un_cv l)
----
Un : (nat -> R), H : Un_growing, l : R |- (is_lub EUn l -> Un_cv l) OUTPUT
intros ?
intros
unfold Un_cv
unfold Un_growing
unfold is_lub
induction 1
induction l
unfold Un_cv in H
unfold Un_growing in H
unfold is_lub in H
Prediction takes 0.11065340042114258 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold Un_cv",
      confidence = 0.5 ),
    ( tacticText = "unfold Un_growing",
      confidence = 0.5 ),
    ( tacticText = "unfold is_lub",
      confidence = 0.5 ),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    ( tacticText = "induction l",
      confidence = 0.5 ),
    ( tacticText = "unfold Un_cv in H",
      confidence = 0.5 ),
    ( tacticText = "unfold Un_growing in H",
      confidence = 0.5 ),
    ( tacticText = "unfold is_lub in H",
      confidence = 0.5 ) ] )
STATE
Un : (nat -> R), H : Un_growing, l : R, H0 : (is_lub EUn l) |- (Un_cv l)
----
Un : (nat -> R), H : Un_growing, l : R, H0 : (is_lub EUn l) |- (Un_cv l) OUTPUT
assumption
apply H0
unfold Un_cv
unfold Un_growing
exact H0
elim H0
unfold is_lub
unfold H0
easy
unfold EUn
Prediction takes 0.09149360656738281 seconds
( textPrediction = [
    ( tacticText = "assumption",
      confidence = 0.5 ),
    (tacticText = "apply H0", confidence = 0.5),
    ( tacticText = "unfold Un_cv",
      confidence = 0.5 ),
    ( tacticText = "unfold Un_growing",
      confidence = 0.5 ),
    (tacticText = "exact H0", confidence = 0.5),
    (tacticText = "elim H0", confidence = 0.5),
    ( tacticText = "unfold is_lub",
      confidence = 0.5 ),
    (tacticText = "unfold H0", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "unfold EUn",
      confidence = 0.5 ) ] )
STATE
Un : (nat -> R), H : Un_growing, l : R, H0 : (is_lub EUn l) |- (forall eps : R, eps > 0 -> exists N : nat, forall n : nat, (n >= N)%nat -> R_dist (Un n) l < eps)
----
Un : (nat -> R), H : Un_growing, l : R, H0 : (is_lub EUn l) |- (forall eps : R, eps > 0 -> exists N : nat, forall n : nat, (n >= N)%nat -> R_dist (Un n) l < eps) OUTPUT
intros ?
intros
unfold R_dist
clear H0
unfold R_dist in H0
elim H0
simpl
unfold Un_growing
unfold R_dist in H
unfold Un_growing in H0
Prediction takes 0.14758992195129395 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold R_dist",
      confidence = 0.5 ),
    (tacticText = "clear H0", confidence = 0.5),
    ( tacticText = "unfold R_dist in H0",
      confidence = 0.5 ),
    (tacticText = "elim H0", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold Un_growing",
      confidence = 0.5 ),
    ( tacticText = "unfold R_dist in H",
      confidence = 0.5 ),
    ( tacticText = "unfold Un_growing in H0",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
 |- (forall x : R, derivable_pt_lim cosh x (sinh x))
----
 |- (forall x : R, derivable_pt_lim cosh x (sinh x)) OUTPUT
intros ?
intros
unfold derivable_pt_pt_pt_lim sinh
unfold derivable_pt_pt_pt
unfold derivable_pt_pt_in
unfold derivable_pt_pt
unfold derivable_pt_pt_pt_lim
unfold derivable_pt_pt_lim sinh
unfold derivable_pt_pt_pt_lim cosh
unfold continuity_pt_pt_pt_lim sinh
Prediction takes 3.1565051078796387 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold derivable_pt_pt_pt_lim sinh",
      confidence = 0.5 ),
    ( tacticText = "unfold derivable_pt_pt_pt",
      confidence = 0.5 ),
    ( tacticText = "unfold derivable_pt_pt_in",
      confidence = 0.5 ),
    ( tacticText = "unfold derivable_pt_pt",
      confidence = 0.5 ),
    ( tacticText = "unfold derivable_pt_pt_pt_lim",
      confidence = 0.5 ),
    ( tacticText = "unfold derivable_pt_pt_lim sinh",
      confidence = 0.5 ),
    ( tacticText = "unfold derivable_pt_pt_pt_lim cosh",
      confidence = 0.5 ),
    ( tacticText = "unfold continuity_pt_pt_pt_lim sinh",
      confidence = 0.5 ) ] )
STATE
x : R |- (derivable_pt_lim cosh x (sinh x))
----
x : R |- (derivable_pt_lim cosh x (sinh x)) OUTPUT
unfold derivable_pt_lim
unfold derivable_pt
intros ?
unfold continuity_pt
unfold derive_pt
assumption
unfold continuity_pt_lim
apply derivable_pt_lim
apply derivable_pt_cosh
unfold derive_pt_lim
Prediction takes 0.17083144187927246 seconds
( textPrediction = [
    ( tacticText = "unfold derivable_pt_lim",
      confidence = 0.5 ),
    ( tacticText = "unfold derivable_pt",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold continuity_pt",
      confidence = 0.5 ),
    ( tacticText = "unfold derive_pt",
      confidence = 0.5 ),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    ( tacticText = "unfold continuity_pt_lim",
      confidence = 0.5 ),
    ( tacticText = "apply derivable_pt_lim",
      confidence = 0.5 ),
    ( tacticText = "apply derivable_pt_cosh",
      confidence = 0.5 ),
    ( tacticText = "unfold derive_pt_lim",
      confidence = 0.5 ) ] )
STATE
x : R |- (forall eps : R, 0 < eps -> exists delta : posreal, forall h : R, h <> 0 -> Rabs h < delta -> Rabs ((cosh (x + h) - cosh x) / h - sinh x) < eps)
----
x : R |- (forall eps : R, 0 < eps -> exists delta : posreal, forall h : R, h <> 0 -> Rabs h < delta -> Rabs ((cosh (x + h) - cosh x) / h - sinh x) < eps) OUTPUT
intros ?
intros
unfold limit_in
unfold R_dist
unfold continuity_pt
unfold limit1_in
simpl
unfold derivable_pt
unfold limit1
unfold limit_in in H
Prediction takes 0.1289055347442627 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold limit_in",
      confidence = 0.5 ),
    ( tacticText = "unfold R_dist",
      confidence = 0.5 ),
    ( tacticText = "unfold continuity_pt",
      confidence = 0.5 ),
    ( tacticText = "unfold limit1_in",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold derivable_pt",
      confidence = 0.5 ),
    ( tacticText = "unfold limit1",
      confidence = 0.5 ),
    ( tacticText = "unfold limit_in in H",
      confidence = 0.5 ) ] )
STATE
x : R, eps : R |- (0 < eps -> exists delta : posreal, forall h : R, h <> 0 -> Rabs h < delta -> Rabs ((cosh (x + h) - cosh x) / h - sinh x) < eps)
----
x : R, eps : R |- (0 < eps -> exists delta : posreal, forall h : R, h <> 0 -> Rabs h < delta -> Rabs ((cosh (x + h) - cosh x) / h - sinh x) < eps) OUTPUT
intros ?
intros
unfold limit_in
unfold continuity_pt
unfold R_dist
unfold Rminus
unfold derivable_pt
unfold Rdiv
unfold limit1_in
unfold limit1
Prediction takes 0.11197805404663086 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold limit_in",
      confidence = 0.5 ),
    ( tacticText = "unfold continuity_pt",
      confidence = 0.5 ),
    ( tacticText = "unfold R_dist",
      confidence = 0.5 ),
    ( tacticText = "unfold Rminus",
      confidence = 0.5 ),
    ( tacticText = "unfold derivable_pt",
      confidence = 0.5 ),
    ( tacticText = "unfold Rdiv",
      confidence = 0.5 ),
    ( tacticText = "unfold limit1_in",
      confidence = 0.5 ),
    ( tacticText = "unfold limit1",
      confidence = 0.5 ) ] )
STATE
x : R, eps : R, H : (0 < eps) |- (exists delta : posreal, forall h : R, h <> 0 -> Rabs h < delta -> Rabs ((cosh (x + h) - cosh x) / h - sinh x) < eps)
----
x : R, eps : R, H : (0 < eps) |- (exists delta : posreal, forall h : R, h <> 0 -> Rabs h < delta -> Rabs ((cosh (x + h) - cosh x) / h - sinh x) < eps) OUTPUT
intros ?
intros
exists delta
elim H
elim H0
unfold limit_in
unfold limit_in in H
cut (0 < eps / 2)
exists {| pos := eps; cond_pos := H |}
exists {| pos := eps; cond_pos := H
Prediction takes 0.20594048500061035 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "exists delta",
      confidence = 0.5 ),
    (tacticText = "elim H", confidence = 0.5),
    (tacticText = "elim H0", confidence = 0.5),
    ( tacticText = "unfold limit_in",
      confidence = 0.5 ),
    ( tacticText = "unfold limit_in in H",
      confidence = 0.5 ),
    ( tacticText = "cut (0 < eps / 2)",
      confidence = 0.5 ),
    ( tacticText = "exists {| pos := eps; cond_pos := H |}",
      confidence = 0.5 ),
    ( tacticText = "exists {| pos := eps; cond_pos := H",
      confidence = 0.5 ) ] )
STATE
x : R, eps : R, H : (0 < eps) |- (exists delta : posreal, forall h : R, h <> 0 -> Rabs h < delta -> Rabs ((cosh (x + h) - cosh x) / h - sinh x) < eps)
----
x : R, eps : R, H : (0 < eps) |- (exists delta : posreal, forall h : R, h <> 0 -> Rabs h < delta -> Rabs ((cosh (x + h) - cosh x) / h - sinh x) < eps) OUTPUT
intros ?
intros
exists delta
elim H
elim H0
unfold limit_in
unfold limit_in in H
cut (0 < eps / 2)
exists {| pos := eps; cond_pos := H |}
exists {| pos := eps; cond_pos := H
Prediction takes 0.16828560829162598 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "exists delta",
      confidence = 0.5 ),
    (tacticText = "elim H", confidence = 0.5),
    (tacticText = "elim H0", confidence = 0.5),
    ( tacticText = "unfold limit_in",
      confidence = 0.5 ),
    ( tacticText = "unfold limit_in in H",
      confidence = 0.5 ),
    ( tacticText = "cut (0 < eps / 2)",
      confidence = 0.5 ),
    ( tacticText = "exists {| pos := eps; cond_pos := H |}",
      confidence = 0.5 ),
    ( tacticText = "exists {| pos := eps; cond_pos := H",
      confidence = 0.5 ) ] )
Model Loaded
0
STATE
 |- (forall (a b : R) (f g : R -> R) (lf lg : Rlist), is_subdivision f a b lf -> is_subdivision g a b lg -> is_subdivision g a b (cons_ORlist lf lg))
----
 |- (forall (a b : R) (f g : R -> R) (lf lg : Rlist), is_subdivision f a b lf -> is_subdivision g a b lg -> is_subdivision g a b (cons_ORlist lf lg)) OUTPUT
intros ?
intros
induction 1
unfold is_subdivision g a b pr)
unfold is_inv
intros until b
unfold is_in
unfold is_subdivision g a b lg)
unfold is_subdivision g a b (IsStepFun g a b a)
unfold is_subdivision g a b (is_subdivision g)
Prediction takes 2.932332992553711 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    ( tacticText = "unfold is_subdivision g a b pr)",
      confidence = 0.5 ),
    ( tacticText = "unfold is_inv",
      confidence = 0.5 ),
    ( tacticText = "intros until b",
      confidence = 0.5 ),
    ( tacticText = "unfold is_in",
      confidence = 0.5 ),
    ( tacticText = "unfold is_subdivision g a b lg)",
      confidence = 0.5 ),
    ( tacticText = "unfold is_subdivision g a b (IsStepFun g a b a)",
      confidence = 0.5 ),
    ( tacticText = "unfold is_subdivision g a b (is_subdivision g)",
      confidence = 0.5 ) ] )
STATE
a : R |- (forall (b : R) (f g : R -> R) (lf lg : Rlist), is_subdivision f a b lf -> is_subdivision g a b lg -> is_subdivision g a b (cons_ORlist lf lg))
----
a : R |- (forall (b : R) (f g : R -> R) (lf lg : Rlist), is_subdivision f a b lf -> is_subdivision g a b lg -> is_subdivision g a b (cons_ORlist lf lg)) OUTPUT
intros ?
intros
unfold is_subdivision
induction 1
simpl
intros until b
intros until lg
unfold is_subdivision g
simple induction lg
simple induction 1
Prediction takes 0.07214117050170898 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold is_subdivision",
      confidence = 0.5 ),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "intros until b",
      confidence = 0.5 ),
    ( tacticText = "intros until lg",
      confidence = 0.5 ),
    ( tacticText = "unfold is_subdivision g",
      confidence = 0.5 ),
    ( tacticText = "simple induction lg",
      confidence = 0.5 ),
    ( tacticText = "simple induction 1",
      confidence = 0.5 ) ] )
STATE
a : R, b : R |- (forall (f g : R -> R) (lf lg : Rlist), is_subdivision f a b lf -> is_subdivision g a b lg -> is_subdivision g a b (cons_ORlist lf lg))
----
a : R, b : R |- (forall (f g : R -> R) (lf lg : Rlist), is_subdivision f a b lf -> is_subdivision g a b lg -> is_subdivision g a b (cons_ORlist lf lg)) OUTPUT
intros ?
intros
unfold is_subdivision
unfold is_subdivision_val
unfold is_subdivision in H
simpl
intros until b
unfold is_subdivision in X
unfold is_subdivision g
intros until g
Prediction takes 0.08220314979553223 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold is_subdivision",
      confidence = 0.5 ),
    ( tacticText = "unfold is_subdivision_val",
      confidence = 0.5 ),
    ( tacticText = "unfold is_subdivision in H",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "intros until b",
      confidence = 0.5 ),
    ( tacticText = "unfold is_subdivision in X",
      confidence = 0.5 ),
    ( tacticText = "unfold is_subdivision g",
      confidence = 0.5 ),
    ( tacticText = "intros until g",
      confidence = 0.5 ) ] )
STATE
a : R, b : R, f : (R -> R) |- (forall (g : R -> R) (lf lg : Rlist), is_subdivision f a b lf -> is_subdivision g a b lg -> is_subdivision g a b (cons_ORlist lf lg))
----
a : R, b : R, f : (R -> R) |- (forall (g : R -> R) (lf lg : Rlist), is_subdivision f a b lf -> is_subdivision g a b lg -> is_subdivision g a b (cons_ORlist lf lg)) OUTPUT
intros ?
intros
unfold is_subdivision
simpl
unfold adapted_couple
clear X
induction lf
intros until lg
simple induction lf
unfold is_subdivision g
Prediction takes 0.09031081199645996 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold is_subdivision",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold adapted_couple",
      confidence = 0.5 ),
    (tacticText = "clear X", confidence = 0.5),
    ( tacticText = "induction lf",
      confidence = 0.5 ),
    ( tacticText = "intros until lg",
      confidence = 0.5 ),
    ( tacticText = "simple induction lf",
      confidence = 0.5 ),
    ( tacticText = "unfold is_subdivision g",
      confidence = 0.5 ) ] )
STATE
a : R, b : R, f : (R -> R), g : (R -> R) |- (forall lf lg : Rlist, is_subdivision f a b lf -> is_subdivision g a b lg -> is_subdivision g a b (cons_ORlist lf lg))
----
a : R, b : R, f : (R -> R), g : (R -> R) |- (forall lf lg : Rlist, is_subdivision f a b lf -> is_subdivision g a b lg -> is_subdivision g a b (cons_ORlist lf lg)) OUTPUT
intros ?
intros
unfold is_subdivision
simpl
clear X
induction lf
simple induction lf
simple induction l
intros until lg
unfold is_subdivision g
Prediction takes 0.12281298637390137 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold is_subdivision",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "clear X", confidence = 0.5),
    ( tacticText = "induction lf",
      confidence = 0.5 ),
    ( tacticText = "simple induction lf",
      confidence = 0.5 ),
    ( tacticText = "simple induction l",
      confidence = 0.5 ),
    ( tacticText = "intros until lg",
      confidence = 0.5 ),
    ( tacticText = "unfold is_subdivision g",
      confidence = 0.5 ) ] )
STATE
a : R, b : R, f : (R -> R), g : (R -> R), lf : Rlist |- (forall lg : Rlist, is_subdivision f a b lf -> is_subdivision g a b lg -> is_subdivision g a b (cons_ORlist lf lg))
----
a : R, b : R, f : (R -> R), g : (R -> R), lf : Rlist |- (forall lg : Rlist, is_subdivision f a b lf -> is_subdivision g a b lg -> is_subdivision g a b (cons_ORlist lf lg)) OUTPUT
intros ?
intros
unfold is_subdivision
induction lf
simpl
intros until lg
simple induction lf
unfold adapted_couple
simple induction lg
unfold is_subdivision g
Prediction takes 0.11876320838928223 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold is_subdivision",
      confidence = 0.5 ),
    ( tacticText = "induction lf",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "intros until lg",
      confidence = 0.5 ),
    ( tacticText = "simple induction lf",
      confidence = 0.5 ),
    ( tacticText = "unfold adapted_couple",
      confidence = 0.5 ),
    ( tacticText = "simple induction lg",
      confidence = 0.5 ),
    ( tacticText = "unfold is_subdivision g",
      confidence = 0.5 ) ] )
STATE
a : R, b : R, f : (R -> R), g : (R -> R), lf : Rlist, lg : Rlist |- (is_subdivision f a b lf -> is_subdivision g a b lg -> is_subdivision g a b (cons_ORlist lf lg))
----
a : R, b : R, f : (R -> R), g : (R -> R), lf : Rlist, lg : Rlist |- (is_subdivision f a b lf -> is_subdivision g a b lg -> is_subdivision g a b (cons_ORlist lf lg)) OUTPUT
intros ?
intros
unfold is_subdivision
unfold adapted_couple
simpl
unfold is_subdivision in H
clear X
unfold adapted_couple in H
unfold is_subdivision_val
unfold is_subdivision g
Prediction takes 0.14779973030090332 seconds
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
 |- (forall a b c : R, Riemann_integrable (fct_cte c) a b)
----
 |- (forall a b c : R, Riemann_integrable (fct_cte c) a b) OUTPUT
intros
intros ?
red
unfold Riemann_integrable
unfold RiemannInt_increasing
unfold fct_increasing
unfold fct_increasing_increasing
unfold RiemannInt_increasing_increasing
unfold Riemann_integrable (fct_cte c)
unfold RiemannInt_SF
Prediction takes 2.8165762424468994 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold Riemann_integrable",
      confidence = 0.5 ),
    ( tacticText = "unfold RiemannInt_increasing",
      confidence = 0.5 ),
    ( tacticText = "unfold fct_increasing",
      confidence = 0.5 ),
    ( tacticText = "unfold fct_increasing_increasing",
      confidence = 0.5 ),
    ( tacticText = "unfold RiemannInt_increasing_increasing",
      confidence = 0.5 ),
    ( tacticText = "unfold Riemann_integrable (fct_cte c)",
      confidence = 0.5 ),
    ( tacticText = "unfold RiemannInt_SF",
      confidence = 0.5 ) ] )
STATE
a : R, b : R, c : R |- (Riemann_integrable (fct_cte c) a b)
----
a : R, b : R, c : R |- (Riemann_integrable (fct_cte c) a b) OUTPUT
unfold RiemannInt
unfold RiemannInt_SF
unfold Riemann_integrable
apply RiemannInt_SF
apply RiemannInt_P4
unfold fct_cte c
apply RiemannInt_P2
apply fct_cte c
apply Riemann_integrable_integrable
apply StepFun_P4
Prediction takes 0.13399910926818848 seconds
( textPrediction = [
    ( tacticText = "unfold RiemannInt",
      confidence = 0.5 ),
    ( tacticText = "unfold RiemannInt_SF",
      confidence = 0.5 ),
    ( tacticText = "unfold Riemann_integrable",
      confidence = 0.5 ),
    ( tacticText = "apply RiemannInt_SF",
      confidence = 0.5 ),
    ( tacticText = "apply RiemannInt_P4",
      confidence = 0.5 ),
    ( tacticText = "unfold fct_cte c",
      confidence = 0.5 ),
    ( tacticText = "apply RiemannInt_P2",
      confidence = 0.5 ),
    ( tacticText = "apply fct_cte c",
      confidence = 0.5 ),
    ( tacticText = "apply Riemann_integrable_integrable",
      confidence = 0.5 ),
    ( tacticText = "apply StepFun_P4",
      confidence = 0.5 ) ] )
STATE
a : R, b : R, c : R |- (forall eps : posreal, {phi : StepFun a b & {psi : StepFun a b | (forall t : R, Rmin a b <= t <= Rmax a b -> Rabs (fct_cte c t - phi t) <= psi t) /\ Rabs (RiemannInt_SF psi) < eps}})
----
a : R, b : R, c : R |- (forall eps : posreal, {phi : StepFun a b & {psi : StepFun a b | (forall t : R, Rmin a b <= t <= Rmax a b -> Rabs (fct_cte c t - phi t) <= psi t) /\ Rabs (RiemannInt_SF psi) < eps}}) OUTPUT
intros ?
intros
split
unfold StepFun
unfold RiemannInt_SF
unfold RiemannInt
unfold StepFun in H
unfold StepFun_P4
assert (a <= c <= b)
unfold StepFun_P44
Prediction takes 0.18995928764343262 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "unfold StepFun",
      confidence = 0.5 ),
    ( tacticText = "unfold RiemannInt_SF",
      confidence = 0.5 ),
    ( tacticText = "unfold RiemannInt",
      confidence = 0.5 ),
    ( tacticText = "unfold StepFun in H",
      confidence = 0.5 ),
    ( tacticText = "unfold StepFun_P4",
      confidence = 0.5 ),
    ( tacticText = "assert (a <= c <= b)",
      confidence = 0.5 ),
    ( tacticText = "unfold StepFun_P44",
      confidence = 0.5 ) ] )
STATE
a : R |- (forall b c : R, Riemann_integrable (fct_cte c) a b)
----
a : R |- (forall b c : R, Riemann_integrable (fct_cte c) a b) OUTPUT
intros ?
intros
unfold Riemann_integrable
unfold RiemannInt_SF
red
unfold fct_cte
intros until c
unfold R_dist
unfold derivable_pt
unfold RiemannInt
Prediction takes 0.09677648544311523 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold Riemann_integrable",
      confidence = 0.5 ),
    ( tacticText = "unfold RiemannInt_SF",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold fct_cte",
      confidence = 0.5 ),
    ( tacticText = "intros until c",
      confidence = 0.5 ),
    ( tacticText = "unfold R_dist",
      confidence = 0.5 ),
    ( tacticText = "unfold derivable_pt",
      confidence = 0.5 ),
    ( tacticText = "unfold RiemannInt",
      confidence = 0.5 ) ] )
STATE
a : R, b : R |- (forall c : R, Riemann_integrable (fct_cte c) a b)
----
a : R, b : R |- (forall c : R, Riemann_integrable (fct_cte c) a b) OUTPUT
intros ?
intros
unfold Riemann_integrable
unfold RiemannInt_SF
unfold fct_cte
unfold RiemannInt
red
unfold derivable_pt
unfold R_dist
apply Riemann_integrable
Prediction takes 0.12781834602355957 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold Riemann_integrable",
      confidence = 0.5 ),
    ( tacticText = "unfold RiemannInt_SF",
      confidence = 0.5 ),
    ( tacticText = "unfold fct_cte",
      confidence = 0.5 ),
    ( tacticText = "unfold RiemannInt",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold derivable_pt",
      confidence = 0.5 ),
    ( tacticText = "unfold R_dist",
      confidence = 0.5 ),
    ( tacticText = "apply Riemann_integrable",
      confidence = 0.5 ) ] )
STATE
a : R, b : R, c : R |- (Riemann_integrable (fct_cte c) a b)
----
a : R, b : R, c : R |- (Riemann_integrable (fct_cte c) a b) OUTPUT
unfold RiemannInt
unfold RiemannInt_SF
unfold Riemann_integrable
apply RiemannInt_SF
apply RiemannInt_P4
unfold fct_cte c
apply RiemannInt_P2
apply fct_cte c
apply Riemann_integrable_integrable
apply StepFun_P4
Prediction takes 0.12948060035705566 seconds
( textPrediction = [
    ( tacticText = "unfold RiemannInt",
      confidence = 0.5 ),
    ( tacticText = "unfold RiemannInt_SF",
      confidence = 0.5 ),
    ( tacticText = "unfold Riemann_integrable",
      confidence = 0.5 ),
    ( tacticText = "apply RiemannInt_SF",
      confidence = 0.5 ),
    ( tacticText = "apply RiemannInt_P4",
      confidence = 0.5 ),
    ( tacticText = "unfold fct_cte c",
      confidence = 0.5 ),
    ( tacticText = "apply RiemannInt_P2",
      confidence = 0.5 ),
    ( tacticText = "apply fct_cte c",
      confidence = 0.5 ),
    ( tacticText = "apply Riemann_integrable_integrable",
      confidence = 0.5 ),
    ( tacticText = "apply StepFun_P4",
      confidence = 0.5 ) ] )
STATE
a : R, b : R, c : R |- (Riemann_integrable (fct_cte c) a b)
----
a : R, b : R, c : R |- (Riemann_integrable (fct_cte c) a b) OUTPUT
unfold RiemannInt
unfold RiemannInt_SF
unfold Riemann_integrable
apply RiemannInt_SF
apply RiemannInt_P4
unfold fct_cte c
apply RiemannInt_P2
apply fct_cte c
apply Riemann_integrable_integrable
apply StepFun_P4
Prediction takes 0.08936238288879395 seconds
( textPrediction = [
    ( tacticText = "unfold RiemannInt",
      confidence = 0.5 ),
    ( tacticText = "unfold RiemannInt_SF",
      confidence = 0.5 ),
    ( tacticText = "unfold Riemann_integrable",
      confidence = 0.5 ),
    ( tacticText = "apply RiemannInt_SF",
      confidence = 0.5 ),
    ( tacticText = "apply RiemannInt_P4",
      confidence = 0.5 ),
    ( tacticText = "unfold fct_cte c",
      confidence = 0.5 ),
    ( tacticText = "apply RiemannInt_P2",
      confidence = 0.5 ),
    ( tacticText = "apply fct_cte c",
      confidence = 0.5 ),
    ( tacticText = "apply Riemann_integrable_integrable",
      confidence = 0.5 ),
    ( tacticText = "apply StepFun_P4",
      confidence = 0.5 ) ] )
STATE
a : R, b : R, c : R |- (Riemann_integrable (fct_cte c) a b)
----
a : R, b : R, c : R |- (Riemann_integrable (fct_cte c) a b) OUTPUT
unfold RiemannInt
unfold RiemannInt_SF
unfold Riemann_integrable
apply RiemannInt_SF
apply RiemannInt_P4
unfold fct_cte c
apply RiemannInt_P2
apply fct_cte c
apply Riemann_integrable_integrable
apply StepFun_P4
Prediction takes 0.09275627136230469 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold is_subdivision",
      confidence = 0.5 ),
    ( tacticText = "unfold adapted_couple",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold is_subdivision in H",
      confidence = 0.5 ),
    (tacticText = "clear X", confidence = 0.5),
    ( tacticText = "unfold adapted_couple in H",
      confidence = 0.5 ),
    ( tacticText = "unfold is_subdivision_val",
      confidence = 0.5 ),
    ( tacticText = "unfold is_subdivision g",
      confidence = 0.5 ) ] )
STATE
a : R, b : R, f : (R -> R), g : (R -> R), lf : Rlist, lg : Rlist, X : (is_subdivision f a b lf) |- (is_subdivision g a b lg -> is_subdivision g a b (cons_ORlist lf lg))
----
a : R, b : R, f : (R -> R), g : (R -> R), lf : Rlist, lg : Rlist, X : (is_subdivision f a b lf) |- (is_subdivision g a b lg -> is_subdivision g a b (cons_ORlist lf lg)) OUTPUT
intros ?
intros
unfold is_subdivision
unfold adapted_couple
clear X
simpl
unfold is_subdivision in H
unfold is_subdivision in X
unfold adapted_couple in H
unfold is_subdivision_val
Prediction takes 0.12339568138122559 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold is_subdivision",
      confidence = 0.5 ),
    ( tacticText = "unfold adapted_couple",
      confidence = 0.5 ),
    (tacticText = "clear X", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold is_subdivision in H",
      confidence = 0.5 ),
    ( tacticText = "unfold is_subdivision in X",
      confidence = 0.5 ),
    ( tacticText = "unfold adapted_couple in H",
      confidence = 0.5 ),
    ( tacticText = "unfold is_subdivision_val",
      confidence = 0.5 ) ] )
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
 |- (continuity cos)
----
 |- (continuity cos) OUTPUT
unfold continuity_pt
unfold cos
unfold cos_in
unfold cos_pt
split
unfold cos_increasing
intros ?
unfold continuity_pt_pt
unfold continuity
apply continuity_pt
Prediction takes 3.238083839416504 seconds
( textPrediction = [
    ( tacticText = "unfold continuity_pt",
      confidence = 0.5 ),
    ( tacticText = "unfold cos",
      confidence = 0.5 ),
    ( tacticText = "unfold cos_in",
      confidence = 0.5 ),
    ( tacticText = "unfold cos_pt",
      confidence = 0.5 ),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "unfold cos_increasing",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold continuity_pt_pt",
      confidence = 0.5 ),
    ( tacticText = "unfold continuity",
      confidence = 0.5 ),
    ( tacticText = "apply continuity_pt",
      confidence = 0.5 ) ] )
STATE
 |- (continuity (fun x : R => let (a, _) := exist_cos x in a))
----
 |- (continuity (fun x : R => let (a, _) := exist_cos x in a)) OUTPUT
unfold Rminus
intros
intros ?
unfold atan_exp
unfold Rsqrt
unfold atan_increasing
unfold Ratan_increasing
apply derivable_pt_pt_0
apply derivable_pt_pt
unfold atan_increasing_exp
Prediction takes 0.11517190933227539 seconds
( textPrediction = [
    ( tacticText = "unfold Rminus",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold atan_exp",
      confidence = 0.5 ),
    ( tacticText = "unfold Rsqrt",
      confidence = 0.5 ),
    ( tacticText = "unfold atan_increasing",
      confidence = 0.5 ),
    ( tacticText = "unfold Ratan_increasing",
      confidence = 0.5 ),
    ( tacticText = "apply derivable_pt_pt_0",
      confidence = 0.5 ),
    ( tacticText = "apply derivable_pt_pt",
      confidence = 0.5 ),
    ( tacticText = "unfold atan_increasing_exp",
      confidence = 0.5 ) ] )
STATE
 |- (continuity cos)
----
 |- (continuity cos) OUTPUT
unfold continuity_pt
unfold cos
unfold cos_in
unfold cos_pt
split
unfold cos_increasing
intros ?
unfold continuity_pt_pt
unfold continuity
apply continuity_pt
Prediction takes 0.0919790267944336 seconds
( textPrediction = [
    ( tacticText = "unfold continuity_pt",
      confidence = 0.5 ),
    ( tacticText = "unfold cos",
      confidence = 0.5 ),
    ( tacticText = "unfold cos_in",
      confidence = 0.5 ),
    ( tacticText = "unfold cos_pt",
      confidence = 0.5 ),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "unfold cos_increasing",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold continuity_pt_pt",
      confidence = 0.5 ),
    ( tacticText = "unfold continuity",
      confidence = 0.5 ),
    ( tacticText = "apply continuity_pt",
      confidence = 0.5 ) ] )
STATE
 |- (continuity (fun x : R => let (a, _) := exist_cos x in a))
----
 |- (continuity (fun x : R => let (a, _) := exist_cos x in a)) OUTPUT
unfold Rminus
intros
intros ?
unfold atan_exp
unfold Rsqrt
unfold atan_increasing
unfold Ratan_increasing
apply derivable_pt_pt_0
apply derivable_pt_pt
unfold atan_increasing_exp
Prediction takes 0.13726043701171875 seconds
( textPrediction = [
    ( tacticText = "unfold Rminus",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold atan_exp",
      confidence = 0.5 ),
    ( tacticText = "unfold Rsqrt",
      confidence = 0.5 ),
    ( tacticText = "unfold atan_increasing",
      confidence = 0.5 ),
    ( tacticText = "unfold Ratan_increasing",
      confidence = 0.5 ),
    ( tacticText = "apply derivable_pt_pt_0",
      confidence = 0.5 ),
    ( tacticText = "apply derivable_pt_pt",
      confidence = 0.5 ),
    ( tacticText = "unfold atan_increasing_exp",
      confidence = 0.5 ) ] )
STATE
x : R |- (continuity_pt (fun x : R => let (a, _) := exist_cos x in a) x)
----
x : R |- (continuity_pt (fun x : R => let (a, _) := exist_cos x in a) x) OUTPUT
unfold Rminus
unfold derivable_pt_lim
unfold derivable_pt
unfold continuity_pt
unfold derive_pt
unfold derivable_pt_lim_lim
destruct (Rcase_abs x)
case (Rcase_abs x)
destruct (Rcase_abs_abs x)
unfold derivable_pt_lim in H
Prediction takes 0.18534350395202637 seconds
( textPrediction = [
    ( tacticText = "unfold Rminus",
      confidence = 0.5 ),
    ( tacticText = "unfold derivable_pt_lim",
      confidence = 0.5 ),
    ( tacticText = "unfold derivable_pt",
      confidence = 0.5 ),
    ( tacticText = "unfold continuity_pt",
      confidence = 0.5 ),
    ( tacticText = "unfold derive_pt",
      confidence = 0.5 ),
    ( tacticText = "unfold derivable_pt_lim_lim",
      confidence = 0.5 ),
    ( tacticText = "destruct (Rcase_abs x)",
      confidence = 0.5 ),
    ( tacticText = "case (Rcase_abs x)",
      confidence = 0.5 ),
    ( tacticText = "destruct (Rcase_abs_abs x)",
      confidence = 0.5 ),
    ( tacticText = "unfold derivable_pt_lim in H",
      confidence = 0.5 ) ] )
STATE
 |- (continuity cos)
----
 |- (continuity cos) OUTPUT
unfold continuity_pt
unfold cos
unfold cos_in
unfold cos_pt
split
unfold cos_increasing
intros ?
unfold continuity_pt_pt
unfold continuity
apply continuity_pt
Prediction takes 0.13353896141052246 seconds
( textPrediction = [
    ( tacticText = "unfold continuity_pt",
      confidence = 0.5 ),
    ( tacticText = "unfold cos",
      confidence = 0.5 ),
    ( tacticText = "unfold cos_in",
      confidence = 0.5 ),
    ( tacticText = "unfold cos_pt",
      confidence = 0.5 ),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "unfold cos_increasing",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold continuity_pt_pt",
      confidence = 0.5 ),
    ( tacticText = "unfold continuity",
      confidence = 0.5 ),
    ( tacticText = "apply continuity_pt",
      confidence = 0.5 ) ] )
STATE
 |- (continuity (fun x : R => let (a, _) := exist_cos x in a))
----
 |- (continuity (fun x : R => let (a, _) := exist_cos x in a)) OUTPUT
unfold Rminus
intros
intros ?
unfold atan_exp
unfold Rsqrt
unfold atan_increasing
unfold Ratan_increasing
apply derivable_pt_pt_0
apply derivable_pt_pt
unfold atan_increasing_exp
Prediction takes 0.17526698112487793 seconds
( textPrediction = [
    ( tacticText = "unfold Rminus",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold atan_exp",
      confidence = 0.5 ),
    ( tacticText = "unfold Rsqrt",
      confidence = 0.5 ),
    ( tacticText = "unfold atan_increasing",
      confidence = 0.5 ),
    ( tacticText = "unfold Ratan_increasing",
      confidence = 0.5 ),
    ( tacticText = "apply derivable_pt_pt_0",
      confidence = 0.5 ),
    ( tacticText = "apply derivable_pt_pt",
      confidence = 0.5 ),
    ( tacticText = "unfold atan_increasing_exp",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
 |- Integral_domain
----
 |- Integral_domain OUTPUT
intros ?
constructor
intros
red
firstorder
auto with zarith
auto
split
auto with sets
unfold rel
Prediction takes 2.777541160583496 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "firstorder",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "auto with sets",
      confidence = 0.5 ),
    ( tacticText = "unfold rel",
      confidence = 0.5 ) ] )
STATE
 |- (forall x y : R, x * y == 0 -> x == 0 \/ y == 0)
----
 |- (forall x y : R, x * y == 0 -> x == 0 \/ y == 0) OUTPUT
intros
intros ?
exact eq_sym
left
auto with *
right
red
trivial
auto with real
auto with relations
Prediction takes 0.0929725170135498 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "exact eq_sym",
      confidence = 0.5 ),
    (tacticText = "left", confidence = 0.5),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    (tacticText = "right", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "auto with relations",
      confidence = 0.5 ) ] )
STATE
x : R, y : R, H : (x * y == 0) |- (x == 0 \/ y == 0)
----
x : R, y : R, H : (x * y == 0) |- (x == 0 \/ y == 0) OUTPUT
right
left
auto with real
auto
auto with relations
apply eq_sym
assumption
apply H
apply eq_not_eq
auto with *
Prediction takes 0.12459564208984375 seconds
( textPrediction = [
    (tacticText = "right", confidence = 0.5),
    (tacticText = "left", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "auto with relations",
      confidence = 0.5 ),
    ( tacticText = "apply eq_sym",
      confidence = 0.5 ),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    (tacticText = "apply H", confidence = 0.5),
    ( tacticText = "apply eq_not_eq",
      confidence = 0.5 ),
    ( tacticText = "auto with *",
      confidence = 0.5 ) ] )
STATE
x : R, y : R, H : (x * y == 0) |- (y == 0)
----
x : R, y : R, H : (x * y == 0) |- (y == 0) OUTPUT
reflexivity
rewrite H
auto with real
assumption
easy
apply H
symmetry
auto
subst
ring
Prediction takes 0.07931184768676758 seconds
( textPrediction = [
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "rewrite H", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "apply H", confidence = 0.5),
    (tacticText = "symmetry", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    (tacticText = "ring", confidence = 0.5) ] )
STATE
x : R, y : R, H : (x * y == 0) |- (x == 0)
----
x : R, y : R, H : (x * y == 0) |- (x == 0) OUTPUT
reflexivity
auto with real
rewrite H
assumption
easy
auto
apply H
symmetry
rewrite <- H
auto with *
Prediction takes 0.07585310935974121 seconds
( textPrediction = [
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "rewrite H", confidence = 0.5),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "apply H", confidence = 0.5),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "auto with *",
      confidence = 0.5 ) ] )
STATE
x : R |- (forall y : R, x * y == 0 -> x == 0 \/ y == 0)
----
x : R |- (forall y : R, x * y == 0 -> x == 0 \/ y == 0) OUTPUT
intros ?
intros
exact Rplus_0_l
exact Rmult_0_l
exact Private_Tac.eq_sym
exact Rplus_0_r
auto with real
exact Rmult_0_r
exact eq_sym
exact eq_not_eq
Prediction takes 0.14685893058776855 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "exact Rplus_0_l",
      confidence = 0.5 ),
    ( tacticText = "exact Rmult_0_l",
      confidence = 0.5 ),
    ( tacticText = "exact Private_Tac.eq_sym",
      confidence = 0.5 ),
    ( tacticText = "exact Rplus_0_r",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "exact Rmult_0_r",
      confidence = 0.5 ),
    ( tacticText = "exact eq_sym",
      confidence = 0.5 ),
    ( tacticText = "exact eq_not_eq",
      confidence = 0.5 ) ] )
STATE
 |- Integral_domain
----
 |- Integral_domain OUTPUT
intros ?
constructor
intros
red
firstorder
auto with zarith
auto
split
auto with sets
unfold rel
Prediction takes 0.08148026466369629 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "firstorder",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "auto with sets",
      confidence = 0.5 ),
    ( tacticText = "unfold rel",
      confidence = 0.5 ) ] )
STATE
 |- (forall x y : R, x * y == 0 -> x == 0 \/ y == 0)
----
 |- (forall x y : R, x * y == 0 -> x == 0 \/ y == 0) OUTPUT
intros
intros ?
exact eq_sym
left
auto with *
right
red
trivial
auto with real
auto with relations
Prediction takes 0.1212167739868164 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "exact eq_sym",
      confidence = 0.5 ),
    (tacticText = "left", confidence = 0.5),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    (tacticText = "right", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "auto with relations",
      confidence = 0.5 ) ] )
( textPrediction = [
    ( tacticText = "unfold RiemannInt",
      confidence = 0.5 ),
    ( tacticText = "unfold RiemannInt_SF",
      confidence = 0.5 ),
    ( tacticText = "unfold Riemann_integrable",
      confidence = 0.5 ),
    ( tacticText = "apply RiemannInt_SF",
      confidence = 0.5 ),
    ( tacticText = "apply RiemannInt_P4",
      confidence = 0.5 ),
    ( tacticText = "unfold fct_cte c",
      confidence = 0.5 ),
    ( tacticText = "apply RiemannInt_P2",
      confidence = 0.5 ),
    ( tacticText = "apply fct_cte c",
      confidence = 0.5 ),
    ( tacticText = "apply Riemann_integrable_integrable",
      confidence = 0.5 ),
    ( tacticText = "apply StepFun_P4",
      confidence = 0.5 ) ] )
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
starting proving server with connection through their stdin
using textmode optiontext
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
 |- (forall a b : R, Rabs (a + b) <= Rabs a + Rabs b)
----
 |- (forall a b : R, Rabs (a + b) <= Rabs a + Rabs b) OUTPUT
intros
intros ?
intros until b
apply Rplus_le_contrapositive_le_contrapositive_contrapositive_le
apply Rplus_le_contrapositive_contrapositive_le_contrapositive_le
unfold Rabs_dist
red
apply Rplus_le_contrapositive_contrapositive_le
exact Rplus_le_contrapositive_contrapositive_le
apply Rplus_le_constant_contrapositive_contrapositive_le
Prediction takes 3.067586898803711 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "intros until b",
      confidence = 0.5 ),
    ( tacticText = "apply Rplus_le_contrapositive_le_contrapositive_contrapositive_le",
      confidence = 0.5 ),
    ( tacticText = "apply Rplus_le_contrapositive_contrapositive_le_contrapositive_le",
      confidence = 0.5 ),
    ( tacticText = "unfold Rabs_dist",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "apply Rplus_le_contrapositive_contrapositive_le",
      confidence = 0.5 ),
    ( tacticText = "exact Rplus_le_contrapositive_contrapositive_le",
      confidence = 0.5 ),
    ( tacticText = "apply Rplus_le_constant_contrapositive_contrapositive_le",
      confidence = 0.5 ) ] )
STATE
a : R, b : R |- (Rabs (a + b) <= Rabs a + Rabs b)
----
a : R, b : R |- (Rabs (a + b) <= Rabs a + Rabs b) OUTPUT
apply Rabs_triang
rewrite Rplus_opp_r
rewrite Rabs_mult
unfold Rminus
unfold Rabs
rewrite Rabs_right
rewrite Rabs_Ropp
rewrite Rplus_comm
rewrite Rabs_R0
rewrite Rplus_opp_l
Prediction takes 0.1070868968963623 seconds
( textPrediction = [
    ( tacticText = "apply Rabs_triang",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_opp_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rabs_mult",
      confidence = 0.5 ),
    ( tacticText = "unfold Rminus",
      confidence = 0.5 ),
    ( tacticText = "unfold Rabs",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rabs_right",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rabs_Ropp",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rabs_R0",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_opp_l",
      confidence = 0.5 ) ] )
STATE
a : R |- (forall b : R, Rabs (a + b) <= Rabs a + Rabs b)
----
a : R |- (forall b : R, Rabs (a + b) <= Rabs a + Rabs b) OUTPUT
intros
intros ?
unfold Rabs
intros until b
assert (Rabs a <= Rabs a + Rabs b)
cut (Rabs a <= Rabs a + Rabs b)
cut (Rabs a <= Rabs a)
assert (Rabs a <= Rabs b)
cut (Rabs a <= Rabs b)
assert (Rabs a <= Rabs a)
Prediction takes 0.1784820556640625 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold Rabs",
      confidence = 0.5 ),
    ( tacticText = "intros until b",
      confidence = 0.5 ),
    ( tacticText = "assert (Rabs a <= Rabs a + Rabs b)",
      confidence = 0.5 ),
    ( tacticText = "cut (Rabs a <= Rabs a + Rabs b)",
      confidence = 0.5 ),
    ( tacticText = "cut (Rabs a <= Rabs a)",
      confidence = 0.5 ),
    ( tacticText = "assert (Rabs a <= Rabs b)",
      confidence = 0.5 ),
    ( tacticText = "cut (Rabs a <= Rabs b)",
      confidence = 0.5 ),
    ( tacticText = "assert (Rabs a <= Rabs a)",
      confidence = 0.5 ) ] )
STATE
a : R, b : R |- (Rabs (a + b) <= Rabs a + Rabs b)
----
a : R, b : R |- (Rabs (a + b) <= Rabs a + Rabs b) OUTPUT
apply Rabs_triang
rewrite Rplus_opp_r
rewrite Rabs_mult
unfold Rminus
unfold Rabs
rewrite Rabs_right
rewrite Rabs_Ropp
rewrite Rplus_comm
rewrite Rabs_R0
rewrite Rplus_opp_l
Prediction takes 0.11022734642028809 seconds
( textPrediction = [
    ( tacticText = "apply Rabs_triang",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_opp_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rabs_mult",
      confidence = 0.5 ),
    ( tacticText = "unfold Rminus",
      confidence = 0.5 ),
    ( tacticText = "unfold Rabs",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rabs_right",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rabs_Ropp",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rabs_R0",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_opp_l",
      confidence = 0.5 ) ] )
STATE
a : R, b : R |- (Rabs (a + b) <= Rabs a + Rabs b)
----
a : R, b : R |- (Rabs (a + b) <= Rabs a + Rabs b) OUTPUT
apply Rabs_triang
rewrite Rplus_opp_r
rewrite Rabs_mult
unfold Rminus
unfold Rabs
rewrite Rabs_right
rewrite Rabs_Ropp
rewrite Rplus_comm
rewrite Rabs_R0
rewrite Rplus_opp_l
Prediction takes 0.10292649269104004 seconds
( textPrediction = [
    ( tacticText = "apply Rabs_triang",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_opp_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rabs_mult",
      confidence = 0.5 ),
    ( tacticText = "unfold Rminus",
      confidence = 0.5 ),
    ( tacticText = "unfold Rabs",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rabs_right",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rabs_Ropp",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rabs_R0",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_opp_l",
      confidence = 0.5 ) ] )
STATE
a : R, b : R |- (Rabs (a + b) <= Rabs a + Rabs b)
----
a : R, b : R |- (Rabs (a + b) <= Rabs a + Rabs b) OUTPUT
apply Rabs_triang
rewrite Rplus_opp_r
rewrite Rabs_mult
unfold Rminus
unfold Rabs
rewrite Rabs_right
rewrite Rabs_Ropp
rewrite Rplus_comm
rewrite Rabs_R0
rewrite Rplus_opp_l
Prediction takes 0.1116783618927002 seconds
( textPrediction = [
    ( tacticText = "apply Rabs_triang",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_opp_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rabs_mult",
      confidence = 0.5 ),
    ( tacticText = "unfold Rminus",
      confidence = 0.5 ),
    ( tacticText = "unfold Rabs",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rabs_right",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rabs_Ropp",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rabs_R0",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_opp_l",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
 |- (forall (l : Rlist) (a x : R), In x (insert l a) <-> x = a \/ In x l)
----
 |- (forall (l : Rlist) (a x : R), In x (insert l a) <-> x = a \/ In x l) OUTPUT
intros
intros ?
induction l
split
simpl
unfold In
induction 1
unfold a
red
unfold c
Prediction takes 3.291633129119873 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "induction l",
      confidence = 0.5 ),
    (tacticText = "split", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "unfold In", confidence = 0.5),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    (tacticText = "unfold a", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "unfold c", confidence = 0.5) ] )
STATE
l : Rlist, a : R, x : R |- (In x (insert l a) <-> x = a \/ In x l)
----
l : Rlist, a : R, x : R |- (In x (insert l a) <-> x = a \/ In x l) OUTPUT
split
intros ?
simpl
induction l
intros
elim (H a)
rewrite (H a)
case (H a)
rewrite In_remove
rewrite In_nil
Prediction takes 0.0832822322845459 seconds
( textPrediction = [
    (tacticText = "split", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "induction l",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "elim (H a)",
      confidence = 0.5 ),
    ( tacticText = "rewrite (H a)",
      confidence = 0.5 ),
    ( tacticText = "case (H a)",
      confidence = 0.5 ),
    ( tacticText = "rewrite In_remove",
      confidence = 0.5 ),
    ( tacticText = "rewrite In_nil",
      confidence = 0.5 ) ] )
STATE
l : Rlist, a : R, x : R |- (In x (insert l a) -> x = a \/ In x l)
----
l : Rlist, a : R, x : R |- (In x (insert l a) -> x = a \/ In x l) OUTPUT
intros ?
intros
induction l
simpl
auto
auto with real
elim H
elim (H a x)
elim (H a)
case (H a)
Prediction takes 0.09787869453430176 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction l",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "elim H", confidence = 0.5),
    ( tacticText = "elim (H a x)",
      confidence = 0.5 ),
    ( tacticText = "elim (H a)",
      confidence = 0.5 ),
    ( tacticText = "case (H a)",
      confidence = 0.5 ) ] )
STATE
l : Rlist, a : R, x : R, H : (In x (insert l a)) |- (x = a \/ In x l)
----
l : Rlist, a : R, x : R, H : (In x (insert l a)) |- (x = a \/ In x l) OUTPUT
left
right
elim H
auto
auto with real
assumption
inversion H
elim (H a x)
elim (H a)
elim (H x a)
Prediction takes 0.15748357772827148 seconds
( textPrediction = [
    (tacticText = "left", confidence = 0.5),
    (tacticText = "right", confidence = 0.5),
    (tacticText = "elim H", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    ( tacticText = "inversion H",
      confidence = 0.5 ),
    ( tacticText = "elim (H a x)",
      confidence = 0.5 ),
    ( tacticText = "elim (H a)",
      confidence = 0.5 ),
    ( tacticText = "elim (H x a)",
      confidence = 0.5 ) ] )
STATE
l : Rlist, a : R, x : R, H : (In x (insert l a)) |- (x = a)
----
l : Rlist, a : R, x : R, H : (In x (insert l a)) |- (x = a) OUTPUT
reflexivity
assumption
elim H
simpl
auto with real
apply H
rewrite H
rewrite <- H
elim (H a)
elim (H x)
Prediction takes 0.12897062301635742 seconds
( textPrediction = [
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    (tacticText = "elim H", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "apply H", confidence = 0.5),
    (tacticText = "rewrite H", confidence = 0.5),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "elim (H a)",
      confidence = 0.5 ),
    ( tacticText = "elim (H x)",
      confidence = 0.5 ) ] )
STATE
l : Rlist, a : R, x : R, H : (In x (insert l a)) |- (In x l)
----
l : Rlist, a : R, x : R, H : (In x (insert l a)) |- (In x l) OUTPUT
assumption
elim H
auto
apply H
exists a
applyRlist
apply (H a)
apply StepFun_Pd
apply StepFun_P1
apply StepFun_P5
Prediction takes 0.0896453857421875 seconds
( textPrediction = [
    ( tacticText = "assumption",
      confidence = 0.5 ),
    (tacticText = "elim H", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "apply H", confidence = 0.5),
    (tacticText = "exists a", confidence = 0.5),
    ( tacticText = "applyRlist",
      confidence = 0.5 ),
    ( tacticText = "apply (H a)",
      confidence = 0.5 ),
    ( tacticText = "apply StepFun_Pd",
      confidence = 0.5 ),
    ( tacticText = "apply StepFun_P1",
      confidence = 0.5 ),
    ( tacticText = "apply StepFun_P5",
      confidence = 0.5 ) ] )
STATE
l : Rlist, a : R, x : R, H : (In x (insert l a)) |- (x = a \/ In x l)
----
l : Rlist, a : R, x : R, H : (In x (insert l a)) |- (x = a \/ In x l) OUTPUT
left
right
elim H
auto
auto with real
assumption
inversion H
elim (H a x)
elim (H a)
elim (H x a)
Prediction takes 0.10872721672058105 seconds
( textPrediction = [
    (tacticText = "left", confidence = 0.5),
    (tacticText = "right", confidence = 0.5),
    (tacticText = "elim H", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    ( tacticText = "inversion H",
      confidence = 0.5 ),
    ( tacticText = "elim (H a x)",
      confidence = 0.5 ),
    ( tacticText = "elim (H a)",
      confidence = 0.5 ),
    ( tacticText = "elim (H x a)",
      confidence = 0.5 ) ] )
STATE
 |- (forall l1 l2 : Rlist, Rlength (cons_ORlist l1 l2) = (Rlength l1 + Rlength l2)%nat)
----
 |- (forall l1 l2 : Rlist, Rlength (cons_ORlist l1 l2) = (Rlength l1 + Rlength l2)%nat) OUTPUT
intros
simpl
induction l2
intros ?
induction l1
reflexivity
induction 1
auto
unfold Rlength
simpl in H
Prediction takes 0.06022214889526367 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "induction l2",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "induction l1",
      confidence = 0.5 ),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold Rlength",
      confidence = 0.5 ),
    ( tacticText = "simpl in H",
      confidence = 0.5 ) ] )
STATE
l1 : Rlist, l2 : Rlist |- (Rlength (cons_ORlist l1 l2) = (Rlength l1 + Rlength l2)%nat)
----
l1 : Rlist, l2 : Rlist |- (Rlength (cons_ORlist l1 l2) = (Rlength l1 + Rlength l2)%nat) OUTPUT
simpl
induction l1
ring
reflexivity
induction l2
auto
unfold Rlength
rewrite Nat.add_comm
rewrite Nat.add_succ_r
replace (Rlength l2) with (Rlength l1 + Rlength l2)%nat
Prediction takes 0.2868764400482178 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "induction l1",
      confidence = 0.5 ),
    (tacticText = "ring", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "induction l2",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold Rlength",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nat.add_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nat.add_succ_r",
      confidence = 0.5 ),
    ( tacticText = "replace (Rlength l2) with (Rlength l1 + Rlength l2)%nat",
      confidence = 0.5 ) ] )
STATE
l2 : Rlist |- (Rlength (cons_ORlist nil l2) = (Rlength nil + Rlength l2)%nat)
----
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
 |- (forall r1 r2 : RbaseSymbolsImpl.R, {r1 < r2} + {r1 = r2} + {r2 < r1})
----
 |- (forall r1 r2 : RbaseSymbolsImpl.R, {r1 < r2} + {r1 = r2} + {r2 < r1}) OUTPUT
intros ?
intros
right
intros until r1
intros until r2
red
induction r1
destruct r1
exact r1
induction r2
Prediction takes 3.1361591815948486 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "right", confidence = 0.5),
    ( tacticText = "intros until r1",
      confidence = 0.5 ),
    ( tacticText = "intros until r2",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "induction r1",
      confidence = 0.5 ),
    ( tacticText = "destruct r1",
      confidence = 0.5 ),
    (tacticText = "exact r1", confidence = 0.5),
    ( tacticText = "induction r2",
      confidence = 0.5 ) ] )
STATE
r1 : RbaseSymbolsImpl.R |- (forall r2 : RbaseSymbolsImpl.R, {r1 < r2} + {r1 = r2} + {r2 < r1})
----
r1 : RbaseSymbolsImpl.R |- (forall r2 : RbaseSymbolsImpl.R, {r1 < r2} + {r1 = r2} + {r2 < r1}) OUTPUT
intros ?
intros
right
simpl
destruct r1
intros until b
red
induction r1
auto with real
destruct r2
Prediction takes 0.11975622177124023 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "right", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct r1",
      confidence = 0.5 ),
    ( tacticText = "intros until b",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "induction r1",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "destruct r2",
      confidence = 0.5 ) ] )
STATE
r1 : RbaseSymbolsImpl.R, r2 : RbaseSymbolsImpl.R |- ({r1 < r2} + {r1 = r2} + {r2 < r1})
----
r1 : RbaseSymbolsImpl.R, r2 : RbaseSymbolsImpl.R |- ({r1 < r2} + {r1 = r2} + {r2 < r1}) OUTPUT
right
left
intros ?
auto with real
auto
destruct r1
destruct r2
elim H
auto with r1
auto with r2
Prediction takes 0.0674588680267334 seconds
( textPrediction = [
    (tacticText = "right", confidence = 0.5),
    (tacticText = "left", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "destruct r1",
      confidence = 0.5 ),
    ( tacticText = "destruct r2",
      confidence = 0.5 ),
    (tacticText = "elim H", confidence = 0.5),
    ( tacticText = "auto with r1",
      confidence = 0.5 ),
    ( tacticText = "auto with r2",
      confidence = 0.5 ) ] )
STATE
r1 : RbaseSymbolsImpl.R, r2 : RbaseSymbolsImpl.R |- (r2 < r1)
----
r1 : RbaseSymbolsImpl.R, r2 : RbaseSymbolsImpl.R |- (r2 < r1) OUTPUT
auto
easy
trivial
simpl
destruct r2
destruct r1
exact r2
exact r1
apply Rsqr
apply Rsqr_pos
Prediction takes 0.08186221122741699 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct r2",
      confidence = 0.5 ),
    ( tacticText = "destruct r1",
      confidence = 0.5 ),
    (tacticText = "exact r2", confidence = 0.5),
    (tacticText = "exact r1", confidence = 0.5),
    ( tacticText = "apply Rsqr",
      confidence = 0.5 ),
    ( tacticText = "apply Rsqr_pos",
      confidence = 0.5 ) ] )
STATE
r1 : RbaseSymbolsImpl.R, r2 : RbaseSymbolsImpl.R |- ({r1 < r2} + {r1 = r2})
----
r1 : RbaseSymbolsImpl.R, r2 : RbaseSymbolsImpl.R |- ({r1 < r2} + {r1 = r2}) OUTPUT
right
left
intros ?
auto with real
auto
destruct r1
destruct r2
auto with r1
auto with r2
auto with rorder
Prediction takes 0.06506824493408203 seconds
( textPrediction = [
    (tacticText = "right", confidence = 0.5),
    (tacticText = "left", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "destruct r1",
      confidence = 0.5 ),
    ( tacticText = "destruct r2",
      confidence = 0.5 ),
    ( tacticText = "auto with r1",
      confidence = 0.5 ),
    ( tacticText = "auto with r2",
      confidence = 0.5 ),
    ( tacticText = "auto with rorder",
      confidence = 0.5 ) ] )
STATE
r1 : RbaseSymbolsImpl.R, r2 : RbaseSymbolsImpl.R |- (r1 = r2)
----
r1 : RbaseSymbolsImpl.R, r2 : RbaseSymbolsImpl.R |- (r1 = r2) OUTPUT
auto
easy
symmetry
reflexivity
trivial
destruct r2
destruct r1
rewrite r1
rewrite r2Rsqr
rewrite <- r1
Prediction takes 0.12940311431884766 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "destruct r2",
      confidence = 0.5 ),
    ( tacticText = "destruct r1",
      confidence = 0.5 ),
    ( tacticText = "rewrite r1",
      confidence = 0.5 ),
    ( tacticText = "rewrite r2Rsqr",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- r1",
      confidence = 0.5 ) ] )
STATE
r1 : RbaseSymbolsImpl.R, r2 : RbaseSymbolsImpl.R |- (r1 < r2)
----
r1 : RbaseSymbolsImpl.R, r2 : RbaseSymbolsImpl.R |- (r1 < r2) OUTPUT
auto
easy
trivial
simpl
destruct r2
destruct r1
exact r1
exact r2
apply Rsqr
apply Rsqr_pos
Prediction takes 0.08253288269042969 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct r2",
      confidence = 0.5 ),
    ( tacticText = "destruct r1",
      confidence = 0.5 ),
    (tacticText = "exact r1", confidence = 0.5),
    (tacticText = "exact r2", confidence = 0.5),
    ( tacticText = "apply Rsqr",
      confidence = 0.5 ),
    ( tacticText = "apply Rsqr_pos",
      confidence = 0.5 ) ] )
Model Loaded
0
STATE
 |- (forall r1 r2 : R, r1 >= r2 -> ~ r1 < r2)
----
 |- (forall r1 r2 : R, r1 >= r2 -> ~ r1 < r2) OUTPUT
intros
intros ?
red
auto with real
intros until r
intuition
intros until r1
auto
unfold Rle_antisym
intros until r2
Prediction takes 2.888181209564209 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "intros until r",
      confidence = 0.5 ),
    (tacticText = "intuition", confidence = 0.5),
    ( tacticText = "intros until r1",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold Rle_antisym",
      confidence = 0.5 ),
    ( tacticText = "intros until r2",
      confidence = 0.5 ) ] )
STATE
r1 : R, r2 : R, H : (r1 >= r2) |- (~ r1 < r2)
----
r1 : R, r2 : R, H : (r1 >= r2) |- (~ r1 < r2) OUTPUT
auto with real
intros ?
right
left
apply Rlt_le
apply Rlt_lt
apply Rle_lt
apply Rlt_not_lt
rewrite <- H
apply Rge_lt
Prediction takes 0.0983119010925293 seconds
( textPrediction = [
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "right", confidence = 0.5),
    (tacticText = "left", confidence = 0.5),
    ( tacticText = "apply Rlt_le",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_lt",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_lt",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_not_lt",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "apply Rge_lt",
      confidence = 0.5 ) ] )
STATE
r1 : R, r2 : R, H : (r1 >= r2), H0 : (r1 < r2) |- False
----
r1 : R, r2 : R, H : (r1 >= r2), H0 : (r1 < r2) |- False OUTPUT
apply H
contradiction
assumption
auto
elim H
apply H in H
apply H0
apply H in H0
rewrite H in H
apply Rlt_trans with r1
Prediction takes 0.09586739540100098 seconds
( textPrediction = [
    (tacticText = "apply H", confidence = 0.5),
    ( tacticText = "contradiction",
      confidence = 0.5 ),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "elim H", confidence = 0.5),
    ( tacticText = "apply H in H",
      confidence = 0.5 ),
    (tacticText = "apply H0", confidence = 0.5),
    ( tacticText = "apply H in H0",
      confidence = 0.5 ),
    ( tacticText = "rewrite H in H",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_trans with r1",
      confidence = 0.5 ) ] )
STATE
r1 : R |- (forall r2 : R, r1 >= r2 -> ~ r1 < r2)
----
r1 : R |- (forall r2 : R, r1 >= r2 -> ~ r1 < r2) OUTPUT
intros ?
intros
auto with real
unfold Rle
red
induction r1
induction 2
destruct 1
induction r
induction r2
Prediction takes 0.06000471115112305 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "unfold Rle",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "induction r1",
      confidence = 0.5 ),
    ( tacticText = "induction 2",
      confidence = 0.5 ),
    ( tacticText = "destruct 1",
      confidence = 0.5 ),
    ( tacticText = "induction r",
      confidence = 0.5 ),
    ( tacticText = "induction r2",
      confidence = 0.5 ) ] )
STATE
r1 : R, r2 : R |- (r1 >= r2 -> ~ r1 < r2)
----
r1 : R, r2 : R |- (r1 >= r2 -> ~ r1 < r2) OUTPUT
intros ?
intros
auto with real
intuition
unfold Rle
auto
red
apply Rle_lt
apply Rlt_le
unfold Rle in H
Prediction takes 0.08662128448486328 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "intuition", confidence = 0.5),
    ( tacticText = "unfold Rle",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "apply Rle_lt",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_le",
      confidence = 0.5 ),
    ( tacticText = "unfold Rle in H",
      confidence = 0.5 ) ] )
STATE
r1 : R, r2 : R, H : (r1 >= r2) |- (~ r1 < r2)
----
r1 : R, r2 : R, H : (r1 >= r2) |- (~ r1 < r2) OUTPUT
auto with real
intros ?
right
left
apply Rlt_le
apply Rlt_lt
apply Rle_lt
apply Rlt_not_lt
rewrite <- H
apply Rge_lt
Prediction takes 0.08400154113769531 seconds
( textPrediction = [
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "right", confidence = 0.5),
    (tacticText = "left", confidence = 0.5),
    ( tacticText = "apply Rlt_le",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_lt",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_lt",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_not_lt",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "apply Rge_lt",
      confidence = 0.5 ) ] )
STATE
 |- (forall r1 r2 : R, r1 = r2 -> r1 <= r2)
----
 |- (forall r1 r2 : R, r1 = r2 -> r1 <= r2) OUTPUT
intros
intros ?
auto with real
red
unfold Rle_antisym
auto
unfold Rsqr
intros until r1
intuition
intros until r
Prediction takes 0.06551432609558105 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold Rle_antisym",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold Rsqr",
      confidence = 0.5 ),
    ( tacticText = "intros until r1",
      confidence = 0.5 ),
    (tacticText = "intuition", confidence = 0.5),
    ( tacticText = "intros until r",
      confidence = 0.5 ) ] )
STATE
r1 : R, r2 : R, H : (r1 = r2) |- (r1 <= r2)
----
r1 : R, r2 : R, H : (r1 = r2) |- (r1 <= r2) OUTPUT
auto with real
assumption
auto
elim H
apply Rlt_le
apply Rle_antisym
intuition
rewrite H
rewrite <- H
apply Rle_lt
Prediction takes 0.062486886978149414 seconds
( textPrediction = [
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "elim H", confidence = 0.5),
    ( tacticText = "apply Rlt_le",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_antisym",
      confidence = 0.5 ),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "rewrite H", confidence = 0.5),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_lt",
      confidence = 0.5 ) ] )
STATE
r1 : R |- (forall r2 : R, r1 = r2 -> r1 <= r2)
----
r1 : R |- (forall r2 : R, r1 = r2 -> r1 <= r2) OUTPUT
intros ?
intros
auto with real
unfold Rle
induction r1
auto
destruct 1
intros until r1
unfold Rsqr
apply Rle_antisym
Prediction takes 0.09317564964294434 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "unfold Rle",
      confidence = 0.5 ),
    ( tacticText = "induction r1",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "destruct 1",
      confidence = 0.5 ),
    ( tacticText = "intros until r1",
      confidence = 0.5 ),
    ( tacticText = "unfold Rsqr",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_antisym",
      confidence = 0.5 ) ] )
STATE
r1 : R, r2 : R |- (r1 = r2 -> r1 <= r2)
----
r1 : R, r2 : R |- (r1 = r2 -> r1 <= r2) OUTPUT
intros ?
intros
auto with real
intuition
auto
unfold Rle
apply Rle_antisym
unfold Rsqr
destruct 1
apply Rlt_le
Prediction takes 0.09932780265808105 seconds
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
 |- (forall (R1 R2 : ConstructiveReals) (f : ConstructiveRealsMorphism R1 R2) (x : CRcarrier R1) (n : nat), orderEq (CRcarrier R2) (CRlt R2) (CRmorph R1 R2 f (CRmult R1 x (CR_of_Q R1 (Z.of_nat n # 1)))) (CRmult R2 (CRmorph R1 R2 f x) (CR_of_Q R2 (Z.of_nat n # 1))))
----
 |- (forall (R1 R2 : ConstructiveReals) (f : ConstructiveRealsMorphism R1 R2) (x : CRcarrier R1) (n : nat), orderEq (CRcarrier R2) (CRlt R2) (CRmorph R1 R2 f (CRmult R1 x (CR_of_Q R1 (Z.of_nat n # 1)))) (CRmult R2 (CRmorph R1 R2 f x) (CR_of_Q R2 (Z.of_nat n # 1)))) OUTPUT
intros
intros ?
simpl
red
induction 1
exact (CRisRing R1)
unfold N2 (CRlt R2 (CR_of_Q R2 (CR_of_Q R1 # 1) (CR_of_Q R1 # 1))
unfold N2 (CRlt R2 (CR_of_of_Q R2 (Q R1 # 1) (CR_of_Q R1 # 1))
apply (CRlt R2 (CRmorph R1 R1 R2) (CRmorph R1 R1 R2 f (CR_of_of_Q R1 (Q R1 # 1)))
apply (CRlt R2 (CRmorph R1 R1 R2) (CRmorph R1 R1 R2 f x) (CR_of_of_Q R1 (Q R1 # 1))
Prediction takes 3.3137331008911133 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    ( tacticText = "exact (CRisRing R1)",
      confidence = 0.5 ),
    ( tacticText = "unfold N2 (CRlt R2 (CR_of_Q R2 (CR_of_Q R1 # 1) (CR_of_Q R1 # 1))",
      confidence = 0.5 ),
    ( tacticText = "unfold N2 (CRlt R2 (CR_of_of_Q R2 (Q R1 # 1) (CR_of_Q R1 # 1))",
      confidence = 0.5 ),
    ( tacticText = "apply (CRlt R2 (CRmorph R1 R1 R2) (CRmorph R1 R1 R2 f (CR_of_of_Q R1 (Q R1 # 1)))",
      confidence = 0.5 ),
    ( tacticText = "apply (CRlt R2 (CRmorph R1 R1 R2) (CRmorph R1 R1 R2 f x) (CR_of_of_Q R1 (Q R1 # 1))",
      confidence = 0.5 ) ] )
STATE
R1 : ConstructiveReals, R2 : ConstructiveReals, f : (ConstructiveRealsMorphism R1 R2), x : (CRcarrier R1), n : nat |- (orderEq (CRcarrier R2) (CRlt R2) (CRmorph R1 R2 f (CRmult R1 x (CR_of_Q R1 (Z.of_nat n # 1)))) (CRmult R2 (CRmorph R1 R2 f x) (CR_of_Q R2 (Z.of_nat n # 1))))
----
R1 : ConstructiveReals, R2 : ConstructiveReals, f : (ConstructiveRealsMorphism R1 R2), x : (CRcarrier R1), n : nat |- (orderEq (CRcarrier R2) (CRlt R2) (CRmorph R1 R2 f (CRmult R1 x (CR_of_Q R1 (Z.of_nat n # 1)))) (CRmult R2 (CRmorph R1 R2 f x) (CR_of_Q R2 (Z.of_nat n # 1)))) OUTPUT
apply CReq_refl
apply (CRisRingExt R2)
simpl
apply CReq_sym
apply CRisRing
apply (CRisRingExt R1)
destruct (CRisRing R2)
apply (CRisRingExt R2 _))
apply (CRle_trans R2 _ (CR_of_Q R2 (Z.pos n # 1))))
apply (CRle_trans R2 _ (CR_of_Q R2 (Z.pos n # 1)))
Prediction takes 0.30272626876831055 seconds
( textPrediction = [
    ( tacticText = "apply CReq_refl",
      confidence = 0.5 ),
    ( tacticText = "apply (CRisRingExt R2)",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "apply CReq_sym",
      confidence = 0.5 ),
    ( tacticText = "apply CRisRing",
      confidence = 0.5 ),
    ( tacticText = "apply (CRisRingExt R1)",
      confidence = 0.5 ),
    ( tacticText = "destruct (CRisRing R2)",
      confidence = 0.5 ),
    ( tacticText = "apply (CRisRingExt R2 _))",
      confidence = 0.5 ),
    ( tacticText = "apply (CRle_trans R2 _ (CR_of_Q R2 (Z.pos n # 1))))",
      confidence = 0.5 ),
    ( tacticText = "apply (CRle_trans R2 _ (CR_of_Q R2 (Z.pos n # 1)))",
      confidence = 0.5 ) ] )
STATE
R1 : ConstructiveReals |- (forall (R2 : ConstructiveReals) (f : ConstructiveRealsMorphism R1 R2) (x : CRcarrier R1) (n : nat), orderEq (CRcarrier R2) (CRlt R2) (CRmorph R1 R2 f (CRmult R1 x (CR_of_Q R1 (Z.of_nat n # 1)))) (CRmult R2 (CRmorph R1 R2 f x) (CR_of_Q R2 (Z.of_nat n # 1))))
----
R1 : ConstructiveReals |- (forall (R2 : ConstructiveReals) (f : ConstructiveRealsMorphism R1 R2) (x : CRcarrier R1) (n : nat), orderEq (CRcarrier R2) (CRlt R2) (CRmorph R1 R2 f (CRmult R1 x (CR_of_Q R1 (Z.of_nat n # 1)))) (CRmult R2 (CRmorph R1 R2 f x) (CR_of_Q R2 (Z.of_nat n # 1)))) OUTPUT
intros ?
intros
induction n
simpl
induction 2
apply CReq_refl
apply (CRisRingExt R2)
exact (CRisRingExt R2)
apply CRle_trans
apply (CRisRingExt R1)
Prediction takes 0.10855913162231445 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "induction 2",
      confidence = 0.5 ),
    ( tacticText = "apply CReq_refl",
      confidence = 0.5 ),
    ( tacticText = "apply (CRisRingExt R2)",
      confidence = 0.5 ),
    ( tacticText = "exact (CRisRingExt R2)",
      confidence = 0.5 ),
    ( tacticText = "apply CRle_trans",
      confidence = 0.5 ),
    ( tacticText = "apply (CRisRingExt R1)",
      confidence = 0.5 ) ] )
STATE
R1 : ConstructiveReals, R2 : ConstructiveReals |- (forall (f : ConstructiveRealsMorphism R1 R2) (x : CRcarrier R1) (n : nat), orderEq (CRcarrier R2) (CRlt R2) (CRmorph R1 R2 f (CRmult R1 x (CR_of_Q R1 (Z.of_nat n # 1)))) (CRmult R2 (CRmorph R1 R2 f x) (CR_of_Q R2 (Z.of_nat n # 1))))
----
R1 : ConstructiveReals, R2 : ConstructiveReals |- (forall (f : ConstructiveRealsMorphism R1 R2) (x : CRcarrier R1) (n : nat), orderEq (CRcarrier R2) (CRlt R2) (CRmorph R1 R2 f (CRmult R1 x (CR_of_Q R1 (Z.of_nat n # 1)))) (CRmult R2 (CRmorph R1 R2 f x) (CR_of_Q R2 (Z.of_nat n # 1)))) OUTPUT
intros
intros ?
simpl
induction n
split
apply CReq_refl
apply CRisRing
apply CReq_trans
apply CR_of_Q
apply CRmult_lt_compat
Prediction takes 0.08727335929870605 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "apply CReq_refl",
      confidence = 0.5 ),
    ( tacticText = "apply CRisRing",
      confidence = 0.5 ),
    ( tacticText = "apply CReq_trans",
      confidence = 0.5 ),
    ( tacticText = "apply CR_of_Q",
      confidence = 0.5 ),
    ( tacticText = "apply CRmult_lt_compat",
      confidence = 0.5 ) ] )
STATE
R1 : ConstructiveReals, R2 : ConstructiveReals, f : (ConstructiveRealsMorphism R1 R2), x : (CRcarrier R1), n : nat |- (orderEq (CRcarrier R2) (CRlt R2) (CRmorph R1 R2 f (CRmult R1 x (CR_of_Q R1 (Z.of_nat n # 1)))) (CRmult R2 (CRmorph R1 R2 f x) (CR_of_Q R2 (Z.of_nat n # 1))))
----
R1 : ConstructiveReals, R2 : ConstructiveReals, f : (ConstructiveRealsMorphism R1 R2), x : (CRcarrier R1), n : nat |- (orderEq (CRcarrier R2) (CRlt R2) (CRmorph R1 R2 f (CRmult R1 x (CR_of_Q R1 (Z.of_nat n # 1)))) (CRmult R2 (CRmorph R1 R2 f x) (CR_of_Q R2 (Z.of_nat n # 1)))) OUTPUT
apply CReq_refl
apply (CRisRingExt R2)
simpl
apply CReq_sym
apply CRisRing
apply (CRisRingExt R1)
destruct (CRisRing R2)
apply (CRisRingExt R2 _))
apply (CRle_trans R2 _ (CR_of_Q R2 (Z.pos n # 1))))
apply (CRle_trans R2 _ (CR_of_Q R2 (Z.pos n # 1)))
Prediction takes 0.33331751823425293 seconds
( textPrediction = [
    ( tacticText = "apply CReq_refl",
      confidence = 0.5 ),
    ( tacticText = "apply (CRisRingExt R2)",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "apply CReq_sym",
      confidence = 0.5 ),
    ( tacticText = "apply CRisRing",
      confidence = 0.5 ),
    ( tacticText = "apply (CRisRingExt R1)",
      confidence = 0.5 ),
    ( tacticText = "destruct (CRisRing R2)",
      confidence = 0.5 ),
    ( tacticText = "apply (CRisRingExt R2 _))",
      confidence = 0.5 ),
    ( tacticText = "apply (CRle_trans R2 _ (CR_of_Q R2 (Z.pos n # 1))))",
      confidence = 0.5 ),
    ( tacticText = "apply (CRle_trans R2 _ (CR_of_Q R2 (Z.pos n # 1)))",
      confidence = 0.5 ) ] )
STATE
R1 : ConstructiveReals, R2 : ConstructiveReals, f : (ConstructiveRealsMorphism R1 R2) |- (forall (x : CRcarrier R1) (n : nat), orderEq (CRcarrier R2) (CRlt R2) (CRmorph R1 R2 f (CRmult R1 x (CR_of_Q R1 (Z.of_nat n # 1)))) (CRmult R2 (CRmorph R1 R2 f x) (CR_of_Q R2 (Z.of_nat n # 1))))
----
l2 : Rlist |- (Rlength (cons_ORlist nil l2) = (Rlength nil + Rlength l2)%nat) OUTPUT
simpl
reflexivity
induction l2
ring
auto
rewrite Nat.add_comm
induction l1
simpl in H
induction l
simpl in *
Prediction takes 0.11857414245605469 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "induction l2",
      confidence = 0.5 ),
    (tacticText = "ring", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "rewrite Nat.add_comm",
      confidence = 0.5 ),
    ( tacticText = "induction l1",
      confidence = 0.5 ),
    ( tacticText = "simpl in H",
      confidence = 0.5 ),
    ( tacticText = "induction l",
      confidence = 0.5 ),
    ( tacticText = "simpl in *",
      confidence = 0.5 ) ] )
STATE
l2 : Rlist |- (Rlength l2 = Rlength l2)
----
l2 : Rlist |- (Rlength l2 = Rlength l2) OUTPUT
reflexivity
auto
simpl
induction l2
intros ?
induction l
easy
induction l1
auto with arith
destruct l2
Prediction takes 0.054177045822143555 seconds
( textPrediction = [
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "induction l2",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "induction l",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "induction l1",
      confidence = 0.5 ),
    ( tacticText = "auto with arith",
      confidence = 0.5 ),
    ( tacticText = "destruct l2",
      confidence = 0.5 ) ] )
STATE
r : R, l1 : Rlist, l2 : Rlist, IHl1 : (Rlength (cons_ORlist l1 l2) = (Rlength l1 + Rlength l2)%nat) |- (Rlength (cons_ORlist (cons r l1) l2) = (Rlength (cons r l1) + Rlength l2)%nat)
----
r : R, l1 : Rlist, l2 : Rlist, IHl1 : (Rlength (cons_ORlist l1 l2) = (Rlength l1 + Rlength l2)%nat) |- (Rlength (cons_ORlist (cons r l1) l2) = (Rlength (cons r l1) + Rlength l2)%nat) OUTPUT
simpl
ring
reflexivity
induction l1
auto
rewrite Nat.add_comm
induction l2
rewrite app_nil_r
rewrite <- H
rewrite (cons_comm l1)
Prediction takes 0.21336698532104492 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "ring", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "induction l1",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "rewrite Nat.add_comm",
      confidence = 0.5 ),
    ( tacticText = "induction l2",
      confidence = 0.5 ),
    ( tacticText = "rewrite app_nil_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "rewrite (cons_comm l1)",
      confidence = 0.5 ) ] )
STATE
l1 : Rlist |- (Rlength (cons_ORlist l1 nil) = (Rlength l1 + Rlength nil)%nat)
----
l1 : Rlist |- (Rlength (cons_ORlist l1 nil) = (Rlength l1 + Rlength nil)%nat) OUTPUT
simpl
ring
reflexivity
induction l1
auto
intros
rewrite app_nil_r
rewrite Nat.add_comm
induction l2
rewrite app_nil
Prediction takes 0.08276605606079102 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "ring", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "induction l1",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "rewrite app_nil_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nat.add_comm",
      confidence = 0.5 ),
    ( tacticText = "induction l2",
      confidence = 0.5 ),
    ( tacticText = "rewrite app_nil",
      confidence = 0.5 ) ] )
STATE
l1 : Rlist |- (Rlength (cons_ORlist l1 nil) = (Rlength l1 + 0)%nat)
----
l1 : Rlist |- (Rlength (cons_ORlist l1 nil) = (Rlength l1 + 0)%nat) OUTPUT
simpl
ring
reflexivity
induction l1
auto
rewrite Nat.add_comm
induction l2
ring_simpl
rewrite Nat.add_r
rewrite <- H
Prediction takes 0.08378791809082031 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "ring", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "induction l1",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "rewrite Nat.add_comm",
      confidence = 0.5 ),
    ( tacticText = "induction l2",
      confidence = 0.5 ),
    ( tacticText = "ring_simpl",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nat.add_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ) ] )
STATE
l1 : Rlist |- (forall l2 : Rlist, Rlength (cons_ORlist l1 l2) = (Rlength l1 + Rlength l2)%nat)
----
l1 : Rlist |- (forall l2 : Rlist, Rlength (cons_ORlist l1 l2) = (Rlength l1 + Rlength l2)%nat) OUTPUT
intros ?
intros
induction l1
simpl
induction l2
unfold Rlength
auto
intros until l2
intros until l1
induction l
Prediction takes 0.05984783172607422 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction l1",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "induction l2",
      confidence = 0.5 ),
    ( tacticText = "unfold Rlength",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "intros until l2",
      confidence = 0.5 ),
    ( tacticText = "intros until l1",
      confidence = 0.5 ),
    ( tacticText = "induction l",
      confidence = 0.5 ) ] )
STATE
 |- (forall l1 l2 : Rlist, Rlength (cons_ORlist l1 l2) = (Rlength l1 + Rlength l2)%nat)
----
 |- (forall l1 l2 : Rlist, Rlength (cons_ORlist l1 l2) = (Rlength l1 + Rlength l2)%nat) OUTPUT
intros
simpl
induction l2
intros ?
induction l1
reflexivity
induction 1
auto
unfold Rlength
simpl in H
Prediction takes 0.0847775936126709 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "induction l2",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "induction l1",
      confidence = 0.5 ),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold Rlength",
      confidence = 0.5 ),
    ( tacticText = "simpl in H",
      confidence = 0.5 ) ] )
STATE
l1 : Rlist, l2 : Rlist |- (Rlength (cons_ORlist l1 l2) = (Rlength l1 + Rlength l2)%nat)
----
l1 : Rlist, l2 : Rlist |- (Rlength (cons_ORlist l1 l2) = (Rlength l1 + Rlength l2)%nat) OUTPUT
simpl
induction l1
ring
reflexivity
induction l2
auto
unfold Rlength
rewrite Nat.add_comm
rewrite Nat.add_succ_r
replace (Rlength l2) with (Rlength l1 + Rlength l2)%nat
Prediction takes 0.21265220642089844 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "induction l1",
      confidence = 0.5 ),
    (tacticText = "ring", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "induction l2",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold Rlength",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nat.add_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nat.add_succ_r",
      confidence = 0.5 ),
    ( tacticText = "replace (Rlength l2) with (Rlength l1 + Rlength l2)%nat",
      confidence = 0.5 ) ] )
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
x : int, y : int, n : int |- ((x + y) << n = (x << n + y << n)%int63)
----
x : int, y : int, n : int |- ((x + y) << n = (x << n + y << n)%int63) OUTPUT
auto
rewrite add_comm
rewrite shiftl_spec
rewrite add_spec
rewrite Z.add_comm
rewrite bit_spec
case (is_zero x)
rewrite (is_zero x)
apply Z.add_small
rewrite add_spec_def
Prediction takes 3.228198766708374 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "rewrite add_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite add_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.add_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite bit_spec",
      confidence = 0.5 ),
    ( tacticText = "case (is_zero x)",
      confidence = 0.5 ),
    ( tacticText = "rewrite (is_zero x)",
      confidence = 0.5 ),
    ( tacticText = "apply Z.add_small",
      confidence = 0.5 ),
    ( tacticText = "rewrite add_spec_def",
      confidence = 0.5 ) ] )
STATE
x : int, y : int, n : int |- ((y + x) << n = (x << n + y << n)%int63)
----
x : int, y : int, n : int |- ((y + x) << n = (x << n + y << n)%int63) OUTPUT
rewrite add_comm
auto
rewrite add_spec
rewrite shiftl_spec
rewrite Z.add_comm
rewrite bit_spec
rewrite add_assoc
rewrite Z.add_assoc
rewrite add_spec_def
rewrite add_spec_r
Prediction takes 0.10764861106872559 seconds
( textPrediction = [
    ( tacticText = "rewrite add_comm",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "rewrite add_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.add_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite bit_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite add_assoc",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.add_assoc",
      confidence = 0.5 ),
    ( tacticText = "rewrite add_spec_def",
      confidence = 0.5 ),
    ( tacticText = "rewrite add_spec_r",
      confidence = 0.5 ) ] )
STATE
x : int, y : int, n : int |- ((x + y) << n = (x << n + y << n)%int63)
----
x : int, y : int, n : int |- ((x + y) << n = (x << n + y << n)%int63) OUTPUT
auto
rewrite add_comm
rewrite shiftl_spec
rewrite add_spec
rewrite Z.add_comm
rewrite bit_spec
case (is_zero x)
rewrite (is_zero x)
apply Z.add_small
rewrite add_spec_def
Prediction takes 0.11847686767578125 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "rewrite add_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite add_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.add_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite bit_spec",
      confidence = 0.5 ),
    ( tacticText = "case (is_zero x)",
      confidence = 0.5 ),
    ( tacticText = "rewrite (is_zero x)",
      confidence = 0.5 ),
    ( tacticText = "apply Z.add_small",
      confidence = 0.5 ),
    ( tacticText = "rewrite add_spec_def",
      confidence = 0.5 ) ] )
STATE
x : int, y : int, n : int |- ((y + x) << n = (x << n + y << n)%int63)
----
x : int, y : int, n : int |- ((y + x) << n = (x << n + y << n)%int63) OUTPUT
rewrite add_comm
auto
rewrite add_spec
rewrite shiftl_spec
rewrite Z.add_comm
rewrite bit_spec
rewrite add_assoc
rewrite Z.add_assoc
rewrite add_spec_def
rewrite add_spec_r
Prediction takes 0.1533374786376953 seconds
( textPrediction = [
    ( tacticText = "rewrite add_comm",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "rewrite add_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.add_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite bit_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite add_assoc",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.add_assoc",
      confidence = 0.5 ),
    ( tacticText = "rewrite add_spec_def",
      confidence = 0.5 ),
    ( tacticText = "rewrite add_spec_r",
      confidence = 0.5 ) ] )
STATE
x : int, y : int, n : int |- ((x + y) << n = (x << n + y << n)%int63)
----
x : int, y : int, n : int |- ((x + y) << n = (x << n + y << n)%int63) OUTPUT
auto
rewrite add_comm
rewrite shiftl_spec
rewrite add_spec
rewrite Z.add_comm
rewrite bit_spec
case (is_zero x)
rewrite (is_zero x)
apply Z.add_small
rewrite add_spec_def
Prediction takes 0.14423704147338867 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "rewrite add_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite add_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.add_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite bit_spec",
      confidence = 0.5 ),
    ( tacticText = "case (is_zero x)",
      confidence = 0.5 ),
    ( tacticText = "rewrite (is_zero x)",
      confidence = 0.5 ),
    ( tacticText = "apply Z.add_small",
      confidence = 0.5 ),
    ( tacticText = "rewrite add_spec_def",
      confidence = 0.5 ) ] )
STATE
x : int, y : int, n : int |- ((y + x) << n = (x << n + y << n)%int63)
----
x : int, y : int, n : int |- ((y + x) << n = (x << n + y << n)%int63) OUTPUT
rewrite add_comm
auto
rewrite add_spec
rewrite shiftl_spec
rewrite Z.add_comm
rewrite bit_spec
rewrite add_assoc
rewrite Z.add_assoc
rewrite add_spec_def
rewrite add_spec_r
Prediction takes 0.14424610137939453 seconds
( textPrediction = [
    ( tacticText = "rewrite add_comm",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "rewrite add_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.add_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite bit_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite add_assoc",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.add_assoc",
      confidence = 0.5 ),
    ( tacticText = "rewrite add_spec_def",
      confidence = 0.5 ),
    ( tacticText = "rewrite add_spec_r",
      confidence = 0.5 ) ] )
STATE
x : int, y : int, n : int |- ((x + y) << n = (x << n + y << n)%int63)
----
x : int, y : int, n : int |- ((x + y) << n = (x << n + y << n)%int63) OUTPUT
auto
rewrite add_comm
rewrite shiftl_spec
rewrite add_spec
rewrite Z.add_comm
rewrite bit_spec
case (is_zero x)
rewrite (is_zero x)
apply Z.add_small
rewrite add_spec_def
Prediction takes 0.15847420692443848 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "rewrite add_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite add_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.add_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite bit_spec",
      confidence = 0.5 ),
    ( tacticText = "case (is_zero x)",
      confidence = 0.5 ),
    ( tacticText = "rewrite (is_zero x)",
      confidence = 0.5 ),
    ( tacticText = "apply Z.add_small",
      confidence = 0.5 ),
    ( tacticText = "rewrite add_spec_def",
      confidence = 0.5 ) ] )
STATE
n : nat, rec : (int  int  int), i : int, j : int |- (0 <  (i)  0 <  (j)   (i) < ( (j) + 1) ^ 2  2 *  (j) < wB  ( j1 : int, 0 <  (j1)  2 ^ Z.of_nat n +  (j1) <=  (j)   (i) < ( (j1) + 1) ^ 2  2 *  (j1) < wB   (rec i j1) ^ 2 <=  (i) < ( (rec i j1) + 1) ^ 2)   (iter_sqrt n rec i j) ^ 2 <=  (i) < ( (iter_sqrt n rec i j) + 1) ^ 2)
----
n : nat, rec : (int  int  int), i : int, j : int |- (0 <  (i)  0 <  (j)   (i) < ( (j) + 1) ^ 2  2 *  (j) < wB  ( j1 : int, 0 <  (j1)  2 ^ Z.of_nat n +  (j1) <=  (j)   (i) < ( (j1) + 1) ^ 2  2 *  (j1) < wB   (rec i j1) ^ 2 <=  (i) < ( (rec i j1) + 1) ^ 2)   (iter_sqrt n rec i j) ^ 2 <=  (i) < ( (iter_sqrt n rec i j) + 1) ^ 2) OUTPUT
intros ?
clear j
auto with zarith
intros
Model Loaded
0
STATE
digits : positive, digits_ne_1 : (digits <> 1%positive), digits_gt_1 := spec_more_than_1_digit : (1 < Z.pos digits) |- (forall x : Z, [|x|] < wB)
----
digits : positive, digits_ne_1 : (digits <> 1%positive), digits_gt_1 := spec_more_than_1_digit : (1 < Z.pos digits) |- (forall x : Z, [|x|] < wB) OUTPUT
intros
unfold to_Z
auto with zarith
auto
induction x
red
unfold [|x|]
unfold Z.lt
unfold Z.le
unfold Z.mod
Prediction takes 2.7026214599609375 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold to_Z",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "induction x",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold [|x|]",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.lt",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.le",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.mod",
      confidence = 0.5 ) ] )
STATE
digits : positive, digits_ne_1 : (digits <> 1%positive), digits_gt_1 := spec_more_than_1_digit : (1 < Z.pos digits), x : Z |- ([|x|] < wB)
----
digits : positive, digits_ne_1 : (digits <> 1%positive), digits_gt_1 := spec_more_than_1_digit : (1 < Z.pos digits), x : Z |- ([|x|] < wB) OUTPUT
unfold to_Z
auto with zarith
apply Zmod_small
unfold wB
unfold Z.lt
unfold Z.le
apply Z.lt_le
apply Z.mod_small
apply Z.le_lt
apply Z.lt_ge
Prediction takes 0.11185812950134277 seconds
( textPrediction = [
    ( tacticText = "unfold to_Z",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    ( tacticText = "apply Zmod_small",
      confidence = 0.5 ),
    (tacticText = "unfold wB", confidence = 0.5),
    ( tacticText = "unfold Z.lt",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.le",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_le",
      confidence = 0.5 ),
    ( tacticText = "apply Z.mod_small",
      confidence = 0.5 ),
    ( tacticText = "apply Z.le_lt",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_ge",
      confidence = 0.5 ) ] )
STATE
digits : positive, digits_ne_1 : (digits <> 1%positive), digits_gt_1 := spec_more_than_1_digit : (1 < Z.pos digits), x : Z |- (x mod wB < wB)
----
digits : positive, digits_ne_1 : (digits <> 1%positive), digits_gt_1 := spec_more_than_1_digit : (1 < Z.pos digits), x : Z |- (x mod wB < wB) OUTPUT
unfold to_Z
auto with zarith
destruct wB
apply Z.mod_small
apply Zmod_small
unfold wB
apply Zmod_lt_le
apply Zmod_lt
apply Z.mod_lt
rewrite Z.mod_small
Prediction takes 0.09405183792114258 seconds
( textPrediction = [
    ( tacticText = "unfold to_Z",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    ( tacticText = "destruct wB",
      confidence = 0.5 ),
    ( tacticText = "apply Z.mod_small",
      confidence = 0.5 ),
    ( tacticText = "apply Zmod_small",
      confidence = 0.5 ),
    (tacticText = "unfold wB", confidence = 0.5),
    ( tacticText = "apply Zmod_lt_le",
      confidence = 0.5 ),
    ( tacticText = "apply Zmod_lt",
      confidence = 0.5 ),
    ( tacticText = "apply Z.mod_lt",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.mod_small",
      confidence = 0.5 ) ] )
STATE
digits : positive, digits_ne_1 : (digits <> 1%positive), digits_gt_1 := spec_more_than_1_digit : (1 < Z.pos digits), x : Z |- (x mod 0 < 0)
----
digits : positive, digits_ne_1 : (digits <> 1%positive), digits_gt_1 := spec_more_than_1_digit : (1 < Z.pos digits), x : Z |- (x mod 0 < 0) OUTPUT
unfold to_Z
auto with zarith
lia
destruct x
apply Z.mod_small
destruct wB
apply Zmod_small
rewrite Z.mod_small
apply Z.mod_lt
apply Zmod_lt
Prediction takes 0.09672117233276367 seconds
( textPrediction = [
    ( tacticText = "unfold to_Z",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "lia", confidence = 0.5),
    ( tacticText = "destruct x",
      confidence = 0.5 ),
    ( tacticText = "apply Z.mod_small",
      confidence = 0.5 ),
    ( tacticText = "destruct wB",
      confidence = 0.5 ),
    ( tacticText = "apply Zmod_small",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.mod_small",
      confidence = 0.5 ),
    ( tacticText = "apply Z.mod_lt",
      confidence = 0.5 ),
    ( tacticText = "apply Zmod_lt",
      confidence = 0.5 ) ] )
STATE
digits : positive, digits_ne_1 : (digits <> 1%positive), digits_gt_1 := spec_more_than_1_digit : (1 < Z.pos digits) |- (forall x : Z, x mod wB < wB)
----
digits : positive, digits_ne_1 : (digits <> 1%positive), digits_gt_1 := spec_more_than_1_digit : (1 < Z.pos digits) |- (forall x : Z, x mod wB < wB) OUTPUT
intros
unfold to_Z
auto with zarith
intros ?
auto
red
induction x
apply Zmod_small
exact Zmod_small
unfold Z.mod
Prediction takes 0.07832884788513184 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold to_Z",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "induction x",
      confidence = 0.5 ),
    ( tacticText = "apply Zmod_small",
      confidence = 0.5 ),
    ( tacticText = "exact Zmod_small",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.mod",
      confidence = 0.5 ) ] )
STATE
digits : positive, digits_ne_1 : (digits <> 1%positive), digits_gt_1 := spec_more_than_1_digit : (1 < Z.pos digits), x : Z |- (x mod wB < wB)
----
digits : positive, digits_ne_1 : (digits <> 1%positive), digits_gt_1 := spec_more_than_1_digit : (1 < Z.pos digits), x : Z |- (x mod wB < wB) OUTPUT
unfold to_Z
auto with zarith
destruct wB
apply Z.mod_small
apply Zmod_small
unfold wB
apply Zmod_lt_le
apply Zmod_lt
apply Z.mod_lt
rewrite Z.mod_small
Prediction takes 0.0927727222442627 seconds
( textPrediction = [
    ( tacticText = "unfold to_Z",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    ( tacticText = "destruct wB",
      confidence = 0.5 ),
    ( tacticText = "apply Z.mod_small",
      confidence = 0.5 ),
    ( tacticText = "apply Zmod_small",
      confidence = 0.5 ),
    (tacticText = "unfold wB", confidence = 0.5),
    ( tacticText = "apply Zmod_lt_le",
      confidence = 0.5 ),
    ( tacticText = "apply Zmod_lt",
      confidence = 0.5 ),
    ( tacticText = "apply Z.mod_lt",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.mod_small",
      confidence = 0.5 ) ] )
STATE
digits : positive, digits_ne_1 : (digits <> 1%positive), digits_gt_1 := spec_more_than_1_digit : (1 < Z.pos digits) |- (forall x : Z, [|x|] < wB)
----
digits : positive, digits_ne_1 : (digits <> 1%positive), digits_gt_1 := spec_more_than_1_digit : (1 < Z.pos digits) |- (forall x : Z, [|x|] < wB) OUTPUT
intros
unfold to_Z
auto with zarith
auto
induction x
red
unfold [|x|]
unfold Z.lt
unfold Z.le
unfold Z.mod
Prediction takes 0.06389021873474121 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold to_Z",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "induction x",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold [|x|]",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.lt",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.le",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.mod",
      confidence = 0.5 ) ] )
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold Rle",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_antisym",
      confidence = 0.5 ),
    ( tacticText = "unfold Rsqr",
      confidence = 0.5 ),
    ( tacticText = "destruct 1",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_le",
      confidence = 0.5 ) ] )
STATE
r1 : R, r2 : R, H : (r1 = r2) |- (r1 <= r2)
----
r1 : R, r2 : R, H : (r1 = r2) |- (r1 <= r2) OUTPUT
auto with real
assumption
auto
elim H
apply Rlt_le
apply Rle_antisym
intuition
rewrite H
rewrite <- H
apply Rle_lt
Prediction takes 0.14385366439819336 seconds
( textPrediction = [
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "elim H", confidence = 0.5),
    ( tacticText = "apply Rlt_le",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_antisym",
      confidence = 0.5 ),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "rewrite H", confidence = 0.5),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_lt",
      confidence = 0.5 ) ] )
STATE
r1 : R, r2 : R, H : (r1 = r2) |- (r1 <= r2)
----
r1 : R, r2 : R, H : (r1 = r2) |- (r1 <= r2) OUTPUT
auto with real
assumption
auto
elim H
apply Rlt_le
apply Rle_antisym
intuition
rewrite H
rewrite <- H
apply Rle_lt
Prediction takes 0.0849921703338623 seconds
( textPrediction = [
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "elim H", confidence = 0.5),
    ( tacticText = "apply Rlt_le",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_antisym",
      confidence = 0.5 ),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "rewrite H", confidence = 0.5),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_lt",
      confidence = 0.5 ) ] )
STATE
r1 : R, r2 : R, H : (r1 = r2) |- (r1 <= r2)
----
r1 : R, r2 : R, H : (r1 = r2) |- (r1 <= r2) OUTPUT
auto with real
assumption
auto
elim H
apply Rlt_le
apply Rle_antisym
intuition
rewrite H
rewrite <- H
apply Rle_lt
Prediction takes 0.07628726959228516 seconds
( textPrediction = [
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "elim H", confidence = 0.5),
    ( tacticText = "apply Rlt_le",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_antisym",
      confidence = 0.5 ),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "rewrite H", confidence = 0.5),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_lt",
      confidence = 0.5 ) ] )
STATE
 |- (forall r1 r2 : R, r1 = r2 -> r1 < r2 \/ r1 = r2)
----
 |- (forall r1 r2 : R, r1 = r2 -> r1 < r2 \/ r1 = r2) OUTPUT
intros
intros ?
auto with real
red
intros until r
auto
right
intuition
left
simpl
Prediction takes 0.06365275382995605 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "intros until r",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "right", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "left", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5) ] )
STATE
 |- (forall r1 r2 : R, r1 = r2 -> r1 <= r2)
----
 |- (forall r1 r2 : R, r1 = r2 -> r1 <= r2) OUTPUT
intros
intros ?
auto with real
red
unfold Rle_antisym
auto
unfold Rsqr
intros until r1
intuition
intros until r
Prediction takes 0.06994771957397461 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold Rle_antisym",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold Rsqr",
      confidence = 0.5 ),
    ( tacticText = "intros until r1",
      confidence = 0.5 ),
    (tacticText = "intuition", confidence = 0.5),
    ( tacticText = "intros until r",
      confidence = 0.5 ) ] )
STATE
r1 : R, r2 : R, H : (r1 = r2) |- (r1 <= r2)
----
r1 : R, r2 : R, H : (r1 = r2) |- (r1 <= r2) OUTPUT
auto with real
assumption
auto
elim H
apply Rlt_le
apply Rle_antisym
intuition
rewrite H
rewrite <- H
apply Rle_lt
Prediction takes 0.06880426406860352 seconds
( textPrediction = [
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "elim H", confidence = 0.5),
    ( tacticText = "apply Rlt_le",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_antisym",
      confidence = 0.5 ),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "rewrite H", confidence = 0.5),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_lt",
      confidence = 0.5 ) ] )
STATE
 |- (forall r1 r2 : R, r1 <> 0 -> r2 <> 0 -> / (r1 * r2) = / r1 * / r2)
----
 |- (forall r1 r2 : R, r1 <> 0 -> r2 <> 0 -> / (r1 * r2) = / r1 * / r2) OUTPUT
intros ?
intros
unfold Rdiv
auto with real
intros intros ?
simpl
intros intros
red
destruct 1
intros until 3
Prediction takes 0.05555248260498047 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold Rdiv",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "intros intros ?",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "intros intros",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "destruct 1",
      confidence = 0.5 ),
    ( tacticText = "intros until 3",
      confidence = 0.5 ) ] )
STATE
r1 : R |- (forall r2 : R, r1 <> 0 -> r2 <> 0 -> / (r1 * r2) = / r1 * / r2)
----
r1 : R |- (forall r2 : R, r1 <> 0 -> r2 <> 0 -> / (r1 * r2) = / r1 * / r2) OUTPUT
intros ?
intros
unfold Rdiv
intros intros ?
auto with real
simpl
destruct 1
destruct r1
intros intros
intros ? ?
Prediction takes 0.06046152114868164 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold Rdiv",
      confidence = 0.5 ),
    ( tacticText = "intros intros ?",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct 1",
      confidence = 0.5 ),
    ( tacticText = "destruct r1",
      confidence = 0.5 ),
    ( tacticText = "intros intros",
      confidence = 0.5 ),
    ( tacticText = "intros ? ?",
      confidence = 0.5 ) ] )
STATE
r1 : R, r2 : R |- (r1 <> 0 -> r2 <> 0 -> / (r1 * r2) = / r1 * / r2)
----
r1 : R, r2 : R |- (r1 <> 0 -> r2 <> 0 -> / (r1 * r2) = / r1 * / r2) OUTPUT
intros ?
intros
unfold Rdiv
auto with real
simpl
destruct 1
rewrite Rmult_assoc
rewrite Rmult_comm
rewrite Rinv_mult
apply Rmult_integral
Prediction takes 0.07645249366760254 seconds
starting proving server with connection through their stdin
using textmode optiontext
R1 : ConstructiveReals, R2 : ConstructiveReals, f : (ConstructiveRealsMorphism R1 R2) |- (forall (x : CRcarrier R1) (n : nat), orderEq (CRcarrier R2) (CRlt R2) (CRmorph R1 R2 f (CRmult R1 x (CR_of_Q R1 (Z.of_nat n # 1)))) (CRmult R2 (CRmorph R1 R2 f x) (CR_of_Q R2 (Z.of_nat n # 1)))) OUTPUT
intros
intros ?
simpl
red
auto
split
apply CReq_refl
apply CRisRing
apply CR_of_Q
apply CReq_sym
Prediction takes 0.10458588600158691 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "apply CReq_refl",
      confidence = 0.5 ),
    ( tacticText = "apply CRisRing",
      confidence = 0.5 ),
    ( tacticText = "apply CR_of_Q",
      confidence = 0.5 ),
    ( tacticText = "apply CReq_sym",
      confidence = 0.5 ) ] )
STATE
R1 : ConstructiveReals, R2 : ConstructiveReals, f : (ConstructiveRealsMorphism R1 R2), x : (CRcarrier R1), n : nat |- (orderEq (CRcarrier R2) (CRlt R2) (CRmorph R1 R2 f (CRmult R1 x (CR_of_Q R1 (Z.of_nat n # 1)))) (CRmult R2 (CRmorph R1 R2 f x) (CR_of_Q R2 (Z.of_nat n # 1))))
----
R1 : ConstructiveReals, R2 : ConstructiveReals, f : (ConstructiveRealsMorphism R1 R2), x : (CRcarrier R1), n : nat |- (orderEq (CRcarrier R2) (CRlt R2) (CRmorph R1 R2 f (CRmult R1 x (CR_of_Q R1 (Z.of_nat n # 1)))) (CRmult R2 (CRmorph R1 R2 f x) (CR_of_Q R2 (Z.of_nat n # 1)))) OUTPUT
apply CReq_refl
apply (CRisRingExt R2)
simpl
apply CReq_sym
apply CRisRing
apply (CRisRingExt R1)
destruct (CRisRing R2)
apply (CRisRingExt R2 _))
apply (CRle_trans R2 _ (CR_of_Q R2 (Z.pos n # 1))))
apply (CRle_trans R2 _ (CR_of_Q R2 (Z.pos n # 1)))
Prediction takes 0.28357887268066406 seconds
( textPrediction = [
    ( tacticText = "apply CReq_refl",
      confidence = 0.5 ),
    ( tacticText = "apply (CRisRingExt R2)",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "apply CReq_sym",
      confidence = 0.5 ),
    ( tacticText = "apply CRisRing",
      confidence = 0.5 ),
    ( tacticText = "apply (CRisRingExt R1)",
      confidence = 0.5 ),
    ( tacticText = "destruct (CRisRing R2)",
      confidence = 0.5 ),
    ( tacticText = "apply (CRisRingExt R2 _))",
      confidence = 0.5 ),
    ( tacticText = "apply (CRle_trans R2 _ (CR_of_Q R2 (Z.pos n # 1))))",
      confidence = 0.5 ),
    ( tacticText = "apply (CRle_trans R2 _ (CR_of_Q R2 (Z.pos n # 1)))",
      confidence = 0.5 ) ] )
STATE
R : ConstructiveReals |- (ConstructiveRealsMorphism R CRealImplem)
----
R : ConstructiveReals |- (ConstructiveRealsMorphism R CRealImplem) OUTPUT
intros ?
exact H
exact (CRisRingExt R)
apply H
apply (CRisRingExt R)
exact Rlt_trans
red
apply CRmult_comm
apply CRplus_comm
apply (CRle_trans R)
Prediction takes 0.10802149772644043 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "exact H", confidence = 0.5),
    ( tacticText = "exact (CRisRingExt R)",
      confidence = 0.5 ),
    (tacticText = "apply H", confidence = 0.5),
    ( tacticText = "apply (CRisRingExt R)",
      confidence = 0.5 ),
    ( tacticText = "exact Rlt_trans",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "apply CRmult_comm",
      confidence = 0.5 ),
    ( tacticText = "apply CRplus_comm",
      confidence = 0.5 ),
    ( tacticText = "apply (CRle_trans R)",
      confidence = 0.5 ) ] )
STATE
R : ConstructiveReals |- (ConstructiveRealsMorphism R CRealImplem)
----
R : ConstructiveReals |- (ConstructiveRealsMorphism R CRealImplem) OUTPUT
intros ?
exact H
exact (CRisRingExt R)
apply H
apply (CRisRingExt R)
exact Rlt_trans
red
apply CRmult_comm
apply CRplus_comm
apply (CRle_trans R)
Prediction takes 0.11027956008911133 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "exact H", confidence = 0.5),
    ( tacticText = "exact (CRisRingExt R)",
      confidence = 0.5 ),
    (tacticText = "apply H", confidence = 0.5),
    ( tacticText = "apply (CRisRingExt R)",
      confidence = 0.5 ),
    ( tacticText = "exact Rlt_trans",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "apply CRmult_comm",
      confidence = 0.5 ),
    ( tacticText = "apply CRplus_comm",
      confidence = 0.5 ),
    ( tacticText = "apply (CRle_trans R)",
      confidence = 0.5 ) ] )
STATE
R : ConstructiveReals |- (ConstructiveRealsMorphism R CRealImplem)
----
R : ConstructiveReals |- (ConstructiveRealsMorphism R CRealImplem) OUTPUT
intros ?
exact H
exact (CRisRingExt R)
apply H
apply (CRisRingExt R)
exact Rlt_trans
red
apply CRmult_comm
apply CRplus_comm
apply (CRle_trans R)
Prediction takes 0.10576343536376953 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "exact H", confidence = 0.5),
    ( tacticText = "exact (CRisRingExt R)",
      confidence = 0.5 ),
    (tacticText = "apply H", confidence = 0.5),
    ( tacticText = "apply (CRisRingExt R)",
      confidence = 0.5 ),
    ( tacticText = "exact Rlt_trans",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "apply CRmult_comm",
      confidence = 0.5 ),
    ( tacticText = "apply CRplus_comm",
      confidence = 0.5 ),
    ( tacticText = "apply (CRle_trans R)",
      confidence = 0.5 ) ] )
STATE
R : ConstructiveReals |- (ConstructiveRealsMorphism R CRealImplem)
----
R : ConstructiveReals |- (ConstructiveRealsMorphism R CRealImplem) OUTPUT
intros ?
exact H
exact (CRisRingExt R)
apply H
apply (CRisRingExt R)
exact Rlt_trans
red
apply CRmult_comm
apply CRplus_comm
apply (CRle_trans R)
Prediction takes 0.1376492977142334 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "exact H", confidence = 0.5),
    ( tacticText = "exact (CRisRingExt R)",
      confidence = 0.5 ),
    (tacticText = "apply H", confidence = 0.5),
    ( tacticText = "apply (CRisRingExt R)",
      confidence = 0.5 ),
    ( tacticText = "exact Rlt_trans",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "apply CRmult_comm",
      confidence = 0.5 ),
    ( tacticText = "apply CRplus_comm",
      confidence = 0.5 ),
    ( tacticText = "apply (CRle_trans R)",
      confidence = 0.5 ) ] )
STATE
R : ConstructiveReals |- (ConstructiveRealsMorphism R CRealImplem)
----
R : ConstructiveReals |- (ConstructiveRealsMorphism R CRealImplem) OUTPUT
intros ?
exact H
exact (CRisRingExt R)
apply H
apply (CRisRingExt R)
exact Rlt_trans
red
apply CRmult_comm
apply CRplus_comm
apply (CRle_trans R)
Prediction takes 0.11011958122253418 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "exact H", confidence = 0.5),
    ( tacticText = "exact (CRisRingExt R)",
      confidence = 0.5 ),
    (tacticText = "apply H", confidence = 0.5),
    ( tacticText = "apply (CRisRingExt R)",
      confidence = 0.5 ),
    ( tacticText = "exact Rlt_trans",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "apply CRmult_comm",
      confidence = 0.5 ),
    ( tacticText = "apply CRplus_comm",
      confidence = 0.5 ),
    ( tacticText = "apply (CRle_trans R)",
      confidence = 0.5 ) ] )
STATE
R : ConstructiveReals |- (ConstructiveRealsMorphism R CRealImplem)
----
R : ConstructiveReals |- (ConstructiveRealsMorphism R CRealImplem) OUTPUT
intros ?
exact H
exact (CRisRingExt R)
apply H
apply (CRisRingExt R)
exact Rlt_trans
red
apply CRmult_comm
apply CRplus_comm
apply (CRle_trans R)
Prediction takes 0.10718178749084473 seconds
unfold iter_sqrt
unfold sqrt_step
unfold sqrt2
rewrite Z.mul_comm
rewrite Z.mul_assoc
case (to_bounded i)
Prediction takes 0.28530454635620117 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "clear j", confidence = 0.5),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold iter_sqrt",
      confidence = 0.5 ),
    ( tacticText = "unfold sqrt_step",
      confidence = 0.5 ),
    ( tacticText = "unfold sqrt2",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.mul_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.mul_assoc",
      confidence = 0.5 ),
    ( tacticText = "case (to_bounded i)",
      confidence = 0.5 ) ] )
STATE
n : nat, rec : (int  int  int), i : int, j : int, H : (0 <  (i)) |- (0 <  (j)   (i) < ( (j) + 1) ^ 2  2 *  (j) < wB  ( j1 : int, 0 <  (j1)  2 ^ Z.of_nat n +  (j1) <=  (j)   (i) < ( (j1) + 1) ^ 2  2 *  (j1) < wB   (rec i j1) ^ 2 <=  (i) < ( (rec i j1) + 1) ^ 2)   (iter_sqrt n rec i j) ^ 2 <=  (i) < ( (iter_sqrt n rec i j) + 1) ^ 2)
----
n : nat, rec : (int  int  int), i : int, j : int, H : (0 <  (i)) |- (0 <  (j)   (i) < ( (j) + 1) ^ 2  2 *  (j) < wB  ( j1 : int, 0 <  (j1)  2 ^ Z.of_nat n +  (j1) <=  (j)   (i) < ( (j1) + 1) ^ 2  2 *  (j1) < wB   (rec i j1) ^ 2 <=  (i) < ( (rec i j1) + 1) ^ 2)   (iter_sqrt n rec i j) ^ 2 <=  (i) < ( (iter_sqrt n rec i j) + 1) ^ 2) OUTPUT
intros ?
intros
clear j
auto with zarith
case_spec
rewrite Z.mul_comm
rewrite Z.pow_succ_r
case_eq_dec
assert (0 <  (i))
rewrite Z.mul_assoc
Prediction takes 0.13651537895202637 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "clear j", confidence = 0.5),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "case_spec", confidence = 0.5),
    ( tacticText = "rewrite Z.mul_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.pow_succ_r",
      confidence = 0.5 ),
    ( tacticText = "case_eq_dec",
      confidence = 0.5 ),
    ( tacticText = "assert (0 <  (i))",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.mul_assoc",
      confidence = 0.5 ) ] )
STATE
n : nat, rec : (int  int  int), i : int, j : int, H : (0 <  (i)), H0 : (0 <  (j)) |- ( (i) < ( (j) + 1) ^ 2  2 *  (j) < wB  ( j1 : int, 0 <  (j1)  2 ^ Z.of_nat n +  (j1) <=  (j)   (i) < ( (j1) + 1) ^ 2  2 *  (j1) < wB   (rec i j1) ^ 2 <=  (i) < ( (rec i j1) + 1) ^ 2)   (iter_sqrt n rec i j) ^ 2 <=  (i) < ( (iter_sqrt n rec i j) + 1) ^ 2)
----
n : nat, rec : (int  int  int), i : int, j : int, H : (0 <  (i)), H0 : (0 <  (j)) |- ( (i) < ( (j) + 1) ^ 2  2 *  (j) < wB  ( j1 : int, 0 <  (j1)  2 ^ Z.of_nat n +  (j1) <=  (j)   (i) < ( (j1) + 1) ^ 2  2 *  (j1) < wB   (rec i j1) ^ 2 <=  (i) < ( (rec i j1) + 1) ^ 2)   (iter_sqrt n rec i j) ^ 2 <=  (i) < ( (iter_sqrt n rec i j) + 1) ^ 2) OUTPUT
intros ?
intros
auto with zarith
clear j
case_spec
rewrite Z.mul_comm
clearbodysneakl
rewrite Z.mul_assoc
case (i)
case (to_nat n)
Prediction takes 0.13372540473937988 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "clear j", confidence = 0.5),
    (tacticText = "case_spec", confidence = 0.5),
    ( tacticText = "rewrite Z.mul_comm",
      confidence = 0.5 ),
    ( tacticText = "clearbodysneakl",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.mul_assoc",
      confidence = 0.5 ),
    (tacticText = "case (i)", confidence = 0.5),
    ( tacticText = "case (to_nat n)",
      confidence = 0.5 ) ] )
STATE
n : nat, rec : (int  int  int), i : int, j : int, H : (0 <  (i)), H0 : (0 <  (j)), H1 : ( (i) < ( (j) + 1) ^ 2) |- (2 *  (j) < wB  ( j1 : int, 0 <  (j1)  2 ^ Z.of_nat n +  (j1) <=  (j)   (i) < ( (j1) + 1) ^ 2  2 *  (j1) < wB   (rec i j1) ^ 2 <=  (i) < ( (rec i j1) + 1) ^ 2)   (iter_sqrt n rec i j) ^ 2 <=  (i) < ( (iter_sqrt n rec i j) + 1) ^ 2)
----
n : nat, rec : (int  int  int), i : int, j : int, H : (0 <  (i)), H0 : (0 <  (j)), H1 : ( (i) < ( (j) + 1) ^ 2) |- (2 *  (j) < wB  ( j1 : int, 0 <  (j1)  2 ^ Z.of_nat n +  (j1) <=  (j)   (i) < ( (j1) + 1) ^ 2  2 *  (j1) < wB   (rec i j1) ^ 2 <=  (i) < ( (rec i j1) + 1) ^ 2)   (iter_sqrt n rec i j) ^ 2 <=  (i) < ( (iter_sqrt n rec i j) + 1) ^ 2) OUTPUT
intros ?
intros
auto with zarith
case_spec
clear H1
case_le_dec
rewrite Z.mul_comm
clearbodysneakl
clearbodyify
clearbody_step
Prediction takes 0.11561226844787598 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "case_spec", confidence = 0.5),
    (tacticText = "clear H1", confidence = 0.5),
    ( tacticText = "case_le_dec",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.mul_comm",
      confidence = 0.5 ),
    ( tacticText = "clearbodysneakl",
      confidence = 0.5 ),
    ( tacticText = "clearbodyify",
      confidence = 0.5 ),
    ( tacticText = "clearbody_step",
      confidence = 0.5 ) ] )
STATE
n : nat, rec : (int  int  int), i : int, j : int, H : (0 <  (i)), H0 : (0 <  (j)), H1 : ( (i) < ( (j) + 1) ^ 2), H2 : (2 *  (j) < wB) |- (( j1 : int, 0 <  (j1)  2 ^ Z.of_nat n +  (j1) <=  (j)   (i) < ( (j1) + 1) ^ 2  2 *  (j1) < wB   (rec i j1) ^ 2 <=  (i) < ( (rec i j1) + 1) ^ 2)   (iter_sqrt n rec i j) ^ 2 <=  (i) < ( (iter_sqrt n rec i j) + 1) ^ 2)
----
n : nat, rec : (int  int  int), i : int, j : int, H : (0 <  (i)), H0 : (0 <  (j)), H1 : ( (i) < ( (j) + 1) ^ 2), H2 : (2 *  (j) < wB) |- (( j1 : int, 0 <  (j1)  2 ^ Z.of_nat n +  (j1) <=  (j)   (i) < ( (j1) + 1) ^ 2  2 *  (j1) < wB   (rec i j1) ^ 2 <=  (i) < ( (rec i j1) + 1) ^ 2)   (iter_sqrt n rec i j) ^ 2 <=  (i) < ( (iter_sqrt n rec i j) + 1) ^ 2) OUTPUT
intros ?
intros
auto with zarith
clear H2
clearb
rewrite Z.mul_comm
case_spec
clearbodysneakl
clearbod_sqrt
case_le_dec
Prediction takes 0.11897540092468262 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "clear H2", confidence = 0.5),
    (tacticText = "clearb", confidence = 0.5),
    ( tacticText = "rewrite Z.mul_comm",
      confidence = 0.5 ),
    (tacticText = "case_spec", confidence = 0.5),
    ( tacticText = "clearbodysneakl",
      confidence = 0.5 ),
    ( tacticText = "clearbod_sqrt",
      confidence = 0.5 ),
    ( tacticText = "case_le_dec",
      confidence = 0.5 ) ] )
STATE
n : nat, rec : (int  int  int), i : int, j : int, H : (0 <  (i)), H0 : (0 <  (j)), H1 : ( (i) < ( (j) + 1) ^ 2), H2 : (2 *  (j) < wB), H3 : ( j1 : int, 0 <  (j1)  2 ^ Z.of_nat n +  (j1) <=  (j)   (i) < ( (j1) + 1) ^ 2  2 *  (j1) < wB   (rec i j1) ^ 2 <=  (i) < ( (rec i j1) + 1) ^ 2) |- ( (iter_sqrt n rec i j) ^ 2 <=  (i) < ( (iter_sqrt n rec i j) + 1) ^ 2)
----
n : nat, rec : (int  int  int), i : int, j : int, H : (0 <  (i)), H0 : (0 <  (j)), H1 : ( (i) < ( (j) + 1) ^ 2), H2 : (2 *  (j) < wB), H3 : ( j1 : int, 0 <  (j1)  2 ^ Z.of_nat n +  (j1) <=  (j)   (i) < ( (j1) + 1) ^ 2  2 *  (j1) < wB   (rec i j1) ^ 2 <=  (i) < ( (rec i j1) + 1) ^ 2) |- ( (iter_sqrt n rec i j) ^ 2 <=  (i) < ( (iter_sqrt n rec i j) + 1) ^ 2) OUTPUT
auto with zarith
split
intros ?
rewrite Z.pow_succ_r
rewrite Z.mul_comm
assert (0 <  (i))
assert (0 <=  (i))
apply Z.pow_le_mono_nonneg
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "exact H", confidence = 0.5),
    ( tacticText = "exact (CRisRingExt R)",
      confidence = 0.5 ),
    (tacticText = "apply H", confidence = 0.5),
    ( tacticText = "apply (CRisRingExt R)",
      confidence = 0.5 ),
    ( tacticText = "exact Rlt_trans",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "apply CRmult_comm",
      confidence = 0.5 ),
    ( tacticText = "apply CRplus_comm",
      confidence = 0.5 ),
    ( tacticText = "apply (CRle_trans R)",
      confidence = 0.5 ) ] )
STATE
R : ConstructiveReals |- (ConstructiveRealsMorphism R CRealImplem)
----
R : ConstructiveReals |- (ConstructiveRealsMorphism R CRealImplem) OUTPUT
intros ?
exact H
exact (CRisRingExt R)
apply H
apply (CRisRingExt R)
exact Rlt_trans
red
apply CRmult_comm
apply CRplus_comm
apply (CRle_trans R)
Prediction takes 0.10590982437133789 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "exact H", confidence = 0.5),
    ( tacticText = "exact (CRisRingExt R)",
      confidence = 0.5 ),
    (tacticText = "apply H", confidence = 0.5),
    ( tacticText = "apply (CRisRingExt R)",
      confidence = 0.5 ),
    ( tacticText = "exact Rlt_trans",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "apply CRmult_comm",
      confidence = 0.5 ),
    ( tacticText = "apply CRplus_comm",
      confidence = 0.5 ),
    ( tacticText = "apply (CRle_trans R)",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
s : t, s' : t, s'' : t, x : elt, y : elt, z : elt |- (equal s' s'' = true -> equal (union s s') (union s s'') = true)
----
s : t, s' : t, s'' : t, x : elt, y : elt, z : elt |- (equal s' s'' = true -> equal (union s s') (union s s'') = true) OUTPUT
auto with set
intros
apply equal_2
apply equal_1
rewrite equal_spec
intros ?
apply subset_2
rewrite union_spec
apply equal_equal
apply inter_2
Prediction takes 3.06112003326416 seconds
( textPrediction = [
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "apply equal_2",
      confidence = 0.5 ),
    ( tacticText = "apply equal_1",
      confidence = 0.5 ),
    ( tacticText = "rewrite equal_spec",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "apply subset_2",
      confidence = 0.5 ),
    ( tacticText = "rewrite union_spec",
      confidence = 0.5 ),
    ( tacticText = "apply equal_equal",
      confidence = 0.5 ),
    ( tacticText = "apply inter_2",
      confidence = 0.5 ) ] )
STATE
f : (elt -> bool), Comp : (Proper (E.eq ==> Logic.eq) f), Comp' : (Proper (E.eq ==> Logic.eq) (fun x : E.t => negb (f x))) |- (forall s : t, equal (fst (partition f s)) (filter f s) = true)
----
f : (elt -> bool), Comp : (Proper (E.eq ==> Logic.eq) f), Comp' : (Proper (E.eq ==> Logic.eq) (fun x : E.t => negb (f x))) |- (forall s : t, equal (fst (partition f s)) (filter f s) = true) OUTPUT
intros
auto
intros ?
unfold equal
unfold filter
simpl
induction s
auto with set
unfold Equal
rewrite filter_spec
Prediction takes 0.2773573398590088 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold equal",
      confidence = 0.5 ),
    ( tacticText = "unfold filter",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "induction s",
      confidence = 0.5 ),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    ( tacticText = "unfold Equal",
      confidence = 0.5 ),
    ( tacticText = "rewrite filter_spec",
      confidence = 0.5 ) ] )
STATE
f : (elt -> bool), Comp : (Proper (E.eq ==> Logic.eq) f), Comp' : (Proper (E.eq ==> Logic.eq) (fun x : E.t => negb (f x))), s : t |- (equal (fst (partition f s)) (filter f s) = true)
----
f : (elt -> bool), Comp : (Proper (E.eq ==> Logic.eq) f), Comp' : (Proper (E.eq ==> Logic.eq) (fun x : E.t => negb (f x))), s : t |- (equal (fst (partition f s)) (filter f s) = true) OUTPUT
rewrite filter_spec
auto
auto with set
unfold filter
rewrite filter_iff
apply filter_2
apply filter_1
apply equal_2
apply filter_spec
rewrite filter_spec2
Prediction takes 0.0808877944946289 seconds
( textPrediction = [
    ( tacticText = "rewrite filter_spec",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    ( tacticText = "unfold filter",
      confidence = 0.5 ),
    ( tacticText = "rewrite filter_iff",
      confidence = 0.5 ),
    ( tacticText = "apply filter_2",
      confidence = 0.5 ),
    ( tacticText = "apply filter_1",
      confidence = 0.5 ),
    ( tacticText = "apply equal_2",
      confidence = 0.5 ),
    ( tacticText = "apply filter_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite filter_spec2",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold Rdiv",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct 1",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rmult_assoc",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rmult_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rinv_mult",
      confidence = 0.5 ),
    ( tacticText = "apply Rmult_integral",
      confidence = 0.5 ) ] )
STATE
r1 : R, r2 : R, H : (r1 <> 0) |- (r2 <> 0 -> / (r1 * r2) = / r1 * / r2)
----
r1 : R, r2 : R, H : (r1 <> 0) |- (r2 <> 0 -> / (r1 * r2) = / r1 * / r2) OUTPUT
intros ?
intros
auto with real
simpl
unfold Rdiv
rewrite Rinv_mult_distr
apply Rinv_neq_compat
rewrite Rmult_assoc
rewrite Rmult_comm
rewrite Rinv_r_sym
Prediction takes 0.18099045753479004 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold Rdiv",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rinv_mult_distr",
      confidence = 0.5 ),
    ( tacticText = "apply Rinv_neq_compat",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rmult_assoc",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rmult_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rinv_r_sym",
      confidence = 0.5 ) ] )
STATE
r1 : R, r2 : R, H : (r1 <> 0), H0 : (r2 <> 0) |- (/ (r1 * r2) = / r1 * / r2)
----
r1 : R, r2 : R, H : (r1 <> 0), H0 : (r2 <> 0) |- (/ (r1 * r2) = / r1 * / r2) OUTPUT
rewrite Rinv_mult_distr
field
ring
reflexivity
rewrite Rmult_assoc
auto with real
rewrite H0
rewrite Rmult_1_r
rewrite Rinv_r_sym
apply Rinv_neq_compat
Prediction takes 0.0896153450012207 seconds
( textPrediction = [
    ( tacticText = "rewrite Rinv_mult_distr",
      confidence = 0.5 ),
    (tacticText = "field", confidence = 0.5),
    (tacticText = "ring", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rmult_assoc",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "rewrite H0",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rmult_1_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rinv_r_sym",
      confidence = 0.5 ),
    ( tacticText = "apply Rinv_neq_compat",
      confidence = 0.5 ) ] )
STATE
r1 : R, r2 : R, H : (r1 <> 0), H0 : (r2 <> 0) |- (r2 <> 0 /\ r1 <> 0)
----
r1 : R, r2 : R, H : (r1 <> 0), H0 : (r2 <> 0) |- (r2 <> 0 /\ r1 <> 0) OUTPUT
auto with real
intuition
tauto
split
auto
assumption
right
red
left
intuition auto
Prediction takes 0.056754350662231445 seconds
( textPrediction = [
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "tauto", confidence = 0.5),
    (tacticText = "split", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    (tacticText = "right", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "left", confidence = 0.5),
    ( tacticText = "intuition auto",
      confidence = 0.5 ) ] )
STATE
 |- (forall a b : R, a < b -> 0 < b - a)
----
 |- (forall a b : R, a < b -> 0 < b - a) OUTPUT
intros
intros ?
exact Rplus_lt_compat_l
red
exact Rplus_lt_reg_l with b
exact Rplus_lt_reg_l
intros until b
exact Rplus_lt_trans
exact Rplus_lt_0_compat_l
exact Rplus_lt_0_compat
Prediction takes 0.12894010543823242 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "exact Rplus_lt_compat_l",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "exact Rplus_lt_reg_l with b",
      confidence = 0.5 ),
    ( tacticText = "exact Rplus_lt_reg_l",
      confidence = 0.5 ),
    ( tacticText = "intros until b",
      confidence = 0.5 ),
    ( tacticText = "exact Rplus_lt_trans",
      confidence = 0.5 ),
    ( tacticText = "exact Rplus_lt_0_compat_l",
      confidence = 0.5 ),
    ( tacticText = "exact Rplus_lt_0_compat",
      confidence = 0.5 ) ] )
STATE
a : R, b : R, H : (a < b) |- (0 < b - a)
----
a : R, b : R, H : (a < b) |- (0 < b - a) OUTPUT
assumption
auto with real
rewrite Rplus_0_l
elim H
unfold Rminus
apply Rlt_0_1
apply Rlt_trans with b
apply Rle_lt_trans with b
apply Rplus_lt_compat_l
apply Rplus_lt_mono_l
Prediction takes 0.15961217880249023 seconds
( textPrediction = [
    ( tacticText = "assumption",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_0_l",
      confidence = 0.5 ),
    (tacticText = "elim H", confidence = 0.5),
    ( tacticText = "unfold Rminus",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_0_1",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_trans with b",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_lt_trans with b",
      confidence = 0.5 ),
    ( tacticText = "apply Rplus_lt_compat_l",
      confidence = 0.5 ),
    ( tacticText = "apply Rplus_lt_mono_l",
      confidence = 0.5 ) ] )
STATE
a : R |- (forall b : R, a < b -> 0 < b - a)
----
a : R |- (forall b : R, a < b -> 0 < b - a) OUTPUT
intros ?
intros
intros until b
exact Rle_lt_trans
unfold Rle
clear b
red
unfold Rsqr
apply Rle_lt_trans
apply Rle_trans with b
Prediction takes 0.08994126319885254 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "intros until b",
      confidence = 0.5 ),
    ( tacticText = "exact Rle_lt_trans",
      confidence = 0.5 ),
    ( tacticText = "unfold Rle",
      confidence = 0.5 ),
    (tacticText = "clear b", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold Rsqr",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_lt_trans",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_trans with b",
      confidence = 0.5 ) ] )
STATE
a : R, b : R |- (a < b -> 0 < b - a)
----
a : R, b : R |- (a < b -> 0 < b - a) OUTPUT
intros ?
intros
unfold Rminus
unfold Rle
auto with real
unfold Rsqr
unfold Rge
apply Rle_ge
apply Rle_antisym
apply Rle_trans
Prediction takes 0.06960868835449219 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold Rminus",
      confidence = 0.5 ),
    ( tacticText = "unfold Rle",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "unfold Rsqr",
      confidence = 0.5 ),
    ( tacticText = "unfold Rge",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_ge",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_antisym",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_trans",
      confidence = 0.5 ) ] )
STATE
a : R, b : R, H : (a < b) |- (0 < b - a)
----
a : R, b : R, H : (a < b) |- (0 < b - a) OUTPUT
assumption
auto with real
rewrite Rplus_0_l
elim H
unfold Rminus
apply Rlt_0_1
apply Rlt_trans with b
apply Rle_lt_trans with b
apply Rplus_lt_compat_l
apply Rplus_lt_mono_l
Prediction takes 0.11129236221313477 seconds
( textPrediction = [
    ( tacticText = "assumption",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_0_l",
      confidence = 0.5 ),
    (tacticText = "elim H", confidence = 0.5),
    ( tacticText = "unfold Rminus",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_0_1",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_trans with b",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_lt_trans with b",
      confidence = 0.5 ),
    ( tacticText = "apply Rplus_lt_compat_l",
      confidence = 0.5 ),
    ( tacticText = "apply Rplus_lt_mono_l",
      confidence = 0.5 ) ] )
STATE
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
apply Z.pow_le_mono_l
rewrite Z.pow_le_mono_r
Prediction takes 0.1738111972808838 seconds
( textPrediction = [
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "split", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "rewrite Z.pow_succ_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.mul_comm",
      confidence = 0.5 ),
    ( tacticText = "assert (0 <  (i))",
      confidence = 0.5 ),
    ( tacticText = "assert (0 <=  (i))",
      confidence = 0.5 ),
    ( tacticText = "apply Z.pow_le_mono_nonneg",
      confidence = 0.5 ),
    ( tacticText = "apply Z.pow_le_mono_l",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.pow_le_mono_r",
      confidence = 0.5 ) ] )
STATE
n : nat, rec : (int  int  int), i : int, j : int, H : (0 <  (i)), H0 : (0 <  (j)), H1 : ( (i) < ( (j) + 1) ^ 2), H2 : (2 *  (j) < wB), H3 : ( j1 : int, 0 <  (j1)  2 ^ Z.of_nat n +  (j1) <=  (j)   (i) < ( (j1) + 1) ^ 2  2 *  (j1) < wB   (rec i j1) ^ 2 <=  (i) < ( (rec i j1) + 1) ^ 2) |- ( (iter_sqrt n rec i j) ^ 2 <=  (i))
----
n : nat, rec : (int  int  int), i : int, j : int, H : (0 <  (i)), H0 : (0 <  (j)), H1 : ( (i) < ( (j) + 1) ^ 2), H2 : (2 *  (j) < wB), H3 : ( j1 : int, 0 <  (j1)  2 ^ Z.of_nat n +  (j1) <=  (j)   (i) < ( (j1) + 1) ^ 2  2 *  (j1) < wB   (rec i j1) ^ 2 <=  (i) < ( (rec i j1) + 1) ^ 2) |- ( (iter_sqrt n rec i j) ^ 2 <=  (i)) OUTPUT
auto with zarith
split
lia
auto
intros ?
case (to_Z_bounded i)
case (i)
rewrite Z.pow_succ_r
rewrite Z.mul_comm
rewrite Z.pow_le_mono_l
Prediction takes 0.20827770233154297 seconds
( textPrediction = [
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "split", confidence = 0.5),
    (tacticText = "lia", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "case (to_Z_bounded i)",
      confidence = 0.5 ),
    (tacticText = "case (i)", confidence = 0.5),
    ( tacticText = "rewrite Z.pow_succ_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.mul_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.pow_le_mono_l",
      confidence = 0.5 ) ] )
STATE
n : nat, rec : (int  int  int), i : int, j : int, H : (0 <  (i)), H0 : (0 <  (j)), H1 : ( (i) < ( (j) + 1) ^ 2), H2 : (2 *  (j) < wB), H3 : ( j1 : int, 0 <  (j1)  2 ^ Z.of_nat n +  (j1) <=  (j)   (i) < ( (j1) + 1) ^ 2  2 *  (j1) < wB   (rec i j1) ^ 2 <=  (i) < ( (rec i j1) + 1) ^ 2) |- ( (iter_sqrt n rec i j) ^ 2 <=  (i) < ( (iter_sqrt n rec i j) + 1) ^ 2)
----
n : nat, rec : (int  int  int), i : int, j : int, H : (0 <  (i)), H0 : (0 <  (j)), H1 : ( (i) < ( (j) + 1) ^ 2), H2 : (2 *  (j) < wB), H3 : ( j1 : int, 0 <  (j1)  2 ^ Z.of_nat n +  (j1) <=  (j)   (i) < ( (j1) + 1) ^ 2  2 *  (j1) < wB   (rec i j1) ^ 2 <=  (i) < ( (rec i j1) + 1) ^ 2) |- ( (iter_sqrt n rec i j) ^ 2 <=  (i) < ( (iter_sqrt n rec i j) + 1) ^ 2) OUTPUT
auto with zarith
split
intros ?
rewrite Z.pow_succ_r
rewrite Z.mul_comm
assert (0 <  (i))
assert (0 <=  (i))
apply Z.pow_le_mono_nonneg
apply Z.pow_le_mono_l
rewrite Z.pow_le_mono_r
Prediction takes 0.17680001258850098 seconds
( textPrediction = [
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "split", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "rewrite Z.pow_succ_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.mul_comm",
      confidence = 0.5 ),
    ( tacticText = "assert (0 <  (i))",
      confidence = 0.5 ),
    ( tacticText = "assert (0 <=  (i))",
      confidence = 0.5 ),
    ( tacticText = "apply Z.pow_le_mono_nonneg",
      confidence = 0.5 ),
    ( tacticText = "apply Z.pow_le_mono_l",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.pow_le_mono_r",
      confidence = 0.5 ) ] )
STATE
n : nat, rec : (int  int  int), i : int, j : int, H : (0 <  (i)), H0 : (0 <  (j)), H1 : ( (i) < ( (j) + 1) ^ 2), H2 : (2 *  (j) < wB), H3 : ( j1 : int, 0 <  (j1)  2 ^ Z.of_nat n +  (j1) <=  (j)   (i) < ( (j1) + 1) ^ 2  2 *  (j1) < wB   (rec i j1) ^ 2 <=  (i) < ( (rec i j1) + 1) ^ 2) |- ( (iter_sqrt n rec i j) ^ 2 <=  (i) < ( (iter_sqrt n rec i j) + 1) ^ 2)
----
n : nat, rec : (int  int  int), i : int, j : int, H : (0 <  (i)), H0 : (0 <  (j)), H1 : ( (i) < ( (j) + 1) ^ 2), H2 : (2 *  (j) < wB), H3 : ( j1 : int, 0 <  (j1)  2 ^ Z.of_nat n +  (j1) <=  (j)   (i) < ( (j1) + 1) ^ 2  2 *  (j1) < wB   (rec i j1) ^ 2 <=  (i) < ( (rec i j1) + 1) ^ 2) |- ( (iter_sqrt n rec i j) ^ 2 <=  (i) < ( (iter_sqrt n rec i j) + 1) ^ 2) OUTPUT
auto with zarith
split
intros ?
rewrite Z.pow_succ_r
rewrite Z.mul_comm
assert (0 <  (i))
assert (0 <=  (i))
apply Z.pow_le_mono_nonneg
apply Z.pow_le_mono_l
rewrite Z.pow_le_mono_r
Prediction takes 0.25609517097473145 seconds
( textPrediction = [
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "split", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "rewrite Z.pow_succ_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.mul_comm",
      confidence = 0.5 ),
    ( tacticText = "assert (0 <  (i))",
      confidence = 0.5 ),
    ( tacticText = "assert (0 <=  (i))",
      confidence = 0.5 ),
    ( tacticText = "apply Z.pow_le_mono_nonneg",
      confidence = 0.5 ),
    ( tacticText = "apply Z.pow_le_mono_l",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.pow_le_mono_r",
      confidence = 0.5 ) ] )
STATE
n : nat, rec : (int  int  int), i : int, j : int, H : (0 <  (i)), H0 : (0 <  (j)), H1 : ( (i) < ( (j) + 1) ^ 2), H2 : (2 *  (j) < wB), H3 : ( j1 : int, 0 <  (j1)  2 ^ Z.of_nat n +  (j1) <=  (j)   (i) < ( (j1) + 1) ^ 2  2 *  (j1) < wB   (rec i j1) ^ 2 <=  (i) < ( (rec i j1) + 1) ^ 2) |- ( (iter_sqrt n rec i j) ^ 2 <=  (i) < ( (iter_sqrt n rec i j) + 1) ^ 2)
----
n : nat, rec : (int  int  int), i : int, j : int, H : (0 <  (i)), H0 : (0 <  (j)), H1 : ( (i) < ( (j) + 1) ^ 2), H2 : (2 *  (j) < wB), H3 : ( j1 : int, 0 <  (j1)  2 ^ Z.of_nat n +  (j1) <=  (j)   (i) < ( (j1) + 1) ^ 2  2 *  (j1) < wB   (rec i j1) ^ 2 <=  (i) < ( (rec i j1) + 1) ^ 2) |- ( (iter_sqrt n rec i j) ^ 2 <=  (i) < ( (iter_sqrt n rec i j) + 1) ^ 2) OUTPUT
auto with zarith
split
intros ?
rewrite Z.pow_succ_r
rewrite Z.mul_comm
assert (0 <  (i))
assert (0 <=  (i))
apply Z.pow_le_mono_nonneg
apply Z.pow_le_mono_l
rewrite Z.pow_le_mono_r
Prediction takes 0.13261055946350098 seconds
( textPrediction = [
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "split", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "rewrite Z.pow_succ_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.mul_comm",
      confidence = 0.5 ),
    ( tacticText = "assert (0 <  (i))",
      confidence = 0.5 ),
    ( tacticText = "assert (0 <=  (i))",
      confidence = 0.5 ),
    ( tacticText = "apply Z.pow_le_mono_nonneg",
      confidence = 0.5 ),
    ( tacticText = "apply Z.pow_le_mono_l",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.pow_le_mono_r",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
 |- (CMorphisms.Proper (CMorphisms.respectful CRealEq (CMorphisms.respectful CRealEq CRealEq)) CReal_plus)
----
 |- (CMorphisms.Proper (CMorphisms.respectful CRealEq (CMorphisms.respectful CRealEq CRealEq)) CReal_plus) OUTPUT
intros
intros ?
constructor
red
simpl
apply CRealEq_trans
exact CRealEq_trans
exact CRealEq
apply CReal_trans
apply CRealEq
Prediction takes 2.9945085048675537 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "apply CRealEq_trans",
      confidence = 0.5 ),
    ( tacticText = "exact CRealEq_trans",
      confidence = 0.5 ),
    ( tacticText = "exact CRealEq",
      confidence = 0.5 ),
    ( tacticText = "apply CReal_trans",
      confidence = 0.5 ),
    ( tacticText = "apply CRealEq",
      confidence = 0.5 ) ] )
STATE
x : CReal |- (forall y : CReal, x == y -> CMorphisms.respectful CRealEq CRealEq (CReal_plus x) (CReal_plus y))
----
x : CReal |- (forall y : CReal, x == y -> CMorphisms.respectful CRealEq CRealEq (CReal_plus x) (CReal_plus y)) OUTPUT
intros ?
intros
unfold CRealEq
intros until y
red
unfold Qeq
intros until x
unfold CReal_plus
apply CRealEq_trans
apply CRealEq_sym
Prediction takes 0.07404708862304688 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold CRealEq",
      confidence = 0.5 ),
    ( tacticText = "intros until y",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold Qeq",
      confidence = 0.5 ),
    ( tacticText = "intros until x",
      confidence = 0.5 ),
    ( tacticText = "unfold CReal_plus",
      confidence = 0.5 ),
    ( tacticText = "apply CRealEq_trans",
      confidence = 0.5 ),
    ( tacticText = "apply CRealEq_sym",
      confidence = 0.5 ) ] )
STATE
x : CReal, y : CReal |- (x == y -> CMorphisms.respectful CRealEq CRealEq (CReal_plus x) (CReal_plus y))
----
x : CReal, y : CReal |- (x == y -> CMorphisms.respectful CRealEq CRealEq (CReal_plus x) (CReal_plus y)) OUTPUT
intros ?
intros
apply CReal_plus_comm
unfold CRealEq
rewrite CReal_plus_comm
rewrite CReal_plus_assoc
apply CRealEq_sym
unfold CReal_plus
apply CRealEq_trans
apply CRealEq_plus_comm
Prediction takes 0.1868734359741211 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "apply CReal_plus_comm",
      confidence = 0.5 ),
    ( tacticText = "unfold CRealEq",
      confidence = 0.5 ),
    ( tacticText = "rewrite CReal_plus_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite CReal_plus_assoc",
      confidence = 0.5 ),
    ( tacticText = "apply CRealEq_sym",
      confidence = 0.5 ),
    ( tacticText = "unfold CReal_plus",
      confidence = 0.5 ),
    ( tacticText = "apply CRealEq_trans",
      confidence = 0.5 ),
    ( tacticText = "apply CRealEq_plus_comm",
      confidence = 0.5 ) ] )
STATE
x : CReal, y : CReal, H : (x == y) |- (CMorphisms.respectful CRealEq CRealEq (CReal_plus x) (CReal_plus y))
----
x : CReal, y : CReal, H : (x == y) |- (CMorphisms.respectful CRealEq CRealEq (CReal_plus x) (CReal_plus y)) OUTPUT
intros ?
exact H
constructor
apply H
apply CReal_plus_comm
apply CRealEq_sym
assumption
apply CRealEq_trans
apply CReal_plus_sym
apply CRealLt_plus_plus
Prediction takes 0.09456968307495117 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "exact H", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    (tacticText = "apply H", confidence = 0.5),
    ( tacticText = "apply CReal_plus_comm",
      confidence = 0.5 ),
    ( tacticText = "apply CRealEq_sym",
      confidence = 0.5 ),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    ( tacticText = "apply CRealEq_trans",
      confidence = 0.5 ),
    ( tacticText = "apply CReal_plus_sym",
      confidence = 0.5 ),
    ( tacticText = "apply CRealLt_plus_plus",
      confidence = 0.5 ) ] )
STATE
x : CReal, y : CReal, H : (x == y), x0 : CReal |- (forall y0 : CReal, x0 == y0 -> x + x0 == y + y0)
----
x : CReal, y : CReal, H : (x == y), x0 : CReal |- (forall y0 : CReal, x0 == y0 -> x + x0 == y + y0) OUTPUT
intros ?
intros
exact H
apply CReal_plus_comm
apply CReal_plus_0_l
apply CReal_plus_0_r
exact y
clear H
rewrite CReal_plus_comm
apply CRealEq_plus
Prediction takes 0.11766791343688965 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "exact H", confidence = 0.5),
    ( tacticText = "apply CReal_plus_comm",
      confidence = 0.5 ),
    ( tacticText = "apply CReal_plus_0_l",
      confidence = 0.5 ),
    ( tacticText = "apply CReal_plus_0_r",
      confidence = 0.5 ),
    (tacticText = "exact y", confidence = 0.5),
    (tacticText = "clear H", confidence = 0.5),
    ( tacticText = "rewrite CReal_plus_comm",
      confidence = 0.5 ),
    ( tacticText = "apply CRealEq_plus",
      confidence = 0.5 ) ] )
STATE
x : CReal, y : CReal, H : (x == y) |- (CMorphisms.respectful CRealEq CRealEq (CReal_plus x) (CReal_plus y))
----
x : CReal, y : CReal, H : (x == y) |- (CMorphisms.respectful CRealEq CRealEq (CReal_plus x) (CReal_plus y)) OUTPUT
intros ?
exact H
constructor
apply H
apply CReal_plus_comm
apply CRealEq_sym
assumption
apply CRealEq_trans
apply CReal_plus_sym
apply CRealLt_plus_plus
Prediction takes 0.09700274467468262 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "exact H", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    (tacticText = "apply H", confidence = 0.5),
    ( tacticText = "apply CReal_plus_comm",
      confidence = 0.5 ),
    ( tacticText = "apply CRealEq_sym",
      confidence = 0.5 ),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    ( tacticText = "apply CRealEq_trans",
      confidence = 0.5 ),
    ( tacticText = "apply CReal_plus_sym",
      confidence = 0.5 ),
    ( tacticText = "apply CRealLt_plus_plus",
      confidence = 0.5 ) ] )
STATE
x : CReal, y : CReal, H : (x == y) |- (CMorphisms.respectful CRealEq CRealEq (CReal_plus x) (CReal_plus y))
----
x : CReal, y : CReal, H : (x == y) |- (CMorphisms.respectful CRealEq CRealEq (CReal_plus x) (CReal_plus y)) OUTPUT
intros ?
exact H
constructor
apply H
apply CReal_plus_comm
apply CRealEq_sym
assumption
apply CRealEq_trans
apply CReal_plus_sym
apply CRealLt_plus_plus
Prediction takes 0.09534025192260742 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "exact H", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    (tacticText = "apply H", confidence = 0.5),
    ( tacticText = "apply CReal_plus_comm",
      confidence = 0.5 ),
    ( tacticText = "apply CRealEq_sym",
      confidence = 0.5 ),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    ( tacticText = "apply CRealEq_trans",
      confidence = 0.5 ),
    ( tacticText = "apply CReal_plus_sym",
      confidence = 0.5 ),
    ( tacticText = "apply CRealLt_plus_plus",
      confidence = 0.5 ) ] )
STATE
x : CReal, y : CReal, H : (x == y), x0 : CReal, y0 : CReal, H0 : (x0 == y0) |- (x + x0 < y + y0 -> False)
----
x : CReal, y : CReal, H : (x == y), x0 : CReal, y0 : CReal, H0 : (x0 == y0) |- (x + x0 < y + y0 -> False) OUTPUT
intros ?
intros
rewrite H0
exact H0
apply H0
rewrite H
contradiction
apply CRealLt_plus
rewrite CReal_plus_comm
apply CReal_plus_comm
Prediction takes 0.11566925048828125 seconds
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "rewrite H0",
      confidence = 0.5 ),
    (tacticText = "exact H0", confidence = 0.5),
    (tacticText = "apply H0", confidence = 0.5),
    (tacticText = "rewrite H", confidence = 0.5),
    ( tacticText = "contradiction",
      confidence = 0.5 ),
    ( tacticText = "apply CRealLt_plus",
      confidence = 0.5 ),
    ( tacticText = "rewrite CReal_plus_comm",
      confidence = 0.5 ),
    ( tacticText = "apply CReal_plus_comm",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
a : R, b : R, H : (a < b) |- (0 < b - a)
----
a : R, b : R, H : (a < b) |- (0 < b - a) OUTPUT
assumption
auto with real
rewrite Rplus_0_l
elim H
unfold Rminus
apply Rlt_0_1
apply Rlt_trans with b
apply Rle_lt_trans with b
apply Rplus_lt_compat_l
apply Rplus_lt_mono_l
Prediction takes 0.10948753356933594 seconds
( textPrediction = [
    ( tacticText = "assumption",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_0_l",
      confidence = 0.5 ),
    (tacticText = "elim H", confidence = 0.5),
    ( tacticText = "unfold Rminus",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_0_1",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_trans with b",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_lt_trans with b",
      confidence = 0.5 ),
    ( tacticText = "apply Rplus_lt_compat_l",
      confidence = 0.5 ),
    ( tacticText = "apply Rplus_lt_mono_l",
      confidence = 0.5 ) ] )
STATE
a : R, b : R, H : (a < b) |- (0 < b - a)
----
a : R, b : R, H : (a < b) |- (0 < b - a) OUTPUT
assumption
auto with real
rewrite Rplus_0_l
elim H
unfold Rminus
apply Rlt_0_1
apply Rlt_trans with b
apply Rle_lt_trans with b
apply Rplus_lt_compat_l
apply Rplus_lt_mono_l
Prediction takes 0.11063551902770996 seconds
( textPrediction = [
    ( tacticText = "assumption",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_0_l",
      confidence = 0.5 ),
    (tacticText = "elim H", confidence = 0.5),
    ( tacticText = "unfold Rminus",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_0_1",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_trans with b",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_lt_trans with b",
      confidence = 0.5 ),
    ( tacticText = "apply Rplus_lt_compat_l",
      confidence = 0.5 ),
    ( tacticText = "apply Rplus_lt_mono_l",
      confidence = 0.5 ) ] )
STATE
 |- (forall a b : R, a < b -> 0 < b - a)
----
 |- (forall a b : R, a < b -> 0 < b - a) OUTPUT
intros
intros ?
exact Rplus_lt_compat_l
red
exact Rplus_lt_reg_l with b
exact Rplus_lt_reg_l
intros until b
exact Rplus_lt_trans
exact Rplus_lt_0_compat_l
exact Rplus_lt_0_compat
Prediction takes 0.1299912929534912 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "exact Rplus_lt_compat_l",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "exact Rplus_lt_reg_l with b",
      confidence = 0.5 ),
    ( tacticText = "exact Rplus_lt_reg_l",
      confidence = 0.5 ),
    ( tacticText = "intros until b",
      confidence = 0.5 ),
    ( tacticText = "exact Rplus_lt_trans",
      confidence = 0.5 ),
    ( tacticText = "exact Rplus_lt_0_compat_l",
      confidence = 0.5 ),
    ( tacticText = "exact Rplus_lt_0_compat",
      confidence = 0.5 ) ] )
STATE
a : R, b : R, H : (a < b) |- (0 < b - a)
----
a : R, b : R, H : (a < b) |- (0 < b - a) OUTPUT
assumption
auto with real
rewrite Rplus_0_l
elim H
unfold Rminus
apply Rlt_0_1
apply Rlt_trans with b
apply Rle_lt_trans with b
apply Rplus_lt_compat_l
apply Rplus_lt_mono_l
Prediction takes 0.1079416275024414 seconds
( textPrediction = [
    ( tacticText = "assumption",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_0_l",
      confidence = 0.5 ),
    (tacticText = "elim H", confidence = 0.5),
    ( tacticText = "unfold Rminus",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_0_1",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_trans with b",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_lt_trans with b",
      confidence = 0.5 ),
    ( tacticText = "apply Rplus_lt_compat_l",
      confidence = 0.5 ),
    ( tacticText = "apply Rplus_lt_mono_l",
      confidence = 0.5 ) ] )
STATE
a : R |- (forall b : R, a < b -> 0 < b - a)
----
a : R |- (forall b : R, a < b -> 0 < b - a) OUTPUT
intros ?
intros
intros until b
exact Rle_lt_trans
unfold Rle
clear b
red
unfold Rsqr
apply Rle_lt_trans
apply Rle_trans with b
Prediction takes 0.08681702613830566 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "intros until b",
      confidence = 0.5 ),
    ( tacticText = "exact Rle_lt_trans",
      confidence = 0.5 ),
    ( tacticText = "unfold Rle",
      confidence = 0.5 ),
    (tacticText = "clear b", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold Rsqr",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_lt_trans",
      confidence = 0.5 ),
    ( tacticText = "apply Rle_trans with b",
      confidence = 0.5 ) ] )
STATE
 |- (forall n : nat, INR n <> 0 -> n <> 0%nat)
----
 |- (forall n : nat, INR n <> 0 -> n <> 0%nat) OUTPUT
intros ?
intros
auto with real
red
intros until n
simpl
auto with arith
trivial
auto
discriminate
Prediction takes 0.08592057228088379 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "intros until n",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "auto with arith",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "discriminate",
      confidence = 0.5 ) ] )
STATE
n : nat |- (INR n <> 0 -> n <> 0%nat)
----
n : nat |- (INR n <> 0 -> n <> 0%nat) OUTPUT
intros ?
intros
auto with real
auto with arith
auto
simpl
lia
red
intuition
easy
Prediction takes 0.08541107177734375 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "auto with arith",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "lia", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5) ] )
STATE
n : nat, H : (INR n <> 0) |- (n <> 0%nat)
----
n : nat, H : (INR n <> 0) |- (n <> 0%nat) OUTPUT
assumption
auto with real
discriminate
red
apply H
intros ?
easy
apply neq_sym
lia
auto with arith
Prediction takes 0.10331320762634277 seconds
( textPrediction = [
    ( tacticText = "assumption",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "discriminate",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "apply H", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply neq_sym",
      confidence = 0.5 ),
    (tacticText = "lia", confidence = 0.5),
    ( tacticText = "auto with arith",
      confidence = 0.5 ) ] )
STATE
n : nat, H : (INR n <> 0) |- (n <> 0%nat)
----
n : nat, H : (INR n <> 0) |- (n <> 0%nat) OUTPUT
assumption
auto with real
discriminate
red
apply H
intros ?
easy
apply neq_sym
lia
auto with arith
Prediction takes 0.10450530052185059 seconds
( textPrediction = [
    ( tacticText = "assumption",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "discriminate",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "apply H", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply neq_sym",
      confidence = 0.5 ),
    (tacticText = "lia", confidence = 0.5),
    ( tacticText = "auto with arith",
      confidence = 0.5 ) ] )
STATE
n : nat, H : (INR n <> 0) |- (n <> 0%nat)
----
n : nat, H : (INR n <> 0) |- (n <> 0%nat) OUTPUT
assumption
auto with real
discriminate
red
apply H
intros ?
easy
apply neq_sym
lia
Model Loaded
0
STATE
s : t, s' : t, s'' : t, s1 : t, s2 : t, s3 : t, x : elt, x' : elt |- (s [<=] s)
----
s : t, s' : t, s'' : t, s1 : t, s2 : t, s3 : t, x : elt, x' : elt |- (s [<=] s) OUTPUT
fsetdec
Dec.fsetdec
MP.Dec.fsetdec
auto with set
intuition
auto
MP.Add

setoid_rewrite
apply -> subset_spec
Prediction takes 3.015359401702881 seconds
( textPrediction = [
    (tacticText = "fsetdec", confidence = 0.5),
    ( tacticText = "Dec.fsetdec",
      confidence = 0.5 ),
    ( tacticText = "MP.Dec.fsetdec",
      confidence = 0.5 ),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "MP.Add", confidence = 0.5),
    (tacticText = "", confidence = 0.5),
    ( tacticText = "setoid_rewrite",
      confidence = 0.5 ),
    ( tacticText = "apply -> subset_spec",
      confidence = 0.5 ) ] )
Model Loaded
0
STATE
s : t, s' : t, s'' : t, s1 : t, s2 : t, s3 : t, x : elt, x' : elt |- (s1 [<=] s2 -> remove x s1 [<=] s2)
----
s : t, s' : t, s'' : t, s1 : t, s2 : t, s3 : t, x : elt, x' : elt |- (s1 [<=] s2 -> remove x s1 [<=] s2) OUTPUT
fsetdec
Dec.fsetdec
MP.Dec.fsetdec
intros ?
intros
MP.order
MP.Add
MP.remove
unfold remove
MP.union
Prediction takes 3.2591683864593506 seconds
( textPrediction = [
    (tacticText = "fsetdec", confidence = 0.5),
    ( tacticText = "Dec.fsetdec",
      confidence = 0.5 ),
    ( tacticText = "MP.Dec.fsetdec",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "MP.order", confidence = 0.5),
    (tacticText = "MP.Add", confidence = 0.5),
    (tacticText = "MP.remove", confidence = 0.5),
    ( tacticText = "unfold remove",
      confidence = 0.5 ),
    (tacticText = "MP.union", confidence = 0.5) ] )
STATE
 |- (forall (s : t) (x : elt), ~ In x s -> cardinal (add x s) = S (cardinal s))
----
 |- (forall (s : t) (x : elt), ~ In x s -> cardinal (add x s) = S (cardinal s)) OUTPUT
intros
auto
auto with *
unfold cardinal
intros ?
induction s
red
unfold cardinal s
auto with set
auto with sets
Prediction takes 0.12637829780578613 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    ( tacticText = "unfold cardinal",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "induction s",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold cardinal s",
      confidence = 0.5 ),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    ( tacticText = "auto with sets",
      confidence = 0.5 ) ] )
STATE
s : t, x : elt, H : (~ In x s) |- (cardinal (add x s) = S (cardinal s))
----
s : t, x : elt, H : (~ In x s) |- (cardinal (add x s) = S (cardinal s)) OUTPUT
rewrite cardinal_fold
apply cardinal_fold
rewrite cardinal_cardinal
auto with set
auto with sets
apply cardinal_cardinal
unfold cardinal
symmetry
apply cardinal_1
split
Prediction takes 0.06452417373657227 seconds
( textPrediction = [
    ( tacticText = "rewrite cardinal_fold",
      confidence = 0.5 ),
    ( tacticText = "apply cardinal_fold",
      confidence = 0.5 ),
    ( tacticText = "rewrite cardinal_cardinal",
      confidence = 0.5 ),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    ( tacticText = "auto with sets",
      confidence = 0.5 ),
    ( tacticText = "apply cardinal_cardinal",
      confidence = 0.5 ),
    ( tacticText = "unfold cardinal",
      confidence = 0.5 ),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "apply cardinal_1",
      confidence = 0.5 ),
    (tacticText = "split", confidence = 0.5) ] )
STATE
s : t, x : elt, H : (~ In x s) |- (fold (fun _ : elt => S) (add x s) 0 = S (cardinal s))
----
s : t, x : elt, H : (~ In x s) |- (fold (fun _ : elt => S) (add x s) 0 = S (cardinal s)) OUTPUT
rewrite cardinal_fold
apply cardinal_fold
simpl
rewrite cardinal_cardinal
auto with set
unfold cardinal
symmetry
rewrite cardinal_fold0
rewrite <- cardinal_fold
apply cardinal_1
Prediction takes 0.14032530784606934 seconds
( textPrediction = [
    ( tacticText = "rewrite cardinal_fold",
      confidence = 0.5 ),
    ( tacticText = "apply cardinal_fold",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "rewrite cardinal_cardinal",
      confidence = 0.5 ),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    ( tacticText = "unfold cardinal",
      confidence = 0.5 ),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "rewrite cardinal_fold0",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- cardinal_fold",
      confidence = 0.5 ),
    ( tacticText = "apply cardinal_1",
      confidence = 0.5 ) ] )
STATE
s : t, x : elt, H : (~ In x s) |- (fold (fun _ : elt => S) (add x s) 0 = S (fold (fun _ : elt => S) s 0))
----
s : t, x : elt, H : (~ In x s) |- (fold (fun _ : elt => S) (add x s) 0 = S (fold (fun _ : elt => S) s 0)) OUTPUT
rewrite cardinal_fold
apply fold_add
rewrite cardinal_fold0
simpl
apply cardinal_fold
symmetry
rewrite <- cardinal_fold
auto with set
apply cardinal_1
rewrite cardinal_fold with x
Prediction takes 0.11338567733764648 seconds
( textPrediction = [
    ( tacticText = "rewrite cardinal_fold",
      confidence = 0.5 ),
    ( tacticText = "apply fold_add",
      confidence = 0.5 ),
    ( tacticText = "rewrite cardinal_fold0",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "apply cardinal_fold",
      confidence = 0.5 ),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "rewrite <- cardinal_fold",
      confidence = 0.5 ),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    ( tacticText = "apply cardinal_1",
      confidence = 0.5 ),
    ( tacticText = "rewrite cardinal_fold with x",
      confidence = 0.5 ) ] )
STATE
s : t |- (forall x : elt, ~ In x s -> cardinal (add x s) = S (cardinal s))
----
s : t |- (forall x : elt, ~ In x s -> cardinal (add x s) = S (cardinal s)) OUTPUT
intros
intros ?
induction s
unfold cardinal
clear s
auto with set
rewrite cardinal_fold
simpl
auto with fset
auto with sets
Prediction takes 0.08700823783874512 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "induction s",
      confidence = 0.5 ),
    ( tacticText = "unfold cardinal",
      confidence = 0.5 ),
    (tacticText = "clear s", confidence = 0.5),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    ( tacticText = "rewrite cardinal_fold",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "auto with fset",
      confidence = 0.5 ),
    ( tacticText = "auto with sets",
      confidence = 0.5 ) ] )
STATE
 |- (forall (s : t) (x : elt), ~ In x s -> cardinal (add x s) = S (cardinal s))
----
 |- (forall (s : t) (x : elt), ~ In x s -> cardinal (add x s) = S (cardinal s)) OUTPUT
intros
auto
auto with *
unfold cardinal
intros ?
induction s
red
unfold cardinal s
auto with set
auto with sets
Prediction takes 0.0962820053100586 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    ( tacticText = "unfold cardinal",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "induction s",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold cardinal s",
      confidence = 0.5 ),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    ( tacticText = "auto with sets",
      confidence = 0.5 ) ] )
STATE
s : t, x : elt, H : (~ In x s) |- (cardinal (add x s) = S (cardinal s))
----
s : t, x : elt, H : (~ In x s) |- (cardinal (add x s) = S (cardinal s)) OUTPUT
rewrite cardinal_fold
apply cardinal_fold
rewrite cardinal_cardinal
auto with set
auto with sets
apply cardinal_cardinal
unfold cardinal
symmetry
apply cardinal_1
split
Prediction takes 0.08097529411315918 seconds
( textPrediction = [
    ( tacticText = "rewrite cardinal_fold",
      confidence = 0.5 ),
    ( tacticText = "apply cardinal_fold",
      confidence = 0.5 ),
    ( tacticText = "rewrite cardinal_cardinal",
      confidence = 0.5 ),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    ( tacticText = "auto with sets",
      confidence = 0.5 ),
    ( tacticText = "apply cardinal_cardinal",
      confidence = 0.5 ),
    ( tacticText = "unfold cardinal",
      confidence = 0.5 ),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "apply cardinal_1",
      confidence = 0.5 ),
    (tacticText = "split", confidence = 0.5) ] )
STATE
s : t, x : elt, H : (~ In x s) |- (fold (fun _ : elt => S) (add x s) 0 = S (cardinal s))
----
s : t, x : elt, H : (~ In x s) |- (fold (fun _ : elt => S) (add x s) 0 = S (cardinal s)) OUTPUTstarting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)

rewrite cardinal_fold
apply cardinal_fold
simpl
rewrite cardinal_cardinal
auto with set
unfold cardinal
symmetry
rewrite cardinal_fold0
rewrite <- cardinal_fold
apply cardinal_1
Prediction takes 0.0985269546508789 seconds
( textPrediction = [
    ( tacticText = "rewrite cardinal_fold",
      confidence = 0.5 ),
    ( tacticText = "apply cardinal_fold",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "rewrite cardinal_cardinal",
      confidence = 0.5 ),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    ( tacticText = "unfold cardinal",
      confidence = 0.5 ),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "rewrite cardinal_fold0",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- cardinal_fold",
      confidence = 0.5 ),
    ( tacticText = "apply cardinal_1",
      confidence = 0.5 ) ] )
STATE
s : t, x : elt, H : (~ In x s) |- (fold (fun _ : elt => S) (add x s) 0 = S (fold (fun _ : elt => S) s 0))
----
s : t, x : elt, H : (~ In x s) |- (fold (fun _ : elt => S) (add x s) 0 = S (fold (fun _ : elt => S) s 0)) OUTPUT
rewrite cardinal_fold
apply fold_add
rewrite cardinal_fold0
simpl
apply cardinal_fold
symmetry
rewrite <- cardinal_fold
auto with set
apply cardinal_1
rewrite cardinal_fold with x
Prediction takes 0.18004989624023438 seconds
( textPrediction = [
    ( tacticText = "rewrite cardinal_fold",
      confidence = 0.5 ),
    ( tacticText = "apply fold_add",
      confidence = 0.5 ),
    ( tacticText = "rewrite cardinal_fold0",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "apply cardinal_fold",
      confidence = 0.5 ),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "rewrite <- cardinal_fold",
      confidence = 0.5 ),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    ( tacticText = "apply cardinal_1",
      confidence = 0.5 ),
    ( tacticText = "rewrite cardinal_fold with x",
      confidence = 0.5 ) ] )
STATE
s : t |- (forall x : elt, ~ In x s -> cardinal (add x s) = S (cardinal s))
----
s : t |- (forall x : elt, ~ In x s -> cardinal (add x s) = S (cardinal s)) OUTPUT
intros
intros ?
induction s
unfold cardinal
clear s
auto with set
rewrite cardinal_fold
simpl
auto with fset
auto with sets
Prediction takes 0.09364008903503418 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "induction s",
      confidence = 0.5 ),
    ( tacticText = "unfold cardinal",
      confidence = 0.5 ),
    (tacticText = "clear s", confidence = 0.5),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    ( tacticText = "rewrite cardinal_fold",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "auto with fset",
      confidence = 0.5 ),
    ( tacticText = "auto with sets",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
auto with arith
Prediction takes 0.09939408302307129 seconds
( textPrediction = [
    ( tacticText = "assumption",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "discriminate",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "apply H", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply neq_sym",
      confidence = 0.5 ),
    (tacticText = "lia", confidence = 0.5),
    ( tacticText = "auto with arith",
      confidence = 0.5 ) ] )
STATE
 |- (forall n : nat, INR n <> 0 -> n = 0%nat -> False)
----
 |- (forall n : nat, INR n <> 0 -> n = 0%nat -> False) OUTPUT
intros ?
intros
auto with real
simpl
auto with arith
red
trivial
auto
auto with *
auto with relations
Prediction takes 0.05496788024902344 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "auto with arith",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    ( tacticText = "auto with relations",
      confidence = 0.5 ) ] )
STATE
 |- (forall n : nat, INR n <> 0 -> n <> 0%nat)
----
 |- (forall n : nat, INR n <> 0 -> n <> 0%nat) OUTPUT
intros ?
intros
auto with real
red
intros until n
simpl
auto with arith
trivial
auto
discriminate
Prediction takes 0.054392099380493164 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "intros until n",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "auto with arith",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "discriminate",
      confidence = 0.5 ) ] )
STATE
n : nat |- (INR n <> 0 -> n <> 0%nat)
----
n : nat |- (INR n <> 0 -> n <> 0%nat) OUTPUT
intros ?
intros
auto with real
auto with arith
auto
simpl
lia
red
intuition
easy
Prediction takes 0.05569124221801758 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "auto with arith",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "lia", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5) ] )
STATE
n : nat, H : (INR n <> 0) |- (n <> 0%nat)
----
n : nat, H : (INR n <> 0) |- (n <> 0%nat) OUTPUT
assumption
auto with real
discriminate
red
apply H
intros ?
easy
apply neq_sym
lia
auto with arith
Prediction takes 0.06180381774902344 seconds
( textPrediction = [
    ( tacticText = "assumption",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "discriminate",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "apply H", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply neq_sym",
      confidence = 0.5 ),
    (tacticText = "lia", confidence = 0.5),
    ( tacticText = "auto with arith",
      confidence = 0.5 ) ] )
STATE
n : nat, H : (INR n <> 0) |- (n = 0%nat -> False)
----
n : nat, H : (INR n <> 0) |- (n = 0%nat -> False) OUTPUT
intros ?
intros
auto with real
auto
easy
auto with arith
simpl
trivial
apply H
red
Prediction takes 0.054354190826416016 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "auto with arith",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "apply H", confidence = 0.5),
    (tacticText = "red", confidence = 0.5) ] )
STATE
n : nat, H : (INR n <> 0) |- (n <> 0%nat)
----
n : nat, H : (INR n <> 0) |- (n <> 0%nat) OUTPUT
assumption
auto with real
discriminate
red
apply H
intros ?
easy
apply neq_sym
lia
auto with arith
Prediction takes 0.13634419441223145 seconds
( textPrediction = [
    ( tacticText = "assumption",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "discriminate",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "apply H", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply neq_sym",
      confidence = 0.5 ),
    (tacticText = "lia", confidence = 0.5),
    ( tacticText = "auto with arith",
      confidence = 0.5 ) ] )
STATE
x : Z, y : Z |- (IZR x = IZR y -> Zeq_bool x y = true)
----
x : Z, y : Z |- (IZR x = IZR y -> Zeq_bool x y = true) OUTPUT
intros ?
intros
unfold IZR
unfold Z.odd
auto with real
easy
auto with zarith
trivial
apply Z.eq_sym
apply Zeq_sym
Prediction takes 0.10201668739318848 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold IZR",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.odd",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "apply Z.eq_sym",
      confidence = 0.5 ),
    ( tacticText = "apply Zeq_sym",
      confidence = 0.5 ) ] )
STATE
x : Z, y : Z, H : (IZR x = IZR y) |- (Zeq_bool x y = true)
----
x : Z, y : Z, H : (IZR x = IZR y) |- (Zeq_bool x y = true) OUTPUT
symmetry
apply Z.lt_not_eq
apply Z.eq_sym
easy
symmetry in H
apply Z.eq_not_eq
auto
auto with real
auto with zarith
apply Zeq_sym
Prediction takes 0.14107728004455566 seconds
( textPrediction = [
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "apply Z.lt_not_eq",
      confidence = 0.5 ),
    ( tacticText = "apply Z.eq_sym",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "symmetry in H",
      confidence = 0.5 ),
    ( tacticText = "apply Z.eq_not_eq",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    ( tacticText = "apply Zeq_sym",
      confidence = 0.5 ) ] )
STATE
x : Z, y : Z, H : (IZR x = IZR y) |- (true = Zeq_bool x y)
----
x : Z, y : Z, H : (IZR x = IZR y) |- (true = Zeq_bool x y) OUTPUT
symmetry
easy
auto with zarith
trivial
subst
auto with real
apply Z.lt_not_eq
apply Z.eq_not_eq
apply Z.eq_sym
apply Z.odd_not_eq
Prediction takes 0.10578727722167969 seconds
( textPrediction = [
    (tacticText = "symmetry", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_not_eq",
      confidence = 0.5 ),
    ( tacticText = "apply Z.eq_not_eq",
      confidence = 0.5 ),
    ( tacticText = "apply Z.eq_sym",
      confidence = 0.5 ),
    ( tacticText = "apply Z.odd_not_eq",
      confidence = 0.5 ) ] )
STATE
x : Z, y : Z, H : (IZR x = IZR y) |- (Zeq_bool x y = true)
----huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
elt : Type |- (forall (m : t elt) (acc : list (key * elt)), (length acc + cardinal m)%nat = length (elements_aux acc m))
----
elt : Type |- (forall (m : t elt) (acc : list (key * elt)), (length acc + cardinal m)%nat = length (elements_aux acc m)) OUTPUT
induction l
intros
induction m
simpl
unfold elements
intros ?
unfold elements_aux
auto
induction k
unfold elements_cardinal
Prediction takes 2.815139055252075 seconds
( textPrediction = [
    ( tacticText = "induction l",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction m",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold elements",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold elements_aux",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "induction k",
      confidence = 0.5 ),
    ( tacticText = "unfold elements_cardinal",
      confidence = 0.5 ) ] )
STATE
elt : Type, m : (t elt), acc : (list (key * elt)) |- ((length acc + cardinal m)%nat = length (elements_aux acc m))
----
elt : Type, m : (t elt), acc : (list (key * elt)) |- ((length acc + cardinal m)%nat = length (elements_aux acc m)) OUTPUT
simpl
rewrite elements_1
rewrite elements_Empty
rewrite elements_cardinal
rewrite elements_in
unfold elements
auto
rewrite elements_mapsto
rewrite elements_node
rewrite elements_spec
Prediction takes 0.06384396553039551 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "rewrite elements_1",
      confidence = 0.5 ),
    ( tacticText = "rewrite elements_Empty",
      confidence = 0.5 ),
    ( tacticText = "rewrite elements_cardinal",
      confidence = 0.5 ),
    ( tacticText = "rewrite elements_in",
      confidence = 0.5 ),
    ( tacticText = "unfold elements",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "rewrite elements_mapsto",
      confidence = 0.5 ),
    ( tacticText = "rewrite elements_node",
      confidence = 0.5 ),
    ( tacticText = "rewrite elements_spec",
      confidence = 0.5 ) ] )
STATE
elt : Type |- (forall acc : list (key * elt), (length acc + cardinal (Leaf elt))%nat = length (elements_aux acc (Leaf elt)))
----
elt : Type |- (forall acc : list (key * elt), (length acc + cardinal (Leaf elt))%nat = length (elements_aux acc (Leaf elt))) OUTPUT
simpl
intros
induction acc
auto
intros ?
simpl in *
unfold elements
unfold elements_aux
inversion 1
simpl elements_aux
Prediction takes 0.0691070556640625 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction acc",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "simpl in *",
      confidence = 0.5 ),
    ( tacticText = "unfold elements",
      confidence = 0.5 ),
    ( tacticText = "unfold elements_aux",
      confidence = 0.5 ),
    ( tacticText = "inversion 1",
      confidence = 0.5 ),
    ( tacticText = "simpl elements_aux",
      confidence = 0.5 ) ] )
STATE
elt : Type |- (forall acc : list (key * elt), (length acc + 0)%nat = length acc)
----
elt : Type |- (forall acc : list (key * elt), (length acc + 0)%nat = length acc) OUTPUT
simpl
intros
auto
induction acc
intros ?
induction l
inversion 1
unfold elements
induction i
intros until acc
Prediction takes 0.053000688552856445 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "induction acc",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "induction l",
      confidence = 0.5 ),
    ( tacticText = "inversion 1",
      confidence = 0.5 ),
    ( tacticText = "unfold elements",
      confidence = 0.5 ),
    ( tacticText = "induction i",
      confidence = 0.5 ),
    ( tacticText = "intros until acc",
      confidence = 0.5 ) ] )
STATE
elt : Type |- (forall (m : t elt) (acc : list (key * elt)), (length acc + cardinal m)%nat = length (elements_aux acc m))
----
elt : Type |- (forall (m : t elt) (acc : list (key * elt)), (length acc + cardinal m)%nat = length (elements_aux acc m)) OUTPUT
induction l
intros
induction m
simpl
unfold elements
intros ?
unfold elements_aux
auto
induction k
unfold elements_cardinal
Prediction takes 0.10719871520996094 seconds
( textPrediction = [
    ( tacticText = "induction l",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction m",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold elements",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold elements_aux",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "induction k",
      confidence = 0.5 ),
    ( tacticText = "unfold elements_cardinal",
      confidence = 0.5 ) ] )
STATE
elt : Type, m : (t elt), acc : (list (key * elt)) |- ((length acc + cardinal m)%nat = length (elements_aux acc m))
----
elt : Type, m : (t elt), acc : (list (key * elt)) |- ((length acc + cardinal m)%nat = length (elements_aux acc m)) OUTPUT
simpl
rewrite elements_1
rewrite elements_Empty
rewrite elements_cardinal
rewrite elements_in
unfold elements
auto
rewrite elements_mapsto
rewrite elements_node
rewrite elements_spec
Prediction takes 0.06654953956604004 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "rewrite elements_1",
      confidence = 0.5 ),
    ( tacticText = "rewrite elements_Empty",
      confidence = 0.5 ),
    ( tacticText = "rewrite elements_cardinal",
      confidence = 0.5 ),
    ( tacticText = "rewrite elements_in",
      confidence = 0.5 ),
    ( tacticText = "unfold elements",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "rewrite elements_mapsto",
      confidence = 0.5 ),
    ( tacticText = "rewrite elements_node",
      confidence = 0.5 ),
    ( tacticText = "rewrite elements_spec",
      confidence = 0.5 ) ] )
STATE
elt : Type |- (forall acc : list (key * elt), (length acc + cardinal (Leaf elt))%nat = length (elements_aux acc (Leaf elt)))
----
elt : Type |- (forall acc : list (key * elt), (length acc + cardinal (Leaf elt))%nat = length (elements_aux acc (Leaf elt))) OUTPUT
simpl
intros
induction acc
auto
intros ?
simpl in *
unfold elements
unfold elements_aux
inversion 1
simpl elements_aux
Prediction takes 0.07250308990478516 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction acc",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "simpl in *",
      confidence = 0.5 ),
    ( tacticText = "unfold elements",
      confidence = 0.5 ),
    ( tacticText = "unfold elements_aux",
      confidence = 0.5 ),
    ( tacticText = "inversion 1",
      confidence = 0.5 ),
    ( tacticText = "simpl elements_aux",
      confidence = 0.5 ) ] )
STATE
elt : Type |- (forall acc : list (key * elt), (length acc + 0)%nat = length acc)
----
elt : Type |- (forall acc : list (key * elt), (length acc + 0)%nat = length acc) OUTPUT
simpl
intros
auto
induction acc
intros ?
induction l
inversion 1
unfold elements
induction i
intros until acc
Prediction takes 0.05480837821960449 seconds
Model Loaded
0
STATE
 |- (forall x : Z, 0 < x <-> 0 <= x - 1)
----
 |- (forall x : Z, 0 < x <-> 0 <= x - 1) OUTPUT
intros
intros ?
split
apply Z.le_le_le_incl
apply Z.le_le_antisym
apply Z.le_le_ge_cases
apply Z.le_ge_cases
apply Z.lt_le_le_incl
setoid_replace x with 0
exact Z.le_le_antisym
Prediction takes 3.253962278366089 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "apply Z.le_le_le_incl",
      confidence = 0.5 ),
    ( tacticText = "apply Z.le_le_antisym",
      confidence = 0.5 ),
    ( tacticText = "apply Z.le_le_ge_cases",
      confidence = 0.5 ),
    ( tacticText = "apply Z.le_ge_cases",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_le_le_incl",
      confidence = 0.5 ),
    ( tacticText = "setoid_replace x with 0",
      confidence = 0.5 ),
    ( tacticText = "exact Z.le_le_antisym",
      confidence = 0.5 ) ] )
STATE
x : Z |- (0 < x <-> 0 <= x - 1)
----
x : Z |- (0 < x <-> 0 <= x - 1) OUTPUT
split
rewrite Z.opp_r
rewrite Z.opp_involutive
rewrite Z.opp_le_mono
rewrite Z.opp_opp_r
rewrite Z.mul_opp_r
rewrite Z.opp_l
rewrite Z.opp_nonneg
easy
rewrite Z.opp_neg_r
Prediction takes 0.11080121994018555 seconds
( textPrediction = [
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "rewrite Z.opp_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.opp_involutive",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.opp_le_mono",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.opp_opp_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.mul_opp_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.opp_l",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.opp_nonneg",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite Z.opp_neg_r",
      confidence = 0.5 ) ] )
STATE
x : Z |- (0 < x -> 0 <= x - 1)
----
x : Z |- (0 < x -> 0 <= x - 1) OUTPUT
intros ?
intros
lia
destruct 1
rewrite Z.opp_r
auto with zarith
trivial
easy
rewrite Z.opp_involutive
apply Z.ge_le
Prediction takes 0.08655166625976562 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "lia", confidence = 0.5),
    ( tacticText = "destruct 1",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.opp_r",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite Z.opp_involutive",
      confidence = 0.5 ),
    ( tacticText = "apply Z.ge_le",
      confidence = 0.5 ) ] )
STATE
x : Z, H : (0 < x) |- (0 <= x - 1)
----
x : Z, H : (0 < x) |- (0 <= x - 1) OUTPUT
lia
apply Z.le_0_le
order
split
apply Z.le_le_mono
apply Z.lt_le_mono
apply Z.lt_le_incl
left
rewrite Z.opp_le_mono
auto with zarith
Prediction takes 0.10327553749084473 seconds
( textPrediction = [
    (tacticText = "lia", confidence = 0.5),
    ( tacticText = "apply Z.le_0_le",
      confidence = 0.5 ),
    (tacticText = "order", confidence = 0.5),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "apply Z.le_le_mono",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_le_mono",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_le_incl",
      confidence = 0.5 ),
    (tacticText = "left", confidence = 0.5),
    ( tacticText = "rewrite Z.opp_le_mono",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ) ] )
STATE
x : Z, H : (0 < x) |- (0 < x - 1)
----
x : Z, H : (0 < x) |- (0 < x - 1) OUTPUT
apply lt_0_1
apply Z.lt_0_1
apply Z.lt_0_le
apply Z.lt_0_lt
lia
auto with real
split
easy
apply Z.lt_neq
rewrite Z.opp_neg_pos
Prediction takes 0.1072244644165039 seconds
( textPrediction = [
    ( tacticText = "apply lt_0_1",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_0_1",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_0_le",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_0_lt",
      confidence = 0.5 ),
    (tacticText = "lia", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "split", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply Z.lt_neq",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.opp_neg_pos",
      confidence = 0.5 ) ] )
STATE
x : Z, H : (0 < x) |- (0 <= x - 1)
----
x : Z, H : (0 < x) |- (0 <= x - 1) OUTPUT
lia
apply Z.le_0_le
order
split
apply Z.le_le_mono
apply Z.lt_le_mono
apply Z.lt_le_incl
left
rewrite Z.opp_le_mono
auto with zarith
Prediction takes 0.18065381050109863 seconds
( textPrediction = [
    (tacticText = "lia", confidence = 0.5),
    ( tacticText = "apply Z.le_0_le",
      confidence = 0.5 ),
    (tacticText = "order", confidence = 0.5),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "apply Z.le_le_mono",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_le_mono",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_le_incl",
      confidence = 0.5 ),
    (tacticText = "left", confidence = 0.5),
    ( tacticText = "rewrite Z.opp_le_mono",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext

x : Z, y : Z, H : (IZR x = IZR y) |- (Zeq_bool x y = true) OUTPUT
symmetry
apply Z.lt_not_eq
apply Z.eq_sym
easy
symmetry in H
apply Z.eq_not_eq
auto
auto with real
auto with zarith
apply Zeq_sym
Prediction takes 0.15439915657043457 seconds
( textPrediction = [
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "apply Z.lt_not_eq",
      confidence = 0.5 ),
    ( tacticText = "apply Z.eq_sym",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "symmetry in H",
      confidence = 0.5 ),
    ( tacticText = "apply Z.eq_not_eq",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    ( tacticText = "apply Zeq_sym",
      confidence = 0.5 ) ] )
STATE
x : Z, y : Z, H : (IZR x = IZR y) |- (true = Zeq_bool x y)
----
x : Z, y : Z, H : (IZR x = IZR y) |- (true = Zeq_bool x y) OUTPUT
symmetry
easy
auto with zarith
trivial
subst
auto with real
apply Z.lt_not_eq
apply Z.eq_not_eq
apply Z.eq_sym
apply Z.odd_not_eq
Prediction takes 0.10770845413208008 seconds
( textPrediction = [
    (tacticText = "symmetry", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_not_eq",
      confidence = 0.5 ),
    ( tacticText = "apply Z.eq_not_eq",
      confidence = 0.5 ),
    ( tacticText = "apply Z.eq_sym",
      confidence = 0.5 ),
    ( tacticText = "apply Z.odd_not_eq",
      confidence = 0.5 ) ] )
STATE
x : Z, y : Z, H : (IZR x = IZR y) |- (Zeq_bool x y = true)
----
x : Z, y : Z, H : (IZR x = IZR y) |- (Zeq_bool x y = true) OUTPUT
symmetry
apply Z.lt_not_eq
apply Z.eq_sym
easy
symmetry in H
apply Z.eq_not_eq
auto
auto with real
auto with zarith
apply Zeq_sym
Prediction takes 0.10664224624633789 seconds
( textPrediction = [
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "apply Z.lt_not_eq",
      confidence = 0.5 ),
    ( tacticText = "apply Z.eq_sym",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "symmetry in H",
      confidence = 0.5 ),
    ( tacticText = "apply Z.eq_not_eq",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    ( tacticText = "apply Zeq_sym",
      confidence = 0.5 ) ] )
STATE
x : Z, y : Z, H : (IZR x = IZR y) |- (true = Zeq_bool x y)
----
x : Z, y : Z, H : (IZR x = IZR y) |- (true = Zeq_bool x y) OUTPUT
symmetry
easy
auto with zarith
trivial
subst
auto with real
apply Z.lt_not_eq
apply Z.eq_not_eq
apply Z.eq_sym
apply Z.odd_not_eq
Prediction takes 0.10928654670715332 seconds
( textPrediction = [
    (tacticText = "symmetry", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_not_eq",
      confidence = 0.5 ),
    ( tacticText = "apply Z.eq_not_eq",
      confidence = 0.5 ),
    ( tacticText = "apply Z.eq_sym",
      confidence = 0.5 ),
    ( tacticText = "apply Z.odd_not_eq",
      confidence = 0.5 ) ] )
STATE
x : Z, y : Z, H : (IZR x = IZR y) |- (Zeq_bool x y = true)
----
x : Z, y : Z, H : (IZR x = IZR y) |- (Zeq_bool x y = true) OUTPUT
symmetry
apply Z.lt_not_eq
apply Z.eq_sym
easy
symmetry in H
apply Z.eq_not_eq
auto
auto with real
auto with zarith
apply Zeq_sym
Prediction takes 0.12920641899108887 seconds
( textPrediction = [
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "apply Z.lt_not_eq",
      confidence = 0.5 ),
    ( tacticText = "apply Z.eq_sym",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "symmetry in H",
      confidence = 0.5 ),
    ( tacticText = "apply Z.eq_not_eq",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    ( tacticText = "apply Zeq_sym",
      confidence = 0.5 ) ] )
STATE
x : Z, y : Z, H : (IZR x = IZR y) |- (true = Zeq_bool x y)
----
x : Z, y : Z, H : (IZR x = IZR y) |- (true = Zeq_bool x y) OUTPUT
symmetry
easy
auto with zarith
trivial
subst
auto with real
apply Z.lt_not_eq
apply Z.eq_not_eq
apply Z.eq_sym
apply Z.odd_not_eq
Prediction takes 0.13663411140441895 seconds
( textPrediction = [
    (tacticText = "symmetry", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_not_eq",
      confidence = 0.5 ),
    ( tacticText = "apply Z.eq_not_eq",
      confidence = 0.5 ),
    ( tacticText = "apply Z.eq_sym",
      confidence = 0.5 ),
    ( tacticText = "apply Z.odd_not_eq",
      confidence = 0.5 ) ] )
STATE
x : Z, y : Z, H : (IZR x = IZR y) |- (Zeq_bool x y = true)
----
x : Z, y : Z, H : (IZR x = IZR y) |- (Zeq_bool x y = true) OUTPUT
symmetry
apply Z.lt_not_eq
apply Z.eq_sym
easy
symmetry in H
apply Z.eq_not_eq
auto
auto with real
auto with zarith
apply Zeq_sym
Prediction takes 0.12900662422180176 seconds
( textPrediction = [
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "apply Z.lt_not_eq",
      confidence = 0.5 ),
    ( tacticText = "apply Z.eq_sym",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "symmetry in H",
      confidence = 0.5 ),
    ( tacticText = "apply Z.eq_not_eq",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    ( tacticText = "apply Zeq_sym",
      confidence = 0.5 ) ] )
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
s : t, s' : t, x : elt, y : elt |- (forall f : elt -> bool, Proper (E.eq ==> Logic.eq) f -> for_all f s = true <-> For_all (fun x : elt => f x = true) s)
----
s : t, s' : t, x : elt, y : elt |- (forall f : elt -> bool, Proper (E.eq ==> Logic.eq) f -> for_all f s = true <-> For_all (fun x : elt => f x = true) s) OUTPUT
intros
induction s
unfold For_all
intros ?
exact (Raw.for_all_spec _ _)
split
exact (M.for_all_spec _ _)
exact (for_all_spec _ _)
auto
destruct (f x)
Prediction takes 2.9897100925445557 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction s",
      confidence = 0.5 ),
    ( tacticText = "unfold For_all",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "exact (Raw.for_all_spec _ _)",
      confidence = 0.5 ),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "exact (M.for_all_spec _ _)",
      confidence = 0.5 ),
    ( tacticText = "exact (for_all_spec _ _)",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "destruct (f x)",
      confidence = 0.5 ) ] )
STATE
s : t, s' : t, x : elt, y : elt, f : (elt -> bool), H : (Proper (E.eq ==> Logic.eq) f) |- (for_all f s = true <-> For_all (fun x : elt => f x = true) s)
----
s : t, s' : t, x : elt, y : elt, f : (elt -> bool), H : (Proper (E.eq ==> Logic.eq) f) |- (for_all f s = true <-> For_all (fun x : elt => f x = true) s) OUTPUT
apply iff_sym
auto
apply for_all_spec
apply for_all_2
apply -> for_all_spec
rewrite for_all_spec
apply For_all_spec
apply For_all_2
apply is_empty_spec
rewrite <- for_all_spec
Prediction takes 0.1067667007446289 seconds
( textPrediction = [
    ( tacticText = "apply iff_sym",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "apply for_all_spec",
      confidence = 0.5 ),
    ( tacticText = "apply for_all_2",
      confidence = 0.5 ),
    ( tacticText = "apply -> for_all_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite for_all_spec",
      confidence = 0.5 ),
    ( tacticText = "apply For_all_spec",
      confidence = 0.5 ),
    ( tacticText = "apply For_all_2",
      confidence = 0.5 ),
    ( tacticText = "apply is_empty_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- for_all_spec",
      confidence = 0.5 ) ] )
STATE
s : t, s' : t, x : elt, y : elt, f : (elt -> bool), H : (Proper (E.eq ==> Logic.eq) f) |- (For_all (fun x : elt => f x = true) s <-> for_all f s = true)
----
s : t, s' : t, x : elt, y : elt, f : (elt -> bool), H : (Proper (E.eq ==> Logic.eq) f) |- (For_all (fun x : elt => f x = true) s <-> for_all f s = true) OUTPUT
apply iff_sym
auto
apply for_all_spec
apply for_all_2
apply -> for_all_spec
destruct (f x)
apply <- for_all_spec
apply for_all_1
rewrite for_all_all_spec
apply for_all_all_2
Prediction takes 0.11488652229309082 seconds
( textPrediction = [
    ( tacticText = "apply iff_sym",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "apply for_all_spec",
      confidence = 0.5 ),
    ( tacticText = "apply for_all_2",
      confidence = 0.5 ),
    ( tacticText = "apply -> for_all_spec",
      confidence = 0.5 ),
    ( tacticText = "destruct (f x)",
      confidence = 0.5 ),
    ( tacticText = "apply <- for_all_spec",
      confidence = 0.5 ),
    ( tacticText = "apply for_all_1",
      confidence = 0.5 ),
    ( tacticText = "rewrite for_all_all_spec",
      confidence = 0.5 ),
    ( tacticText = "apply for_all_all_2",
      confidence = 0.5 ) ] )
STATE
s : t, s' : t, x : elt, y : elt, f : (elt -> bool), H : (Proper (E.eq ==> Logic.eq) f) |- (for_all f s = true <-> For_all (fun x : elt => f x = true) s)
----
s : t, s' : t, x : elt, y : elt, f : (elt -> bool), H : (Proper (E.eq ==> Logic.eq) f) |- (for_all f s = true <-> For_all (fun x : elt => f x = true) s) OUTPUT
apply iff_sym
auto
apply for_all_spec
apply for_all_2
apply -> for_all_spec
rewrite for_all_spec
apply For_all_spec
apply For_all_2
apply is_empty_spec
rewrite <- for_all_spec
Prediction takes 0.10878920555114746 seconds
( textPrediction = [
    ( tacticText = "apply iff_sym",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "apply for_all_spec",
      confidence = 0.5 ),
    ( tacticText = "apply for_all_2",
      confidence = 0.5 ),
    ( tacticText = "apply -> for_all_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite for_all_spec",
      confidence = 0.5 ),
    ( tacticText = "apply For_all_spec",
      confidence = 0.5 ),
    ( tacticText = "apply For_all_2",
      confidence = 0.5 ),
    ( tacticText = "apply is_empty_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- for_all_spec",
      confidence = 0.5 ) ] )
STATE
s : t, s' : t, x : elt, y : elt, f : (elt -> bool), H : (Proper (E.eq ==> Logic.eq) f) |- (For_all (fun x : elt => f x = true) s <-> for_all f s = true)
----
s : t, s' : t, x : elt, y : elt, f : (elt -> bool), H : (Proper (E.eq ==> Logic.eq) f) |- (For_all (fun x : elt => f x = true) s <-> for_all f s = true) OUTPUT
apply iff_sym
auto
apply for_all_spec
apply for_all_2
apply -> for_all_spec
destruct (f x)
apply <- for_all_spec
apply for_all_1
rewrite for_all_all_spec
apply for_all_all_2
Prediction takes 0.11277294158935547 seconds
( textPrediction = [
    ( tacticText = "apply iff_sym",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "apply for_all_spec",
      confidence = 0.5 ),
    ( tacticText = "apply for_all_2",
      confidence = 0.5 ),
    ( tacticText = "apply -> for_all_spec",
      confidence = 0.5 ),
    ( tacticText = "destruct (f x)",
      confidence = 0.5 ),
    ( tacticText = "apply <- for_all_spec",
      confidence = 0.5 ),
    ( tacticText = "apply for_all_1",
      confidence = 0.5 ),
    ( tacticText = "rewrite for_all_all_spec",
      confidence = 0.5 ),
    ( tacticText = "apply for_all_all_2",
      confidence = 0.5 ) ] )
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
starting proving server with connection through their stdin
using textmode optiontext
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
elt : Type, elt' : Type, elt'' : Type |- (forall (m : t elt) (x : key) (b : elt') (f : key -> elt -> elt'), (forall (x0 y : key) (e : elt), E.eq x0 y -> f x0 e = f y e) -> MapsTo x b (mapi f m) <-> (exists a : elt, b = f x a /\ MapsTo x a m))
----
elt : Type, elt' : Type, elt'' : Type |- (forall (m : t elt) (x : key) (b : elt') (f : key -> elt -> elt'), (forall (x0 y : key) (e : elt), E.eq x0 y -> f x0 e = f y e) -> MapsTo x b (mapi f m) <-> (exists a : elt, b = f x a /\ MapsTo x a m)) OUTPUT
intros ?
intros
split
unfold MapsTo
unfold f
induction m
unfold g
unfold create
unfold creflexivity
exact (Raw.Proofs.mapi_2 (x:=x))
Prediction takes 3.00075101852417 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "unfold MapsTo",
      confidence = 0.5 ),
    (tacticText = "unfold f", confidence = 0.5),
    ( tacticText = "induction m",
      confidence = 0.5 ),
    (tacticText = "unfold g", confidence = 0.5),
    ( tacticText = "unfold create",
      confidence = 0.5 ),
    ( tacticText = "unfold creflexivity",
      confidence = 0.5 ),
    ( tacticText = "exact (Raw.Proofs.mapi_2 (x:=x))",
      confidence = 0.5 ) ] )
STATE
elt : Type, elt' : Type, elt'' : Type, m : (t elt) |- (forall (x : key) (b : elt') (f : key -> elt -> elt'), (forall (x0 y : key) (e : elt), E.eq x0 y -> f x0 e = f y e) -> MapsTo x b (mapi f m) <-> (exists a : elt, b = f x a /\ MapsTo x a m))
----
elt : Type, elt' : Type, elt'' : Type, m : (t elt) |- (forall (x : key) (b : elt') (f : key -> elt -> elt'), (forall (x0 y : key) (e : elt), E.eq x0 y -> f x0 e = f y e) -> MapsTo x b (mapi f m) <-> (exists a : elt, b = f x a /\ MapsTo x a m)) OUTPUT
intros ?
intros
split
unfold MapsTo
induction m
unfold f
simpl
intros until b
unfold g
exact (Raw.Proofs.mapi_2 (m:=m))
Prediction takes 0.23935723304748535 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "unfold MapsTo",
      confidence = 0.5 ),
    ( tacticText = "induction m",
      confidence = 0.5 ),
    (tacticText = "unfold f", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "intros until b",
      confidence = 0.5 ),
    (tacticText = "unfold g", confidence = 0.5),
    ( tacticText = "exact (Raw.Proofs.mapi_2 (m:=m))",
      confidence = 0.5 ) ] )
STATE
elt : Type, elt' : Type, elt'' : Type, m : (t elt), x : key |- (forall (b : elt') (f : key -> elt -> elt'), (forall (x y : key) (e : elt), E.eq x y -> f x e = f y e) -> MapsTo x b (mapi f m) <-> (exists a : elt, b = f x a /\ MapsTo x a m))
----
elt : Type, elt' : Type, elt'' : Type, m : (t elt), x : key |- (forall (b : elt') (f : key -> elt -> elt'), (forall (x y : key) (e : elt), E.eq x y -> f x e = f y e) -> MapsTo x b (mapi f m) <-> (exists a : elt, b = f x a /\ MapsTo x a m)) OUTPUT
intros ?
intros
split
unfold MapsTo
unfold f
unfold g
induction m
intros until b
unfold g.eq_dec
unfold g.eq
Prediction takes 0.0978994369506836 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "unfold MapsTo",
      confidence = 0.5 ),
    (tacticText = "unfold f", confidence = 0.5),
    (tacticText = "unfold g", confidence = 0.5),
    ( tacticText = "induction m",
      confidence = 0.5 ),
    ( tacticText = "intros until b",
      confidence = 0.5 ),
    ( tacticText = "unfold g.eq_dec",
      confidence = 0.5 ),
    ( tacticText = "unfold g.eq",
      confidence = 0.5 ) ] )
STATE
elt : Type, elt' : Type, elt'' : Type, m : (t elt), x : key, b : elt' |- (forall f : key -> elt -> elt', (forall (x y : key) (e : elt), E.eq x y -> f x e = f y e) -> MapsTo x b (mapi f m) <-> (exists a : elt, b = f x a /\ MapsTo x a m))
----
elt : Type, elt' : Type, elt'' : Type, m : (t elt), x : key, b : elt' |- (forall f : key -> elt -> elt', (forall (x y : key) (e : elt), E.eq x y -> f x e = f y e) -> MapsTo x b (mapi f m) <-> (exists a : elt, b = f x a /\ MapsTo x a m)) OUTPUT
intros ?
intros
split
unfold MapsTo
unfold g
intros until b
induction m
unfold f
exact (Raw.Proofs.find_2 (m:=x) (m:=x) (x:=x))
exact (Raw.Proofs.find_1 (m:=x) (m:=x) (x:=x))
Prediction takes 0.303027868270874 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "unfold MapsTo",
      confidence = 0.5 ),
    (tacticText = "unfold g", confidence = 0.5),
    ( tacticText = "intros until b",
      confidence = 0.5 ),
    ( tacticText = "induction m",
      confidence = 0.5 ),
    (tacticText = "unfold f", confidence = 0.5),
    ( tacticText = "exact (Raw.Proofs.find_2 (m:=x) (m:=x) (x:=x))",
      confidence = 0.5 ),
    ( tacticText = "exact (Raw.Proofs.find_1 (m:=x) (m:=x) (x:=x))",
      confidence = 0.5 ) ] )
STATE
elt : Type, elt' : Type, elt'' : Type, m : (t elt), x : key, b : elt', f : (key -> elt -> elt') |- ((forall (x y : key) (e : elt), E.eq x y -> f x e = f y e) -> MapsTo x b (mapi f m) <-> (exists a : elt, b = f x a /\ MapsTo x a m))
----
elt : Type, elt' : Type, elt'' : Type, m : (t elt), x : key, b : elt', f : (key -> elt -> elt') |- ((forall (x y : key) (e : elt), E.eq x y -> f x e = f y e) -> MapsTo x b (mapi f m) <-> (exists a : elt, b = f x a /\ MapsTo x a m)) OUTPUT
intros ?
intros
split
unfold MapsTo
unfold f
unfold g
induction m
exact (Raw.Proofs.find_2 (m:=x) (m:=x) (x:=x))
exact (Raw.Proofs.find_2 (x:=x) (y:=x) (e:=x) (e:=x))
exact (Raw.Proofs.find_2 (m:=x) (x:=x) (x:=y) (e:=x))
Prediction takes 0.39508771896362305 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "unfold MapsTo",
      confidence = 0.5 ),
    (tacticText = "unfold f", confidence = 0.5),
    (tacticText = "unfold g", confidence = 0.5),
    ( tacticText = "induction m",
      confidence = 0.5 ),
    ( tacticText = "exact (Raw.Proofs.find_2 (m:=x) (m:=x) (x:=x))",
      confidence = 0.5 ),
    ( tacticText = "exact (Raw.Proofs.find_2 (x:=x) (y:=x) (e:=x) (e:=x))",
      confidence = 0.5 ),
    ( tacticText = "exact (Raw.Proofs.find_2 (m:=x) (x:=x) (x:=y) (e:=x))",
      confidence = 0.5 ) ] )
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "induction acc",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "induction l",
      confidence = 0.5 ),
    ( tacticText = "inversion 1",
      confidence = 0.5 ),
    ( tacticText = "unfold elements",
      confidence = 0.5 ),
    ( tacticText = "induction i",
      confidence = 0.5 ),
    ( tacticText = "intros until acc",
      confidence = 0.5 ) ] )
STATE
elt : Type, cmp : (elt -> elt -> bool) |- (forall e2 : enumeration elt, IfEq (equal_end e2) nil (flatten_e e2))
----
elt : Type, cmp : (elt -> elt -> bool) |- (forall e2 : enumeration elt, IfEq (equal_end e2) nil (flatten_e e2)) OUTPUT
intros
simpl
auto
intros ?
induction e2
unfold IfEq
unfold elements
red
unfold Equivb
induction e1
Prediction takes 0.053637027740478516 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "induction e2",
      confidence = 0.5 ),
    ( tacticText = "unfold IfEq",
      confidence = 0.5 ),
    ( tacticText = "unfold elements",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold Equivb",
      confidence = 0.5 ),
    ( tacticText = "induction e1",
      confidence = 0.5 ) ] )
STATE
elt : Type, cmp : (elt -> elt -> bool), e2 : (enumeration elt) |- (IfEq (equal_end e2) nil (flatten_e e2))
----
elt : Type, cmp : (elt -> elt -> bool), e2 : (enumeration elt) |- (IfEq (equal_end e2) nil (flatten_e e2)) OUTPUT
simpl
auto
unfold equal
constructor
unfold Equivb
red
unfold Equivb in *
intros
apply equal_IfEq
inversion_clear 1
Prediction takes 0.07044458389282227 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold equal",
      confidence = 0.5 ),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    ( tacticText = "unfold Equivb",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold Equivb in *",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "apply equal_IfEq",
      confidence = 0.5 ),
    ( tacticText = "inversion_clear 1",
      confidence = 0.5 ) ] )
STATE
elt : Type, cmp : (elt -> elt -> bool), e2 : (enumeration elt) |- (IfEq (equal_end e2) nil (flatten_e e2))
----
elt : Type, cmp : (elt -> elt -> bool), e2 : (enumeration elt) |- (IfEq (equal_end e2) nil (flatten_e e2)) OUTPUT
simpl
auto
unfold equal
constructor
unfold Equivb
red
unfold Equivb in *
intros
apply equal_IfEq
inversion_clear 1
Prediction takes 0.0976266860961914 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold equal",
      confidence = 0.5 ),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    ( tacticText = "unfold Equivb",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold Equivb in *",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "apply equal_IfEq",
      confidence = 0.5 ),
    ( tacticText = "inversion_clear 1",
      confidence = 0.5 ) ] )
STATE
elt : Type, cmp : (elt -> elt -> bool) |- (forall e2 : enumeration elt, IfEq (equal_end e2) nil (flatten_e e2))
----
elt : Type, cmp : (elt -> elt -> bool) |- (forall e2 : enumeration elt, IfEq (equal_end e2) nil (flatten_e e2)) OUTPUT
intros
simpl
auto
intros ?
induction e2
unfold IfEq
unfold elements
red
unfold Equivb
induction e1
Prediction takes 0.08208203315734863 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "induction e2",
      confidence = 0.5 ),
    ( tacticText = "unfold IfEq",
      confidence = 0.5 ),
    ( tacticText = "unfold elements",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold Equivb",
      confidence = 0.5 ),
    ( tacticText = "induction e1",
      confidence = 0.5 ) ] )
STATE
elt : Type, cmp : (elt -> elt -> bool), e2 : (enumeration elt) |- (IfEq (equal_end e2) nil (flatten_e e2))
----
elt : Type, cmp : (elt -> elt -> bool), e2 : (enumeration elt) |- (IfEq (equal_end e2) nil (flatten_e e2)) OUTPUT
simpl
auto
unfold equal
constructor
unfold Equivb
red
unfold Equivb in *
intros
apply equal_IfEq
inversion_clear 1
Prediction takes 0.06395339965820312 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold equal",
      confidence = 0.5 ),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    ( tacticText = "unfold Equivb",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold Equivb in *",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "apply equal_IfEq",
      confidence = 0.5 ),
    ( tacticText = "inversion_clear 1",
      confidence = 0.5 ) ] )
STATE
elt : Type, cmp : (elt -> elt -> bool), e2 : (enumeration elt) |- (IfEq (equal_end e2) nil (flatten_e e2))
----
elt : Type, cmp : (elt -> elt -> bool), e2 : (enumeration elt) |- (IfEq (equal_end e2) nil (flatten_e e2)) OUTPUT
simpl
auto
unfold equal
constructor
unfold Equivb
red
unfold Equivb in *
intros
apply equal_IfEq
inversion_clear 1
Prediction takes 0.06546187400817871 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold equal",
      confidence = 0.5 ),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    ( tacticText = "unfold Equivb",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold Equivb in *",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "apply equal_IfEq",
      confidence = 0.5 ),
    ( tacticText = "inversion_clear 1",
      confidence = 0.5 ) ] )
STATE
elt : Type, cmp : (elt -> elt -> bool) |- (IfEq (equal_end (End elt)) nil (flatten_e (End elt)))
----
elt : Type, cmp : (elt -> elt -> bool) |- (IfEq (equal_end (End elt)) nil (flatten_e (End elt))) OUTPUT
simpl
intros
auto
constructor
unfold Equivb
intros ?
unfold equal
red
unfold Equivb in *
apply equal_IfEq
Prediction takes 0.06944108009338379 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    ( tacticText = "unfold Equivb",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold equal",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold Equivb in *",
      confidence = 0.5 ),
    ( tacticText = "apply equal_IfEq",
      confidence = 0.5 ) ] )
STATE
elt : Type, cmp : (elt -> elt -> bool) |- (forall e2 : enumeration elt, IfEq (equal_end e2) nil (flatten_e e2))
----
elt : Type, cmp : (elt -> elt -> bool) |- (forall e2 : enumeration elt, IfEq (equal_end e2) nil (flatten_e e2)) OUTPUT
intros
simpl
auto
intros ?
induction e2
unfold IfEq
unfold elements
red
unfold Equivb
induction e1
Prediction takes 0.058919668197631836 seconds
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
s : t, s' : t, x : elt, y : elt |- (E.eq x y -> In x s -> In y s)
----
s : t, s' : t, x : elt, y : elt |- (E.eq x y -> In x s -> In y s) OUTPUT
intros
intros ?
intuition
auto
auto with set
rewrite E
auto with relations
rewrite E.eq_iff
apply In_1
rewrite E.eq_alt
Prediction takes 3.117640733718872 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    (tacticText = "rewrite E", confidence = 0.5),
    ( tacticText = "auto with relations",
      confidence = 0.5 ),
    ( tacticText = "rewrite E.eq_iff",
      confidence = 0.5 ),
    ( tacticText = "apply In_1",
      confidence = 0.5 ),
    ( tacticText = "rewrite E.eq_alt",
      confidence = 0.5 ) ] )
STATE
s : t, s' : t, x : elt, y : elt, H : (E.eq x y), H0 : (In x s) |- (In y s)
----
s : t, s' : t, x : elt, y : elt, H : (E.eq x y), H0 : (In x s) |- (In y s) OUTPUT
auto
auto with set
auto with relations
elim H0
auto with fset
elim H
rewrite H0
inv
apply (In_1 H)
auto with fsetdec
Prediction takes 0.1560831069946289 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    ( tacticText = "auto with relations",
      confidence = 0.5 ),
    (tacticText = "elim H0", confidence = 0.5),
    ( tacticText = "auto with fset",
      confidence = 0.5 ),
    (tacticText = "elim H", confidence = 0.5),
    ( tacticText = "rewrite H0",
      confidence = 0.5 ),
    (tacticText = "inv", confidence = 0.5),
    ( tacticText = "apply (In_1 H)",
      confidence = 0.5 ),
    ( tacticText = "auto with fsetdec",
      confidence = 0.5 ) ] )
STATE
s : t, s' : t, x : elt, y : elt, H : (E.eq x y) |- (In x s -> In y s)
----
s : t, s' : t, x : elt, y : elt, H : (E.eq x y) |- (In x s -> In y s) OUTPUT
auto
rewrite H
intros
intros ?
auto with set
intuition
apply In_1
auto with relations
rewrite <- H
apply In_iff
Prediction takes 0.07016730308532715 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "rewrite H", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    (tacticText = "intuition", confidence = 0.5),
    ( tacticText = "apply In_1",
      confidence = 0.5 ),
    ( tacticText = "auto with relations",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "apply In_iff",
      confidence = 0.5 ) ] )
STATE
s : t, s' : t, x : elt, y : elt, H : (E.eq x y) |- (In y s -> In y s)
----
s : t, s' : t, x : elt, y : elt, H : (E.eq x y) |- (In y s -> In y s) OUTPUT
auto
rewrite H
intros
intros ?
intuition
auto with set
apply In_1
auto with relations
rewrite <- H
apply In_spec
Prediction takes 0.0752723217010498 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "rewrite H", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    ( tacticText = "apply In_1",
      confidence = 0.5 ),
    ( tacticText = "auto with relations",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "apply In_spec",
      confidence = 0.5 ) ] )
STATE
s : t, s' : t, x : elt, y : elt, H : (E.eq x y), H0 : (In x s) |- (In y s)
----
s : t, s' : t, x : elt, y : elt, H : (E.eq x y), H0 : (In x s) |- (In y s) OUTPUT
auto
auto with set
auto with relations
elim H0
auto with fset
elim H
rewrite H0
inv
apply (In_1 H)
auto with fsetdec
Prediction takes 0.10159730911254883 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    ( tacticText = "auto with relations",
      confidence = 0.5 ),
    (tacticText = "elim H0", confidence = 0.5),
    ( tacticText = "auto with fset",
      confidence = 0.5 ),
    (tacticText = "elim H", confidence = 0.5),
    ( tacticText = "rewrite H0",
      confidence = 0.5 ),
    (tacticText = "inv", confidence = 0.5),
    ( tacticText = "apply (In_1 H)",
      confidence = 0.5 ),
    ( tacticText = "auto with fsetdec",
      confidence = 0.5 ) ] )
STATE
 |- (Proper (E.eq ==> Subset ==> Subset) remove)
----
 |- (Proper (E.eq ==> Subset ==> Subset) remove) OUTPUT
intros ?
red
auto with *
unfold Subset
unfold Equal
unfold Add
auto with set
simpl
intros
unfold add)
Prediction takes 0.06424140930175781 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    ( tacticText = "unfold Subset",
      confidence = 0.5 ),
    ( tacticText = "unfold Equal",
      confidence = 0.5 ),
    ( tacticText = "unfold Add",
      confidence = 0.5 ),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold add)",
      confidence = 0.5 ) ] )
STATE
x : E.t |- (forall y : E.t, E.eq x y -> (Subset ==> Subset)%signature (remove x) (remove y))
----
x : E.t |- (forall y : E.t, E.eq x y -> (Subset ==> Subset)%signature (remove x) (remove y)) OUTPUT
intros ?
red
unfold remove
intros
unfold add
auto with *
unfold Subset
unfold singleton
unfold union
red in *
Prediction takes 0.06253409385681152 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold remove",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold add",
      confidence = 0.5 ),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    ( tacticText = "unfold Subset",
      confidence = 0.5 ),
    ( tacticText = "unfold singleton",
      confidence = 0.5 ),
    ( tacticText = "unfold union",
      confidence = 0.5 ),
    (tacticText = "red in *", confidence = 0.5) ] )
STATE
x : E.t, y : E.t |- (E.eq x y -> (Subset ==> Subset)%signature (remove x) (remove y))
----
x : E.t, y : E.t |- (E.eq x y -> (Subset ==> Subset)%signature (remove x) (remove y)) OUTPUT
intros ?
red
unfold remove
intros
unfold add
unfold singleton
unfold Subset
unfold diff
simpl
unfold remove x
Prediction takes 0.06009721755981445 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold remove",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold add",
      confidence = 0.5 ),
    ( tacticText = "unfold singleton",
      confidence = 0.5 ),
    ( tacticText = "unfold Subset",
      confidence = 0.5 ),
    ( tacticText = "unfold diff",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold remove x",
      confidence = 0.5 ) ] )
STATE
x : E.t, y : E.t, H : (E.eq x y) |- ((Subset ==> Subset)%signature (remove x) (remove y))
----
x : E.t, y : E.t, H : (E.eq x y) |- ((Subset ==> Subset)%signature (remove x) (remove y)) OUTPUT
intros ?
red
unfold remove
apply remove_equal
red in H
auto with *
apply remove_1
apply remove_2
apply remove_remove_2
apply remove_1 with x
Prediction takes 0.08700299263000488 seconds
Model Loaded
0
STATE
 |- (forall (s : t) (f : elt -> bool), compat_bool E.eq f -> For_all (fun x : elt => f x = true) s -> for_all f s = true)
----
 |- (forall (s : t) (f : elt -> bool), compat_bool E.eq f -> For_all (fun x : elt => f x = true) s -> for_all f s = true) OUTPUT
intros
intros ?
induction s
unfold For_all
unfold
auto
unfold is_empty
unfold For_inv
unfold filter
unfold fset
Prediction takes 3.2821171283721924 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "induction s",
      confidence = 0.5 ),
    ( tacticText = "unfold For_all",
      confidence = 0.5 ),
    (tacticText = "unfold", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold is_empty",
      confidence = 0.5 ),
    ( tacticText = "unfold For_inv",
      confidence = 0.5 ),
    ( tacticText = "unfold filter",
      confidence = 0.5 ),
    ( tacticText = "unfold fset",
      confidence = 0.5 ) ] )
STATE
s : t, f : (elt -> bool), H : (compat_bool E.eq f), H0 : (For_all (fun x : elt => f x = true) s) |- (for_all f s = true)
----
s : t, f : (elt -> bool), H : (compat_bool E.eq f), H0 : (For_all (fun x : elt => f x = true) s) |- (for_all f s = true) OUTPUT
auto
apply for_all_2
apply for_all_1
rewrite for_all_iff
rewrite for_all_all_iff
rewrite for_all_spec
apply for_all_all_2
rewrite for_all_all_2
rewrite for_all_all_spec
apply for_all_2 with f
Prediction takes 0.13815951347351074 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "apply for_all_2",
      confidence = 0.5 ),
    ( tacticText = "apply for_all_1",
      confidence = 0.5 ),
    ( tacticText = "rewrite for_all_iff",
      confidence = 0.5 ),
    ( tacticText = "rewrite for_all_all_iff",
      confidence = 0.5 ),
    ( tacticText = "rewrite for_all_spec",
      confidence = 0.5 ),
    ( tacticText = "apply for_all_all_2",
      confidence = 0.5 ),
    ( tacticText = "rewrite for_all_all_2",
      confidence = 0.5 ),
    ( tacticText = "rewrite for_all_all_spec",
      confidence = 0.5 ),
    ( tacticText = "apply for_all_2 with f",
      confidence = 0.5 ) ] )
STATE
s : t |- (forall f : elt -> bool, compat_bool E.eq f -> For_all (fun x : elt => f x = true) s -> for_all f s = true)
----
s : t |- (forall f : elt -> bool, compat_bool E.eq f -> For_all (fun x : elt => f x = true) s -> for_all f s = true) OUTPUT
intros ?
intros
unfold For_all
induction s
unfold is_empty
unfold
destruct s
unfold f
unfold is_all
unfold compat
Prediction takes 0.06907796859741211 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold For_all",
      confidence = 0.5 ),
    ( tacticText = "induction s",
      confidence = 0.5 ),
    ( tacticText = "unfold is_empty",
      confidence = 0.5 ),
    (tacticText = "unfold", confidence = 0.5),
    ( tacticText = "destruct s",
      confidence = 0.5 ),
    (tacticText = "unfold f", confidence = 0.5),
    ( tacticText = "unfold is_all",
      confidence = 0.5 ),
    ( tacticText = "unfold compat",
      confidence = 0.5 ) ] )
STATE
s : t, f : (elt -> bool) |- (compat_bool E.eq f -> For_all (fun x : elt => f x = true) s -> for_all f s = true)
----
s : t, f : (elt -> bool) |- (compat_bool E.eq f -> For_all (fun x : elt => f x = true) s -> for_all f s = true) OUTPUT
intros ?
intros
unfold For_all
induction s
unfold
destruct s
unfold for_all
destruct (f a)
destruct (f x)
destruct (f s)
Prediction takes 0.08395791053771973 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold For_all",
      confidence = 0.5 ),
    ( tacticText = "induction s",
      confidence = 0.5 ),
    (tacticText = "unfold", confidence = 0.5),
    ( tacticText = "destruct s",
      confidence = 0.5 ),
    ( tacticText = "unfold for_all",
      confidence = 0.5 ),
    ( tacticText = "destruct (f a)",
      confidence = 0.5 ),
    ( tacticText = "destruct (f x)",
      confidence = 0.5 ),
    ( tacticText = "destruct (f s)",
      confidence = 0.5 ) ] )
STATE
s : t, f : (elt -> bool), H : (compat_bool E.eq f) |- (For_all (fun x : elt => f x = true) s -> for_all f s = true)
----
s : t, f : (elt -> bool), H : (compat_bool E.eq f) |- (For_all (fun x : elt => f x = true) s -> for_all f s = true) OUTPUT
intros
apply for_all_2
auto
intros ?
unfold For_all
unfold
rewrite for_all_spec
unfold for_all
apply for_all_1
rewrite for_all_iff
Prediction takes 0.09538054466247559 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "apply for_all_2",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold For_all",
      confidence = 0.5 ),
    (tacticText = "unfold", confidence = 0.5),
    ( tacticText = "rewrite for_all_spec",
      confidence = 0.5 ),
    ( tacticText = "unfold for_all",
      confidence = 0.5 ),
    ( tacticText = "apply for_all_1",
      confidence = 0.5 ),
    ( tacticText = "rewrite for_all_iff",
      confidence = 0.5 ) ] )
STATE
s : t, f : (elt -> bool), H : (compat_bool E.eq f), H0 : (For_all (fun x : elt => f x = true) s) |- (for_all f s = true)
----
s : t, f : (elt -> bool), H : (compat_bool E.eq f), H0 : (For_all (fun x : elt => f x = true) s) |- (for_all f s = true) OUTPUT
auto
apply for_all_2
apply for_all_1
rewrite for_all_iff
rewrite for_all_all_iff
rewrite for_all_spec
apply for_all_all_2
rewrite for_all_all_2
rewrite for_all_all_spec
apply for_all_2 with f
Prediction takes 0.14477300643920898 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "apply for_all_2",
      confidence = 0.5 ),
    ( tacticText = "apply for_all_1",
      confidence = 0.5 ),
    ( tacticText = "rewrite for_all_iff",
      confidence = 0.5 ),
    ( tacticText = "rewrite for_all_all_iff",
      confidence = 0.5 ),
    ( tacticText = "rewrite for_all_spec",
      confidence = 0.5 ),
    ( tacticText = "apply for_all_all_2",
      confidence = 0.5 ),
    ( tacticText = "rewrite for_all_all_2",
      confidence = 0.5 ),
    ( tacticText = "rewrite for_all_all_spec",
      confidence = 0.5 ),
    ( tacticText = "apply for_all_2 with f",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
a : Z, b : Z |- ((a | - b) -> (a | b))
----
a : Z, b : Z |- ((a | - b) -> (a | b)) OUTPUT
intros ?
apply Z.divide_opp_l
apply Z.divide_opp_r
apply divide_opp_l
intros
apply divide_opp_r
rewrite (opp_involutive a)
apply Z.divide_pol_r
apply divide_lcm_l
apply Z.divide_l
Prediction takes 2.87261700630188 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "apply Z.divide_opp_l",
      confidence = 0.5 ),
    ( tacticText = "apply Z.divide_opp_r",
      confidence = 0.5 ),
    ( tacticText = "apply divide_opp_l",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "apply divide_opp_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite (opp_involutive a)",
      confidence = 0.5 ),
    ( tacticText = "apply Z.divide_pol_r",
      confidence = 0.5 ),
    ( tacticText = "apply divide_lcm_l",
      confidence = 0.5 ),
    ( tacticText = "apply Z.divide_l",
      confidence = 0.5 ) ] )
STATE
a : Z, b : Z, H : (a | - b) |- (a | b)
----
a : Z, b : Z, H : (a | - b) |- (a | b) OUTPUT
apply divide_opp_l
apply divide_opp_r
easy
trivial
apply divide_lcm_l
trivial using divide_opp_r
trivial using divide_lcm_r
trivial using divide_lcm_l
apply divide_mul_r
order
Prediction takes 0.138275146484375 seconds
( textPrediction = [
    ( tacticText = "apply divide_opp_l",
      confidence = 0.5 ),
    ( tacticText = "apply divide_opp_r",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "apply divide_lcm_l",
      confidence = 0.5 ),
    ( tacticText = "trivial using divide_opp_r",
      confidence = 0.5 ),
    ( tacticText = "trivial using divide_lcm_r",
      confidence = 0.5 ),
    ( tacticText = "trivial using divide_lcm_l",
      confidence = 0.5 ),
    ( tacticText = "apply divide_mul_r",
      confidence = 0.5 ),
    (tacticText = "order", confidence = 0.5) ] )
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "induction e2",
      confidence = 0.5 ),
    ( tacticText = "unfold IfEq",
      confidence = 0.5 ),
    ( tacticText = "unfold elements",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold Equivb",
      confidence = 0.5 ),
    ( tacticText = "induction e1",
      confidence = 0.5 ) ] )
STATE
elt : Type, cmp : (elt -> elt -> bool), e2 : (enumeration elt) |- (IfEq (equal_end e2) nil (flatten_e e2))
----
elt : Type, cmp : (elt -> elt -> bool), e2 : (enumeration elt) |- (IfEq (equal_end e2) nil (flatten_e e2)) OUTPUT
simpl
auto
unfold equal
constructor
unfold Equivb
red
unfold Equivb in *
intros
apply equal_IfEq
inversion_clear 1
Prediction takes 0.0657052993774414 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold equal",
      confidence = 0.5 ),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    ( tacticText = "unfold Equivb",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold Equivb in *",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "apply equal_IfEq",
      confidence = 0.5 ),
    ( tacticText = "inversion_clear 1",
      confidence = 0.5 ) ] )
STATE
elt : Type, cmp : (elt -> elt -> bool), e2 : (enumeration elt) |- (IfEq (equal_end e2) nil (flatten_e e2))
----
elt : Type, cmp : (elt -> elt -> bool), e2 : (enumeration elt) |- (IfEq (equal_end e2) nil (flatten_e e2)) OUTPUT
simpl
auto
unfold equal
constructor
unfold Equivb
red
unfold Equivb in *
intros
apply equal_IfEq
inversion_clear 1
Prediction takes 0.0721273422241211 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold equal",
      confidence = 0.5 ),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    ( tacticText = "unfold Equivb",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold Equivb in *",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "apply equal_IfEq",
      confidence = 0.5 ),
    ( tacticText = "inversion_clear 1",
      confidence = 0.5 ) ] )
Model Loaded
0
STATE
d : uint |- (of_lu d = 0 <-> nztail d = Nil)
----
d : uint |- (of_lu d = 0 <-> nztail d = Nil) OUTPUT
split
simpl
simpl_of_lu
easy
unfold rev
unfold nztail
unfold nzhead
destruct d
apply of_lu
unfold rev_revapp
Prediction takes 2.900817394256592 seconds
( textPrediction = [
    (tacticText = "split", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "simpl_of_lu",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "unfold rev",
      confidence = 0.5 ),
    ( tacticText = "unfold nztail",
      confidence = 0.5 ),
    ( tacticText = "unfold nzhead",
      confidence = 0.5 ),
    ( tacticText = "destruct d",
      confidence = 0.5 ),
    ( tacticText = "apply of_lu",
      confidence = 0.5 ),
    ( tacticText = "unfold rev_revapp",
      confidence = 0.5 ) ] )
STATE
d : uint |- (of_lu d = 0 -> nztail d = Nil)
----
d : uint |- (of_lu d = 0 -> nztail d = Nil) OUTPUT
intros ?
simpl
trivial
destruct d
easy
auto
simpl_of_lu
intros
destruct (nztail d)
apply of_lu
Prediction takes 0.07877445220947266 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "destruct d",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "simpl_of_lu",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "destruct (nztail d)",
      confidence = 0.5 ),
    ( tacticText = "apply of_lu",
      confidence = 0.5 ) ] )
STATE
d : uint, H : (of_lu d = 0) |- (nztail d = Nil)
----
d : uint, H : (of_lu d = 0) |- (nztail d = Nil) OUTPUT
easy
apply of_lu_revapp
rewrite <- H
trivial
auto
apply IHd
apply to_lu_revapp
rewrite IHd
apply nzhead_revapp
apply to_of_lu
Prediction takes 0.08504748344421387 seconds
( textPrediction = [
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply of_lu_revapp",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "apply IHd", confidence = 0.5),
    ( tacticText = "apply to_lu_revapp",
      confidence = 0.5 ),
    ( tacticText = "rewrite IHd",
      confidence = 0.5 ),
    ( tacticText = "apply nzhead_revapp",
      confidence = 0.5 ),
    ( tacticText = "apply to_of_lu",
      confidence = 0.5 ) ] )
STATE
d : uint |- (of_lu d = 0 <-> nztail d = Nil)
----
d : uint |- (of_lu d = 0 <-> nztail d = Nil) OUTPUT
split
simpl
simpl_of_lu
easy
unfold rev
unfold nztail
unfold nzhead
destruct d
apply of_lu
unfold rev_revapp
Prediction takes 0.1268329620361328 seconds
( textPrediction = [
    (tacticText = "split", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "simpl_of_lu",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "unfold rev",
      confidence = 0.5 ),
    ( tacticText = "unfold nztail",
      confidence = 0.5 ),
    ( tacticText = "unfold nzhead",
      confidence = 0.5 ),
    ( tacticText = "destruct d",
      confidence = 0.5 ),
    ( tacticText = "apply of_lu",
      confidence = 0.5 ),
    ( tacticText = "unfold rev_revapp",
      confidence = 0.5 ) ] )
STATE
d : uint |- (of_lu d = 0 -> nztail d = Nil)
----
d : uint |- (of_lu d = 0 -> nztail d = Nil) OUTPUT
intros ?
simpl
trivial
destruct d
easy
auto
simpl_of_lu
intros
destruct (nztail d)
apply of_lu
Prediction takes 0.0921330451965332 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "destruct d",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "simpl_of_lu",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "destruct (nztail d)",
      confidence = 0.5 ),
    ( tacticText = "apply of_lu",
      confidence = 0.5 ) ] )
STATE
d : uint, H : (of_lu d = 0) |- (nztail d = Nil)
----
d : uint, H : (of_lu d = 0) |- (nztail d = Nil) OUTPUT
easy
apply of_lu_revapp
rewrite <- H
trivial
auto
apply IHd
apply to_lu_revapp
rewrite IHd
apply nzhead_revapp
apply to_of_lu
Prediction takes 0.11243820190429688 seconds
( textPrediction = [
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply of_lu_revapp",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "apply IHd", confidence = 0.5),
    ( tacticText = "apply to_lu_revapp",
      confidence = 0.5 ),
    ( tacticText = "rewrite IHd",
      confidence = 0.5 ),
    ( tacticText = "apply nzhead_revapp",
      confidence = 0.5 ),
    ( tacticText = "apply to_of_lu",
      confidence = 0.5 ) ] )
STATE
 |- (of_lu Nil = 0 -> nztail Nil = Nil)
----
 |- (of_lu Nil = 0 -> nztail Nil = Nil) OUTPUT
trivial
simpl
intros
intros ?
easy
discriminate
auto
destruct 1
congruence
simpl_lu
Prediction takes 0.08295321464538574 seconds
( textPrediction = [
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "discriminate",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "destruct 1",
      confidence = 0.5 ),
    ( tacticText = "congruence",
      confidence = 0.5 ),
    (tacticText = "simpl_lu", confidence = 0.5) ] )
starting proving server with connection through their stdin
using textmode optiontext
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
a : N, b : N |- (Nleb a b = false -> Nleb (N.double a) (N.double b) = false)
----
a : N, b : N |- (Nleb a b = false -> Nleb (N.double a) (N.double b) = false) OUTPUT
intros ?
unfold Nleb
intros
simpl
destruct b
rewrite Nleb_eq
rewrite Nleb_succ
apply Nleb_le
rewrite Nleb_spec
apply Nleb_eq
Prediction takes 2.818295478820801 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold Nleb",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct b",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nleb_eq",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nleb_succ",
      confidence = 0.5 ),
    ( tacticText = "apply Nleb_le",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nleb_spec",
      confidence = 0.5 ),
    ( tacticText = "apply Nleb_eq",
      confidence = 0.5 ) ] )
STATE
a : N, b : N, H : (Nleb a b = false) |- (Nleb (N.double a) (N.double b) = false)
----
a : N, b : N, H : (Nleb a b = false) |- (Nleb (N.double a) (N.double b) = false) OUTPUT
rewrite H
easy
destruct (Nleb_spec a b)
symmetry
rewrite <- H
apply Nleb_le in H
rewrite Nleb_succ
rewrite <- (Nleb_spec a b)
destruct (N.leb_spec a b)
rewrite (Nleb_succ_pred b)
Prediction takes 0.17001676559448242 seconds
( textPrediction = [
    (tacticText = "rewrite H", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "destruct (Nleb_spec a b)",
      confidence = 0.5 ),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "apply Nleb_le in H",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nleb_succ",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- (Nleb_spec a b)",
      confidence = 0.5 ),
    ( tacticText = "destruct (N.leb_spec a b)",
      confidence = 0.5 ),
    ( tacticText = "rewrite (Nleb_succ_pred b)",
      confidence = 0.5 ) ] )
STATE
a : N, b : N |- ((N.to_nat a <=? N.to_nat b)%nat = false -> (N.to_nat (N.double a) <=? N.to_nat (N.double b))%nat = false)
----
a : N, b : N |- ((N.to_nat a <=? N.to_nat b)%nat = false -> (N.to_nat (N.double a) <=? N.to_nat (N.double b))%nat = false) OUTPUT
intros
intros ?
simpl
trivial
intros until a
intros until b
rewrite Nleb_le
unfold Nleb
unfold N.leb
rewrite Nleb_nat
Prediction takes 0.09650993347167969 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "intros until a",
      confidence = 0.5 ),
    ( tacticText = "intros until b",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nleb_le",
      confidence = 0.5 ),
    ( tacticText = "unfold Nleb",
      confidence = 0.5 ),
    ( tacticText = "unfold N.leb",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nleb_nat",
      confidence = 0.5 ) ] )
STATE
a : N, b : N, H : ((N.to_nat a <=? N.to_nat b)%nat = false) |- ((N.to_nat (N.double a) <=? N.to_nat (N.double b))%nat = false)
----
a : N, b : N, H : ((N.to_nat a <=? N.to_nat b)%nat = false) |- ((N.to_nat (N.double a) <=? N.to_nat (N.double b))%nat = false) OUTPUT
rewrite H
simpl
easy
trivial
apply Nat.leb_le
rewrite Nleb_le
rewrite <- H
rewrite N.leb_le
rewrite Nleb_nat
apply N.leb_le
Prediction takes 0.10793066024780273 seconds
( textPrediction = [
    (tacticText = "rewrite H", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "apply Nat.leb_le",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nleb_le",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "rewrite N.leb_le",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nleb_nat",
      confidence = 0.5 ),
    ( tacticText = "apply N.leb_le",
      confidence = 0.5 ) ] )
STATE
a : N, b : N, H : ((N.to_nat a <=? N.to_nat b)%nat = false) |- ((N.to_nat (N.double a) <=? N.to_nat (N.double b))%nat = false)
----
a : N, b : N, H : ((N.to_nat a <=? N.to_nat b)%nat = false) |- ((N.to_nat (N.double a) <=? N.to_nat (N.double b))%nat = false) OUTPUT
rewrite H
simpl
easy
trivial
apply Nat.leb_le
rewrite Nleb_le
rewrite <- H
rewrite N.leb_le
rewrite Nleb_nat
apply N.leb_le
Prediction takes 0.10112190246582031 seconds
( textPrediction = [
    (tacticText = "rewrite H", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "apply Nat.leb_le",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nleb_le",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "rewrite N.leb_le",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nleb_nat",
      confidence = 0.5 ),
    ( tacticText = "apply N.leb_le",
      confidence = 0.5 ) ] )
STATE
a : N, b : N, H : (Nleb a b = false) |- (Nleb (N.double a) (N.double b) = false)
----
a : N, b : N, H : (Nleb a b = false) |- (Nleb (N.double a) (N.double b) = false) OUTPUT
rewrite H
easy
destruct (Nleb_spec a b)
symmetry
rewrite <- H
apply Nleb_le in H
rewrite Nleb_succ
rewrite <- (Nleb_spec a b)
destruct (N.leb_spec a b)
rewrite (Nleb_succ_pred b)
Prediction takes 0.14363980293273926 seconds
( textPrediction = [
    (tacticText = "rewrite H", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "destruct (Nleb_spec a b)",
      confidence = 0.5 ),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "apply Nleb_le in H",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nleb_succ",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- (Nleb_spec a b)",
      confidence = 0.5 ),
    ( tacticText = "destruct (N.leb_spec a b)",
      confidence = 0.5 ),
    ( tacticText = "rewrite (Nleb_succ_pred b)",
      confidence = 0.5 ) ] )
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold remove",
      confidence = 0.5 ),
    ( tacticText = "apply remove_equal",
      confidence = 0.5 ),
    (tacticText = "red in H", confidence = 0.5),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    ( tacticText = "apply remove_1",
      confidence = 0.5 ),
    ( tacticText = "apply remove_2",
      confidence = 0.5 ),
    ( tacticText = "apply remove_remove_2",
      confidence = 0.5 ),
    ( tacticText = "apply remove_1 with x",
      confidence = 0.5 ) ] )
STATE
x : E.t, y : E.t, H : (E.eq x y), x0 : t |- (forall y0 : t, x0 [<=] y0 -> remove x x0 [<=] remove y y0)
----
x : E.t, y : E.t, H : (E.eq x y), x0 : t |- (forall y0 : t, x0 [<=] y0 -> remove x x0 [<=] remove y y0) OUTPUT
intros ?
intros
unfold remove
auto with set
red
unfold add
auto with *
simpl
unfold Subset
unfold singleton
Prediction takes 0.056258440017700195 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold remove",
      confidence = 0.5 ),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold add",
      confidence = 0.5 ),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold Subset",
      confidence = 0.5 ),
    ( tacticText = "unfold singleton",
      confidence = 0.5 ) ] )
STATE
x : E.t, y : E.t, H : (E.eq x y), x0 : t, y0 : t |- (x0 [<=] y0 -> remove x x0 [<=] remove y y0)
----
x : E.t, y : E.t, H : (E.eq x y), x0 : t, y0 : t |- (x0 [<=] y0 -> remove x x0 [<=] remove y y0) OUTPUT
intros ?
intros
unfold remove
auto with set
rewrite remove_min_iff
rewrite same_b
rewrite singleton_iff
rewrite singleton_spec
apply remove_equal
rewrite remove_neq
Prediction takes 0.08935046195983887 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold remove",
      confidence = 0.5 ),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    ( tacticText = "rewrite remove_min_iff",
      confidence = 0.5 ),
    ( tacticText = "rewrite same_b",
      confidence = 0.5 ),
    ( tacticText = "rewrite singleton_iff",
      confidence = 0.5 ),
    ( tacticText = "rewrite singleton_spec",
      confidence = 0.5 ),
    ( tacticText = "apply remove_equal",
      confidence = 0.5 ),
    ( tacticText = "rewrite remove_neq",
      confidence = 0.5 ) ] )
STATE
x : E.t, y : E.t, H : (E.eq x y), x0 : t, y0 : t, H0 : (x0 [<=] y0) |- (remove x x0 [<=] remove y y0)
----
x : E.t, y : E.t, H : (E.eq x y), x0 : t, y0 : t, H0 : (x0 [<=] y0) |- (remove x x0 [<=] remove y y0) OUTPUT
auto
unfold remove
auto with set
apply remove_equal
rewrite H0
rewrite same_b
rewrite remove_neq
apply remove_neq
rewrite remove_min_iff
apply MP.remove_1
Prediction takes 0.10253739356994629 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold remove",
      confidence = 0.5 ),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    ( tacticText = "apply remove_equal",
      confidence = 0.5 ),
    ( tacticText = "rewrite H0",
      confidence = 0.5 ),
    ( tacticText = "rewrite same_b",
      confidence = 0.5 ),
    ( tacticText = "rewrite remove_neq",
      confidence = 0.5 ),
    ( tacticText = "apply remove_neq",
      confidence = 0.5 ),
    ( tacticText = "rewrite remove_min_iff",
      confidence = 0.5 ),
    ( tacticText = "apply MP.remove_1",
      confidence = 0.5 ) ] )
STATE
x : E.t, y : E.t, H : (E.eq x y), x0 : t, y0 : t, H0 : (x0 [<=] y0) |- (remove x x0 [<=] remove y y0)
----
x : E.t, y : E.t, H : (E.eq x y), x0 : t, y0 : t, H0 : (x0 [<=] y0) |- (remove x x0 [<=] remove y y0) OUTPUT
auto
unfold remove
auto with set
apply remove_equal
rewrite H0
rewrite same_b
rewrite remove_neq
apply remove_neq
rewrite remove_min_iff
apply MP.remove_1
Prediction takes 0.0898122787475586 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold remove",
      confidence = 0.5 ),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    ( tacticText = "apply remove_equal",
      confidence = 0.5 ),
    ( tacticText = "rewrite H0",
      confidence = 0.5 ),
    ( tacticText = "rewrite same_b",
      confidence = 0.5 ),
    ( tacticText = "rewrite remove_neq",
      confidence = 0.5 ),
    ( tacticText = "apply remove_neq",
      confidence = 0.5 ),
    ( tacticText = "rewrite remove_min_iff",
      confidence = 0.5 ),
    ( tacticText = "apply MP.remove_1",
      confidence = 0.5 ) ] )
STATE
x : E.t, y : E.t, H : (E.eq x y), x0 : t, y0 : t, H0 : (x0 [<=] y0) |- (remove x x0 [<=] remove y y0)
----
x : E.t, y : E.t, H : (E.eq x y), x0 : t, y0 : t, H0 : (x0 [<=] y0) |- (remove x x0 [<=] remove y y0) OUTPUT
auto
unfold remove
auto with set
apply remove_equal
rewrite H0
rewrite same_b
rewrite remove_neq
apply remove_neq
rewrite remove_min_iff
apply MP.remove_1
Prediction takes 0.08699774742126465 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold remove",
      confidence = 0.5 ),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    ( tacticText = "apply remove_equal",
      confidence = 0.5 ),
    ( tacticText = "rewrite H0",
      confidence = 0.5 ),
    ( tacticText = "rewrite same_b",
      confidence = 0.5 ),
    ( tacticText = "rewrite remove_neq",
      confidence = 0.5 ),
    ( tacticText = "apply remove_neq",
      confidence = 0.5 ),
    ( tacticText = "rewrite remove_min_iff",
      confidence = 0.5 ),
    ( tacticText = "apply MP.remove_1",
      confidence = 0.5 ) ] )
STATE
x : E.t, y : E.t, H : (E.eq x y) |- (forall x0 y0 : t, x0 [<=] y0 -> remove x x0 [<=] remove y y0)
----
x : E.t, y : E.t, H : (E.eq x y) |- (forall x0 y0 : t, x0 [<=] y0 -> remove x x0 [<=] remove y y0) OUTPUT
intros ?
intros
auto with set
unfold remove
auto with *
red
unfold add
unfold singleton
simpl
auto
Prediction takes 0.05944037437438965 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    ( tacticText = "unfold remove",
      confidence = 0.5 ),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold add",
      confidence = 0.5 ),
    ( tacticText = "unfold singleton",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5) ] )
STATE
x : E.t, y : E.t, H : (E.eq x y), x0 : t |- (forall y0 : t, x0 [<=] y0 -> remove x x0 [<=] remove y y0)
----
x : E.t, y : E.t, H : (E.eq x y), x0 : t |- (forall y0 : t, x0 [<=] y0 -> remove x x0 [<=] remove y y0) OUTPUT
intros ?
intros
unfold remove
auto with set
red
unfold add
auto with *
simpl
unfold Subset
unfold singleton
Prediction takes 0.06976771354675293 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold remove",
      confidence = 0.5 ),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold add",
      confidence = 0.5 ),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold Subset",
      confidence = 0.5 ),
    ( tacticText = "unfold singleton",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
starting proving server with connection through their stdin
using textmode optiontext
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
 |- (forall (a : N) (n m : nat), (n <= m)%nat -> N.testbit_nat (N.shiftl_nat a n) m = N.testbit_nat a (m - n))
----
 |- (forall (a : N) (n m : nat), (n <= m)%nat -> N.testbit_nat (N.shiftl_nat a n) m = N.testbit_nat a (m - n)) OUTPUT
intros
intros ?
intros until n
induction n
intros until a
intros until m
trivial
simpl
auto
intros until b
Prediction takes 3.354081869125366 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "intros until n",
      confidence = 0.5 ),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    ( tacticText = "intros until a",
      confidence = 0.5 ),
    ( tacticText = "intros until m",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "intros until b",
      confidence = 0.5 ) ] )
STATE
a : N, n : nat, m : nat, H : (n <= m)%nat |- (N.testbit_nat (N.shiftl_nat a n) m = N.testbit_nat a (m - n))
----
a : N, n : nat, m : nat, H : (n <= m)%nat |- (N.testbit_nat (N.shiftl_nat a n) m = N.testbit_nat a (m - n)) OUTPUT
rewrite H
rewrite shiftl_spec_high'
simpl
trivial
rewrite shiftl_spec_high
rewrite shiftl_spec_low
rewrite N.shiftl_nat_nat
destruct (N.shiftl_nat a n)
destruct (N.testbit_nat a m)
rewrite (N.shiftl_nat a n)
Prediction takes 0.15041327476501465 seconds
( textPrediction = [
    (tacticText = "rewrite H", confidence = 0.5),
    ( tacticText = "rewrite shiftl_spec_high\'",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "rewrite shiftl_spec_high",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec_low",
      confidence = 0.5 ),
    ( tacticText = "rewrite N.shiftl_nat_nat",
      confidence = 0.5 ),
    ( tacticText = "destruct (N.shiftl_nat a n)",
      confidence = 0.5 ),
    ( tacticText = "destruct (N.testbit_nat a m)",
      confidence = 0.5 ),
    ( tacticText = "rewrite (N.shiftl_nat a n)",
      confidence = 0.5 ) ] )
STATE
a : N |- (forall n m : nat, (n <= m)%nat -> N.testbit_nat (N.shiftl_nat a n) m = N.testbit_nat a (m - n))
----
a : N |- (forall n m : nat, (n <= m)%nat -> N.testbit_nat (N.shiftl_nat a n) m = N.testbit_nat a (m - n)) OUTPUT
intros ?
intros
intros until n
induction n
intros until a
intros until m
simpl
intros until b
destruct a
unfold N.testbit
Prediction takes 0.07976388931274414 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "intros until n",
      confidence = 0.5 ),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    ( tacticText = "intros until a",
      confidence = 0.5 ),
    ( tacticText = "intros until m",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "intros until b",
      confidence = 0.5 ),
    ( tacticText = "destruct a",
      confidence = 0.5 ),
    ( tacticText = "unfold N.testbit",
      confidence = 0.5 ) ] )
STATE
a : N, n : nat |- (forall m : nat, (n <= m)%nat -> N.testbit_nat (N.shiftl_nat a n) m = N.testbit_nat a (m - n))
----
a : N, n : nat |- (forall m : nat, (n <= m)%nat -> N.testbit_nat (N.shiftl_nat a n) m = N.testbit_nat a (m - n)) OUTPUT
intros ?
intros
induction n
intros until n
intros until m
simpl
intros until a
trivial
destruct a
case n
Prediction takes 0.06927943229675293 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    ( tacticText = "intros until n",
      confidence = 0.5 ),
    ( tacticText = "intros until m",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "intros until a",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "destruct a",
      confidence = 0.5 ),
    (tacticText = "case n", confidence = 0.5) ] )
STATE
a : N, n : nat, m : nat |- ((n <= m)%nat -> N.testbit_nat (N.shiftl_nat a n) m = N.testbit_nat a (m - n))
----
a : N, n : nat, m : nat |- ((n <= m)%nat -> N.testbit_nat (N.shiftl_nat a n) m = N.testbit_nat a (m - n)) OUTPUT
intros ?
intros
unfold N.testbit_nat
induction n
simpl
rewrite shiftl_spec_high'
rewrite shiftl_spec_high
trivial
unfold N.testbit
rewrite shiftl_spec_low
Prediction takes 0.15262079238891602 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold N.testbit_nat",
      confidence = 0.5 ),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "rewrite shiftl_spec_high\'",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec_high",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "unfold N.testbit",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec_low",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
R : Type, rO : R, rI : R, rplus : (R -> R -> R), rtimes : (R -> R -> R), rminus : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), rle : (R -> R -> Prop), rlt : (R -> R -> Prop), sor : (SOR 0 1 rplus rtimes rminus ropp req rle rlt) |- (forall n m : R, n <= m <-> 0 <= m - n)
----
R : Type, rO : R, rI : R, rplus : (R -> R -> R), rtimes : (R -> R -> R), rminus : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), rle : (R -> R -> Prop), rlt : (R -> R -> Prop), sor : (SOR 0 1 rplus rtimes rminus ropp req rle rlt) |- (forall n m : R, n <= m <-> 0 <= m - n) OUTPUT
intros ?
intros
induct ltac:(n)
ring
unfold Rminus
apply Rplus_le_mono_l
apply Rlt_le_trans with 0
apply Rlt_neq
exact (Rlt_neq sor)
setoid_replace n with 0
Prediction takes 2.9577982425689697 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induct ltac:(n)",
      confidence = 0.5 ),
    (tacticText = "ring", confidence = 0.5),
    ( tacticText = "unfold Rminus",
      confidence = 0.5 ),
    ( tacticText = "apply Rplus_le_mono_l",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_le_trans with 0",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_neq",
      confidence = 0.5 ),
    ( tacticText = "exact (Rlt_neq sor)",
      confidence = 0.5 ),
    ( tacticText = "setoid_replace n with 0",
      confidence = 0.5 ) ] )
STATE
R : Type, rO : R, rI : R, rplus : (R -> R -> R), rtimes : (R -> R -> R), rminus : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), rle : (R -> R -> Prop), rlt : (R -> R -> Prop), sor : (SOR 0 1 rplus rtimes rminus ropp req rle rlt), n : R |- (forall m : R, n <= m <-> 0 <= m - n)
----
R : Type, rO : R, rI : R, rplus : (R -> R -> R), rtimes : (R -> R -> R), rminus : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), rle : (R -> R -> Prop), rlt : (R -> R -> Prop), sor : (SOR 0 1 rplus rtimes rminus ropp req rle rlt), n : R |- (forall m : R, n <= m <-> 0 <= m - n) OUTPUT
intros ?
intros
induct ltac:(n)
induct
split
unfold Rminus
induct ltac:(m)
apply Rlt_neq
rewrite <- Rplus_opp_r
apply Rlt_0_1
Prediction takes 0.2206435203552246 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induct ltac:(n)",
      confidence = 0.5 ),
    (tacticText = "induct", confidence = 0.5),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "unfold Rminus",
      confidence = 0.5 ),
    ( tacticText = "induct ltac:(m)",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_neq",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- Rplus_opp_r",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_0_1",
      confidence = 0.5 ) ] )
STATE
R : Type, rO : R, rI : R, rplus : (R -> R -> R), rtimes : (R -> R -> R), rminus : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), rle : (R -> R -> Prop), rlt : (R -> R -> Prop), sor : (SOR 0 1 rplus rtimes rminus ropp req rle rlt), n : R, m : R |- (n <= m <-> 0 <= m - n)
----
R : Type, rO : R, rI : R, rplus : (R -> R -> R), rtimes : (R -> R -> R), rminus : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), rle : (R -> R -> Prop), rlt : (R -> R -> Prop), sor : (SOR 0 1 rplus rtimes rminus ropp req rle rlt), n : R, m : R |- (n <= m <-> 0 <= m - n) OUTPUT
rewrite Rplus_opp_r
rewrite Rplus_0_l
rewrite <- Rplus_opp_r
rewrite Rplus_le_mono_l
rewrite Rplus_opp_l
rewrite Rplus_le_mono_r
rewrite Rplus_0_r
apply Rplus_le_mono_l
apply Rplus_le_mono_nonneg
apply Rlt_le_trans with 0
Prediction takes 0.13006091117858887 seconds
( textPrediction = [
    ( tacticText = "rewrite Rplus_opp_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_0_l",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- Rplus_opp_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_le_mono_l",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_opp_l",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_le_mono_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_0_r",
      confidence = 0.5 ),
    ( tacticText = "apply Rplus_le_mono_l",
      confidence = 0.5 ),
    ( tacticText = "apply Rplus_le_mono_nonneg",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_le_trans with 0",
      confidence = 0.5 ) ] )
STATE
R : Type, rO : R, rI : R, rplus : (R -> R -> R), rtimes : (R -> R -> R), rminus : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), rle : (R -> R -> Prop), rlt : (R -> R -> Prop), sor : (SOR 0 1 rplus rtimes rminus ropp req rle rlt), n : R, m : R |- (n <= m <-> 0 <= m - n)
----
R : Type, rO : R, rI : R, rplus : (R -> R -> R), rtimes : (R -> R -> R), rminus : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), rle : (R -> R -> Prop), rlt : (R -> R -> Prop), sor : (SOR 0 1 rplus rtimes rminus ropp req rle rlt), n : R, m : R |- (n <= m <-> 0 <= m - n) OUTPUT
rewrite Rplus_opp_r
rewrite Rplus_0_l
rewrite <- Rplus_opp_r
rewrite Rplus_le_mono_l
rewrite Rplus_opp_l
rewrite Rplus_le_mono_r
rewrite Rplus_0_r
apply Rplus_le_mono_l
apply Rplus_le_mono_nonneg
apply Rlt_le_trans with 0
Prediction takes 0.16212010383605957 seconds
( textPrediction = [
    ( tacticText = "rewrite Rplus_opp_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_0_l",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- Rplus_opp_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_le_mono_l",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_opp_l",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_le_mono_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Rplus_0_r",
      confidence = 0.5 ),
    ( tacticText = "apply Rplus_le_mono_l",
      confidence = 0.5 ),
    ( tacticText = "apply Rplus_le_mono_nonneg",
      confidence = 0.5 ),
    ( tacticText = "apply Rlt_le_trans with 0",
      confidence = 0.5 ) ] )
Model Loaded
0
STATE
n : nat |- (two_power_nat n = Zpower_nat 2 n)
----
n : nat |- (two_power_nat n = Zpower_nat 2 n) OUTPUT
simpl
induction n
auto
easy
destruct n
trivial
reflexivity
rewrite two_power
rewrite <- IHn
rewrite two_power2
Prediction takes 2.9755048751831055 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "destruct n",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "rewrite two_power",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- IHn",
      confidence = 0.5 ),
    ( tacticText = "rewrite two_power2",
      confidence = 0.5 ) ] )
STATE
 |- (two_power_nat 0 = Zpower_nat 2 0)
----
 |- (two_power_nat 0 = Zpower_nat 2 0) OUTPUT
simpl
reflexivity
easy
trivial
auto
induction 1
discriminate
simpl in *
simpl in H
rewrite <- H
Prediction takes 0.052023887634277344 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    ( tacticText = "discriminate",
      confidence = 0.5 ),
    ( tacticText = "simpl in *",
      confidence = 0.5 ),
    ( tacticText = "simpl in H",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ) ] )
STATE
 |- (two_power_nat 0 = 1)
----
 |- (two_power_nat 0 = 1) OUTPUT
simpl
reflexivity
trivial
easy
auto
simpl in *
induction 1
intros
rewrite <- H
simpl in H
Prediction takes 0.06490588188171387 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "simpl in *",
      confidence = 0.5 ),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "simpl in H",
      confidence = 0.5 ) ] )
STATE
n : nat, IHn : (two_power_nat n = Zpower_nat 2 n) |- (two_power_nat (S n) = Zpower_nat 2 (S n))
----
n : nat, IHn : (two_power_nat n = Zpower_nat 2 n) |- (two_power_nat (S n) = Zpower_nat 2 (S n)) OUTPUT
simpl
rewrite IHn
easy
auto
rewrite <- IHn
f_equal
destruct n
trivial
f_equiv
rewrite <- H
Prediction takes 0.05495595932006836 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "rewrite IHn",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "rewrite <- IHn",
      confidence = 0.5 ),
    (tacticText = "f_equal", confidence = 0.5),
    ( tacticText = "destruct n",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "f_equiv", confidence = 0.5),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ) ] )
STATE
n : nat |- (two_power_nat n = Zpower_nat 2 n)
----
n : nat |- (two_power_nat n = Zpower_nat 2 n) OUTPUT
simpl
induction n
auto
easy
destruct n
trivial
reflexivity
rewrite two_power
rewrite <- IHn
rewrite two_power2
Prediction takes 0.07409358024597168 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "destruct n",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "rewrite two_power",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- IHn",
      confidence = 0.5 ),
    ( tacticText = "rewrite two_power2",
      confidence = 0.5 ) ] )
Model Loaded
0
STATE
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), rdiv : (R -> R -> R), rinv : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), SRinv_ext : (forall p q : R, p == q -> / p == / q), AFth : almost_field_theory, ARth := (AF_AR AFth) : (almost_ring_theory 0 1 radd rmul rsub ropp req), rI_neq_rO := (AF_1_neq_0 AFth) : (~ 1 == 0), rdiv_def := (AFdiv_def AFth) : (forall p q : R, p / q == p * / q), rinv_l := (AFinv_l AFth) : (forall p : R, ~ p == 0 -> / p * p == 1), eq_trans := (Seq_trans R req Rsth) : (forall x y z : R, x == y -> y == z -> x == z), eq_sym := (Seq_sym R req Rsth) : (forall x y : R, x == y -> y == x), eq_refl := (Seq_refl R req Rsth) : (forall x : R, x == x), radd_0_l := (ARadd_0_l ARth) : (forall x : R, 0 + x == x), radd_comm := (ARadd_comm ARth) : (forall x y : R, x + y == y + x), radd_assoc := (ARadd_assoc ARth) : (forall x y z : R, x + (y + z) == x + y + z), rmul_1_l := (ARmul_1_l ARth) : (forall x : R, 1 * x == x), rmul_0_l := (ARmul_0_l ARth) : (forall x : R, 0 * x == 0), rmul_comm := (ARmul_comm ARth) : (forall x y : R, x * y == y * x), rmul_assoc := (ARmul_assoc ARth) : (forall x y z : R, x * (y * z) == x * y * z), rdistr_l := (ARdistr_l ARth) : (forall x y z : R, (x + y) * z == x * z + y * z), ropp_mul_l := (ARopp_mul_l ARth) : (forall x y : R, - (x * y) == - x * y), ropp_add := (ARopp_add ARth) : (forall x y : R, - (x + y) == - x + - y), rsub_def := (ARsub_def ARth) : (forall x y : R, x - y == x + - y), radd_0_r := (ARadd_0_r Rsth ARth) : (forall x : R, x + 0 == x), rmul_0_r := (ARmul_0_r Rsth ARth) : (forall x : R, x * 0 == 0), rmul_1_r := (ARmul_1_r Rsth ARth) : (forall x : R, x * 1 == x), ropp_0 := (ARopp_zero Rsth Reqe ARth) : (- 0 == 0), rdistr_r := (ARdistr_r Rsth Reqe ARth) : (forall x y z : R, z * (x + y) == z * x + z * y), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req 0%coef 1%coef cadd cmul csub copp ceqb phi), phi_0 := (morph0 CRmorph) : ([0] == 0), phi_1 := (morph1 CRmorph) : ([1] == 1), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get_sign), cdiv : (C -> C -> C * C), cdiv_th : (div_theory req cadd cmul phi cdiv), rpow_pow := (rpow_pow_N pow_th) : (forall (r : R) (n : N), rpow r (Cp_phi n) == pow_N 1 rmul r n), l : (list R), e1 : (PExpr C), e2 : (PExpr C) |- (~ e2 @ l == 0 -> ~ (right (split e1 e2)) @ l == 0)
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), rdiv : (R -> R -> R), rinv : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), SRinv_ext : (forall p q : R, p == q -> / p == / q), AFth : almost_field_theory, ARth := (AF_AR AFth) : (almost_ring_theory 0 1 radd rmul rsub ropp req), rI_neq_rO := (AF_1_neq_0 AFth) : (~ 1 == 0), rdiv_def := (AFdiv_def AFth) : (forall p q : R, p / q == p * / q), rinv_l := (AFinv_l AFth) : (forall p : R, ~ p == 0 -> / p * p == 1), eq_trans := (Seq_trans R req Rsth) : (forall x y z : R, x == y -> y == z -> x == z), eq_sym := (Seq_sym R req Rsth) : (forall x y : R, x == y -> y == x), eq_refl := (Seq_refl R req Rsth) : (forall x : R, x == x), radd_0_l := (ARadd_0_l ARth) : (forall x : R, 0 + x == x), radd_comm := (ARadd_comm ARth) : (forall x y : R, x + y == y + x), radd_assoc := (ARadd_assoc ARth) : (forall x y z : R, x + (y + z) == x + y + z), rmul_1_l := (ARmul_1_l ARth) : (forall x : R, 1 * x == x), rmul_0_l := (ARmul_0_l ARth) : (forall x : R, 0 * x == 0), rmul_comm := (ARmul_comm ARth) : (forall x y : R, x * y == y * x), rmul_assoc := (ARmul_assoc ARth) : (forall x y z : R, x * (y * z) == x * y * z), rdistr_l := (ARdistr_l ARth) : (forall x y z : R, (x + y) * z == x * z + y * z), ropp_mul_l := (ARopp_mul_l ARth) : (forall x y : R, - (x * y) == - x * y), ropp_add := (ARopp_add ARth) : (forall x y : R, - (x + y) == - x + - y), rsub_def := (ARsub_def ARth) : (forall x y : R, x - y == x + - y), radd_0_r := (ARadd_0_r Rsth ARth) : (forall x : R, x + 0 == x), rmul_0_r := (ARmul_0_r Rsth ARth) : (forall x : R, x * 0 == 0), rmul_1_r := (ARmul_1_r Rsth ARth) : (forall x : R, x * 1 == x), ropp_0 := (ARopp_zero Rsth Reqe ARth) : (- 0 == 0), rdistr_r := (ARdistr_r Rsth Reqe ARth) : (forall x y z : R, z * (x + y) == z * x + z * y), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req 0%coef 1%coef cadd cmul csub copp ceqb phi), phi_0 := (morph0 CRmorph) : ([0] == 0), phi_1 := (morph1 CRmorph) : ([1] == 1), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get_sign), cdiv : (C -> C -> C * C), cdiv_th : (div_theory req cadd cmul phi cdiv), rpow_pow := (rpow_pow_N pow_th) : (forall (r : R) (n : N), rpow r (Cp_phi n) == pow_N 1 rmul r n), l : (list R), e1 : (PExpr C), e2 : (PExpr C) |- (~ e2 @ l == 0 -> ~ (right (split e1 e2)) @ l == 0) OUTPUT
Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get
Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow) : (C -> Cpow), get_sign_spec : (sign_theory copp ceqb get_sign), cdiv
Cpow), rpow : (R -> Cpow -> R), pow_th : (power_phi rpow), rpow), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get_sign), cdiv
Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb phi
Cpow), rpow : (R -> Cpow -> R), pow_ Cp_th : (power_phi rpow), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get_sign), cdiv
Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), get_sign : (C -> option C) : (C -> Cpow), phi_th : (power_
Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), get_sign : (C -> option C), get_sign_spec : (power_theory copp ceqb get
Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow) : (N -> Cpow), get_sign_spec : (sign_theory copp ceqb get_sign), cdiv
Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul rdiv Cp_phi rpow), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get
Cpow), rpow : (R -> Cpow -> R), phi_th : (power_theory 1 rmul req Cp_phi rpow), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get
Prediction takes 3.553846597671509 seconds
Model Loaded
0
STATE
 |- (forall a b c : Z, c > 0 -> (a + b * c) / c = a / c + b)
----
 |- (forall a b c : Z, c > 0 -> (a + b * c) / c = a / c + b) OUTPUT
intros
intros ?
exact Private_NZDiv.div_unique
exact Private_NZDiv.div_div_unique
exact Private_NZDiv.div_add
zero
rewrite (add_comm c)
apply Private_NZDiv.div_unique
exact Private_NZDiv.div_div_add
exact Private_NZDiv.div_add_cancel
Prediction takes 3.3469157218933105 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "exact Private_NZDiv.div_unique",
      confidence = 0.5 ),
    ( tacticText = "exact Private_NZDiv.div_div_unique",
      confidence = 0.5 ),
    ( tacticText = "exact Private_NZDiv.div_add",
      confidence = 0.5 ),
    (tacticText = "zero", confidence = 0.5),
    ( tacticText = "rewrite (add_comm c)",
      confidence = 0.5 ),
    ( tacticText = "apply Private_NZDiv.div_unique",
      confidence = 0.5 ),
    ( tacticText = "exact Private_NZDiv.div_div_add",
      confidence = 0.5 ),
    ( tacticText = "exact Private_NZDiv.div_add_cancel",
      confidence = 0.5 ) ] )
STATE
a : Z, b : Z, c : Z, H : (c > 0) |- ((a + b * c) / c = a / c + b)
----
a : Z, b : Z, c : Z, H : (c > 0) |- ((a + b * c) / c = a / c + b) OUTPUT
rewrite (add_comm _ c)
symmetry
rewrite (add_comm c)
rewrite (add_comm a)
rewrite (div_mod a c)
rewrite (div_mod a b)
apply Z.div_mod
apply Private_NZDiv.div_add
rewrite (div_mod a b c)
rewrite <- (add_0_l c)
Prediction takes 0.12006616592407227 seconds
( textPrediction = [
    ( tacticText = "rewrite (add_comm _ c)",
      confidence = 0.5 ),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "rewrite (add_comm c)",
      confidence = 0.5 ),
    ( tacticText = "rewrite (add_comm a)",
      confidence = 0.5 ),
    ( tacticText = "rewrite (div_mod a c)",
      confidence = 0.5 ),
    ( tacticText = "rewrite (div_mod a b)",
      confidence = 0.5 ),
    ( tacticText = "apply Z.div_mod",
      confidence = 0.5 ),
    ( tacticText = "apply Private_NZDiv.div_add",
      confidence = 0.5 ),
    ( tacticText = "rewrite (div_mod a b c)",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- (add_0_l c)",
      confidence = 0.5 ) ] )
STATE
a : Z, b : Z, c : Z, H : (c > 0) |- (a / c + b = (a + b * c) / c)
----
a : Z, b : Z, c : Z, H : (c > 0) |- (a / c + b = (a + b * c) / c) OUTPUT
symmetry
rewrite (add_comm _ c)
apply div_unique with c
apply div_mod
rewrite div_mod
field
rewrite (add_comm a)
rewrite <- div_mod
rewrite (add_comm c)
rewrite Z.add_comm
Prediction takes 0.09788370132446289 seconds
( textPrediction = [
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "rewrite (add_comm _ c)",
      confidence = 0.5 ),
    ( tacticText = "apply div_unique with c",
      confidence = 0.5 ),
    ( tacticText = "apply div_mod",
      confidence = 0.5 ),
    ( tacticText = "rewrite div_mod",
      confidence = 0.5 ),
    (tacticText = "field", confidence = 0.5),
    ( tacticText = "rewrite (add_comm a)",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- div_mod",
      confidence = 0.5 ),
    ( tacticText = "rewrite (add_comm c)",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.add_comm",
      confidence = 0.5 ) ] )
STATE
a : Z, b : Z, c : Z, H : (c > 0) |- ((a + b * c) / c = a / c + b)
----
a : Z, b : Z, c : Z, H : (c > 0) |- ((a + b * c) / c = a / c + b) OUTPUT
rewrite (add_comm _ c)
symmetry
rewrite (add_comm c)
rewrite (add_comm a)
rewrite (div_mod a c)
rewrite (div_mod a b)
apply Z.div_mod
apply Private_NZDiv.div_add
rewrite (div_mod a b c)
rewrite <- (add_0_l c)
Prediction takes 0.11706805229187012 seconds
( textPrediction = [
    ( tacticText = "rewrite (add_comm _ c)",
      confidence = 0.5 ),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "rewrite (add_comm c)",
      confidence = 0.5 ),
    ( tacticText = "rewrite (add_comm a)",
      confidence = 0.5 ),
    ( tacticText = "rewrite (div_mod a c)",
      confidence = 0.5 ),
    ( tacticText = "rewrite (div_mod a b)",
      confidence = 0.5 ),
    ( tacticText = "apply Z.div_mod",
      confidence = 0.5 ),
    ( tacticText = "apply Private_NZDiv.div_add",
      confidence = 0.5 ),
    ( tacticText = "rewrite (div_mod a b c)",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- (add_0_l c)",
      confidence = 0.5 ) ] )
STATE
a : Z |- (forall b c : Z, c > 0 -> (a + b * c) / c = a / c + b)
----
a : Z |- (forall b c : Z, c > 0 -> (a + b * c) / c = a / c + b) OUTPUT
intros ?
intros
exact Z.div_mod
zero_or_not c
exact Private_NZDiv.div_mod
exact Private_NZDiv.div_add
apply Z.div_mod
apply Z.div_unique with c
solve_proper
solve_gcd
Prediction takes 0.11679339408874512 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "exact Z.div_mod",
      confidence = 0.5 ),
    ( tacticText = "zero_or_not c",
      confidence = 0.5 ),
    ( tacticText = "exact Private_NZDiv.div_mod",
      confidence = 0.5 ),
    ( tacticText = "exact Private_NZDiv.div_add",
      confidence = 0.5 ),
    ( tacticText = "apply Z.div_mod",
      confidence = 0.5 ),
    ( tacticText = "apply Z.div_unique with c",
      confidence = 0.5 ),
    ( tacticText = "solve_proper",
      confidence = 0.5 ),
    (tacticText = "solve_gcd", confidence = 0.5) ] )
STATE
a : Z, b : Z |- (forall c : Z, c > 0 -> (a + b * c) / c = a / c + b)
----
a : Z, b : Z |- (forall c : Z, c > 0 -> (a + b * c) / c = a / c + b) OUTPUT
intros ?
intros
zero_or_not c
zero_or_not b
solve_proper
apply Z.div_unique with c
exact Private_NZDiv.div_unique
exact Private_NZDiv.div_add
solve_gcd
exact Z.div_mod
Prediction takes 0.09885692596435547 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "zero_or_not c",
      confidence = 0.5 ),
    ( tacticText = "zero_or_not b",
      confidence = 0.5 ),
    ( tacticText = "solve_proper",
      confidence = 0.5 ),
    ( tacticText = "apply Z.div_unique with c",
      confidence = 0.5 ),
    ( tacticText = "exact Private_NZDiv.div_unique",
      confidence = 0.5 ),
    ( tacticText = "exact Private_NZDiv.div_add",
      confidence = 0.5 ),
    (tacticText = "solve_gcd", confidence = 0.5),
    ( tacticText = "exact Z.div_mod",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
starting proving server with connection through their stdin
using textmode optiontext
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
x : Z, y : Z |- ((x <= y)%Z = (inject_Z x <= inject_Z y))
----
x : Z, y : Z |- ((x <= y)%Z = (inject_Z x <= inject_Z y)) OUTPUT
apply Z.le_antisym
unfold Z.le
easy
simpl
apply Zle_antisym
unfold Zle
auto
subst
apply Z_le_antisym
apply Zmod_le
Prediction takes 3.2166547775268555 seconds
( textPrediction = [
    ( tacticText = "apply Z.le_antisym",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.le",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "apply Zle_antisym",
      confidence = 0.5 ),
    ( tacticText = "unfold Zle",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    ( tacticText = "apply Z_le_antisym",
      confidence = 0.5 ),
    ( tacticText = "apply Zmod_le",
      confidence = 0.5 ) ] )
STATE
x : Z, y : Z |- (((x ?= y)%Z <> Gt) = (inject_Z x <= inject_Z y))
----
x : Z, y : Z |- (((x ?= y)%Z <> Gt) = (inject_Z x <= inject_Z y)) OUTPUT
apply Z.le_antisym
unfold to_Z
case Z.compare_spec
unfold Z.le
easy
apply Zle_antisym
apply Zmod_le
apply Z.lt_le_antisym
apply Z.le_trans with x
apply Z.lt_le_incl
Prediction takes 0.1335468292236328 seconds
( textPrediction = [
    ( tacticText = "apply Z.le_antisym",
      confidence = 0.5 ),
    ( tacticText = "unfold to_Z",
      confidence = 0.5 ),
    ( tacticText = "case Z.compare_spec",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.le",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply Zle_antisym",
      confidence = 0.5 ),
    ( tacticText = "apply Zmod_le",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_le_antisym",
      confidence = 0.5 ),
    ( tacticText = "apply Z.le_trans with x",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_le_incl",
      confidence = 0.5 ) ] )
STATE
x : Z, y : Z |- (x = y -> (Eq <> Gt) = (inject_Z x <= inject_Z y))
----
x : Z, y : Z |- (x = y -> (Eq <> Gt) = (inject_Z x <= inject_Z y)) OUTPUT
intros ?
intros
easy
simpl
unfold to_Z
destruct 1
auto
apply Zle_antisym
unfold Z.le
apply Zeq_sym
Prediction takes 0.1264798641204834 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold to_Z",
      confidence = 0.5 ),
    ( tacticText = "destruct 1",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "apply Zle_antisym",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.le",
      confidence = 0.5 ),
    ( tacticText = "apply Zeq_sym",
      confidence = 0.5 ) ] )
STATE
x : Z, y : Z, H : (x = y) |- ((Eq <> Gt) = (inject_Z x <= inject_Z y))
----
x : Z, y : Z, H : (x = y) |- ((Eq <> Gt) = (inject_Z x <= inject_Z y)) OUTPUT
auto
easy
apply Z.le_antisym
simpl
subst
rewrite to_Z_Z_Z
apply Z.lt_antisym
rewrite to_Z_Z
apply Z.lt_le_incl
apply Z.lt_le_antisym
Prediction takes 0.13423967361450195 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply Z.le_antisym",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    ( tacticText = "rewrite to_Z_Z_Z",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_antisym",
      confidence = 0.5 ),
    ( tacticText = "rewrite to_Z_Z",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_le_incl",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_le_antisym",
      confidence = 0.5 ) ] )
STATE
x : Z, y : Z, H : (x = y) |- ((Eq <> Gt) = (inject_Z x <= inject_Z y))
----
x : Z, y : Z, H : (x = y) |- ((Eq <> Gt) = (inject_Z x <= inject_Z y)) OUTPUT
auto
easy
apply Z.le_antisym
simpl
subst
rewrite to_Z_Z_Z
apply Z.lt_antisym
rewrite to_Z_Z
apply Z.lt_le_incl
apply Z.lt_le_antisym
Prediction takes 0.1086430549621582 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply Z.le_antisym",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    ( tacticText = "rewrite to_Z_Z_Z",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_antisym",
      confidence = 0.5 ),
    ( tacticText = "rewrite to_Z_Z",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_le_incl",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_le_antisym",
      confidence = 0.5 ) ] )
STATE
x : Z, y : Z |- ((x <= y)%Z = (inject_Z x <= inject_Z y))
----
x : Z, y : Z |- ((x <= y)%Z = (inject_Z x <= inject_Z y)) OUTPUT
apply Z.le_antisym
unfold Z.le
easy
simpl
apply Zle_antisym
unfold Zle
auto
subst
apply Z_le_antisym
apply Zmod_le
Prediction takes 0.09123349189758301 seconds
( textPrediction = [
    ( tacticText = "apply Z.le_antisym",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.le",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "apply Zle_antisym",
      confidence = 0.5 ),
    ( tacticText = "unfold Zle",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    ( tacticText = "apply Z_le_antisym",
      confidence = 0.5 ),
    ( tacticText = "apply Zmod_le",
      confidence = 0.5 ) ] )
STATE
x : Z, y : Z |- (((x ?= y)%Z <> Gt) = (inject_Z x <= inject_Z y))
----
x : Z, y : Z |- (((x ?= y)%Z <> Gt) = (inject_Z x <= inject_Z y)) OUTPUT
apply Z.le_antisym
unfold to_Z
case Z.compare_spec
unfold Z.le
easy
apply Zle_antisym
apply Zmod_le
apply Z.lt_le_antisym
apply Z.le_trans with x
apply Z.lt_le_incl
Prediction takes 0.11583209037780762 seconds
( textPrediction = [
    ( tacticText = "apply Z.le_antisym",
      confidence = 0.5 ),
    ( tacticText = "unfold to_Z",
      confidence = 0.5 ),
    ( tacticText = "case Z.compare_spec",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.le",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply Zle_antisym",
      confidence = 0.5 ),
    ( tacticText = "apply Zmod_le",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_le_antisym",
      confidence = 0.5 ),
    ( tacticText = "apply Z.le_trans with x",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_le_incl",
      confidence = 0.5 ) ] )
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
( textPrediction = [
    ( tacticText = "Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get",
      confidence = 0.5 ),
    ( tacticText = "Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow) : (C -> Cpow), get_sign_spec : (sign_theory copp ceqb get_sign), cdiv",
      confidence = 0.5 ),
    ( tacticText = "Cpow), rpow : (R -> Cpow -> R), pow_th : (power_phi rpow), rpow), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get_sign), cdiv",
      confidence = 0.5 ),
    ( tacticText = "Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb phi",
      confidence = 0.5 ),
    ( tacticText = "Cpow), rpow : (R -> Cpow -> R), pow_ Cp_th : (power_phi rpow), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get_sign), cdiv",
      confidence = 0.5 ),
    ( tacticText = "Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), get_sign : (C -> option C) : (C -> Cpow), phi_th : (power_",
      confidence = 0.5 ),
    ( tacticText = "Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), get_sign : (C -> option C), get_sign_spec : (power_theory copp ceqb get",
      confidence = 0.5 ),
    ( tacticText = "Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow) : (N -> Cpow), get_sign_spec : (sign_theory copp ceqb get_sign), cdiv",
      confidence = 0.5 ),
    ( tacticText = "Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul rdiv Cp_phi rpow), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get",
      confidence = 0.5 ),
    ( tacticText = "Cpow), rpow : (R -> Cpow -> R), phi_th : (power_theory 1 rmul req Cp_phi rpow), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get",
      confidence = 0.5 ) ] )
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
starting proving server with connection through their stdin
using textmode optiontext
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Setoid_Theory R req), Reqe : (ring_eq_ext radd rmul ropp req), Rth : (ring_theory 0 1 radd rmul rsub ropp req), ARth := (Rth_ARth Rsth Reqe Rth) : (almost_ring_theory 0 1 radd rmul rsub ropp req) |- (forall x y : Z, Zeq_bool x y = true -> [x] == [y])
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Setoid_Theory R req), Reqe : (ring_eq_ext radd rmul ropp req), Rth : (ring_theory 0 1 radd rmul rsub ropp req), ARth := (Rth_ARth Rsth Reqe Rth) : (almost_ring_theory 0 1 radd rmul rsub ropp req) |- (forall x y : Z, Zeq_bool x y = true -> [x] == [y]) OUTPUT
intros
intros ?
simpl
destruct x
trivial
intros until y
easy
destruct y
intros until x
apply gen_phiZ
Prediction takes 3.2009353637695312 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct x",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "intros until y",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "destruct y",
      confidence = 0.5 ),
    ( tacticText = "intros until x",
      confidence = 0.5 ),
    ( tacticText = "apply gen_phiZ",
      confidence = 0.5 ) ] )
STATE
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Setoid_Theory R req), Reqe : (ring_eq_ext radd rmul ropp req), Rth : (ring_theory 0 1 radd rmul rsub ropp req), ARth := (Rth_ARth Rsth Reqe Rth) : (almost_ring_theory 0 1 radd rmul rsub ropp req), x : Z, y : Z, H : (Zeq_bool x y = true) |- ([x] == [y])
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Setoid_Theory R req), Reqe : (ring_eq_ext radd rmul ropp req), Rth : (ring_theory 0 1 radd rmul rsub ropp req), ARth := (Rth_ARth Rsth Reqe Rth) : (almost_ring_theory 0 1 radd rmul rsub ropp req), x : Z, y : Z, H : (Zeq_bool x y = true) |- ([x] == [y]) OUTPUT
rewrite H
easy
subst
reflexivity
rewrite H in H
apply gen_phiPOS_not_eq
apply gen_phiPOS_not_eq in H
rewrite (Zeq_ext Reqe)
apply gen_phiZ_not_eq
apply gen_phiZ_eq_eq
Prediction takes 0.22847890853881836 seconds
( textPrediction = [
    (tacticText = "rewrite H", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "rewrite H in H",
      confidence = 0.5 ),
    ( tacticText = "apply gen_phiPOS_not_eq",
      confidence = 0.5 ),
    ( tacticText = "apply gen_phiPOS_not_eq in H",
      confidence = 0.5 ),
    ( tacticText = "rewrite (Zeq_ext Reqe)",
      confidence = 0.5 ),
    ( tacticText = "apply gen_phiZ_not_eq",
      confidence = 0.5 ),
    ( tacticText = "apply gen_phiZ_eq_eq",
      confidence = 0.5 ) ] )
STATE
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Setoid_Theory R req), Reqe : (ring_eq_ext radd rmul ropp req), Rth : (ring_theory 0 1 radd rmul rsub ropp req), ARth := (Rth_ARth Rsth Reqe Rth) : (almost_ring_theory 0 1 radd rmul rsub ropp req), x : Z |- (forall y : Z, Zeq_bool x y = true -> [x] == [y])
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Setoid_Theory R req), Reqe : (ring_eq_ext radd rmul ropp req), Rth : (ring_theory 0 1 radd rmul rsub ropp req), ARth := (Rth_ARth Rsth Reqe Rth) : (almost_ring_theory 0 1 radd rmul rsub ropp req), x : Z |- (forall y : Z, Zeq_bool x y = true -> [x] == [y]) OUTPUT
intros
intros ?
intros until y
simpl
destruct x
intros until x
easy
unfold gen_phiZ
apply gen_phiZ_eq
apply gen_phiZ
Prediction takes 0.16634559631347656 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "intros until y",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct x",
      confidence = 0.5 ),
    ( tacticText = "intros until x",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "unfold gen_phiZ",
      confidence = 0.5 ),
    ( tacticText = "apply gen_phiZ_eq",
      confidence = 0.5 ),
    ( tacticText = "apply gen_phiZ",
      confidence = 0.5 ) ] )
STATE
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Setoid_Theory R req), Reqe : (ring_eq_ext radd rmul ropp req), Rth : (ring_theory 0 1 radd rmul rsub ropp req), ARth := (Rth_ARth Rsth Reqe Rth) : (almost_ring_theory 0 1 radd rmul rsub ropp req), x : Z, y : Z, H : (Zeq_bool x y = true) |- ([x] == [y])
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Setoid_Theory R req), Reqe : (ring_eq_ext radd rmul ropp req), Rth : (ring_theory 0 1 radd rmul rsub ropp req), ARth := (Rth_ARth Rsth Reqe Rth) : (almost_ring_theory 0 1 radd rmul rsub ropp req), x : Z, y : Z, H : (Zeq_bool x y = true) |- ([x] == [y]) OUTPUT
rewrite H
easy
subst
reflexivity
rewrite H in H
apply gen_phiPOS_not_eq
apply gen_phiPOS_not_eq in H
rewrite (Zeq_ext Reqe)
apply gen_phiZ_not_eq
apply gen_phiZ_eq_eq
Prediction takes 0.1718142032623291 seconds
( textPrediction = [
    (tacticText = "rewrite H", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "rewrite H in H",
      confidence = 0.5 ),
    ( tacticText = "apply gen_phiPOS_not_eq",
      confidence = 0.5 ),
    ( tacticText = "apply gen_phiPOS_not_eq in H",
      confidence = 0.5 ),
    ( tacticText = "rewrite (Zeq_ext Reqe)",
      confidence = 0.5 ),
    ( tacticText = "apply gen_phiZ_not_eq",
      confidence = 0.5 ),
    ( tacticText = "apply gen_phiZ_eq_eq",
      confidence = 0.5 ) ] )
STATE
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Setoid_Theory R req), Reqe : (ring_eq_ext radd rmul ropp req), Rth : (ring_theory 0 1 radd rmul rsub ropp req), ARth := (Rth_ARth Rsth Reqe Rth) : (almost_ring_theory 0 1 radd rmul rsub ropp req), x : Z, y : Z |- (Zeq_bool x y = true -> [x] == [y])
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Setoid_Theory R req), Reqe : (ring_eq_ext radd rmul ropp req), Rth : (ring_theory 0 1 radd rmul rsub ropp req), ARth := (Rth_ARth Rsth Reqe Rth) : (almost_ring_theory 0 1 radd rmul rsub ropp req), x : Z, y : Z |- (Zeq_bool x y = true -> [x] == [y]) OUTPUT
intros
intros ?
destruct x
easy
simpl
intros until y
destruct y
destruct 1
intros until x
apply gen_phiZ
Prediction takes 0.09053492546081543 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "destruct x",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "intros until y",
      confidence = 0.5 ),
    ( tacticText = "destruct y",
      confidence = 0.5 ),
    ( tacticText = "destruct 1",
      confidence = 0.5 ),
    ( tacticText = "intros until x",
      confidence = 0.5 ),
    ( tacticText = "apply gen_phiZ",
      confidence = 0.5 ) ] )
STATE
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Setoid_Theory R req), Reqe : (ring_eq_ext radd rmul ropp req), Rth : (ring_theory 0 1 radd rmul rsub ropp req), ARth := (Rth_ARth Rsth Reqe Rth) : (almost_ring_theory 0 1 radd rmul rsub ropp req) |- (forall y : Z, Zeq_bool 0 y = true -> [0] == [y])
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Setoid_Theory R req), Reqe : (ring_eq_ext radd rmul ropp req), Rth : (ring_theory 0 1 radd rmul rsub ropp req), ARth := (Rth_ARth Rsth Reqe Rth) : (almost_ring_theory 0 1 radd rmul rsub ropp req) |- (forall y : Z, Zeq_bool 0 y = true -> [0] == [y]) OUTPUT
intros
intros ?
intros until y
simpl
destruct y
easy
trivial
auto
intros until x
apply gen_phiZ
Prediction takes 0.09107780456542969 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "intros until y",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct y",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "intros until x",
      confidence = 0.5 ),
    ( tacticText = "apply gen_phiZ",
      confidence = 0.5 ) ] )
STATE
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Setoid_Theory R req), Reqe : (ring_eq_ext radd rmul ropp req), Rth : (ring_theory 0 1 radd rmul rsub ropp req), ARth := (Rth_ARth Rsth Reqe Rth) : (almost_ring_theory 0 1 radd rmul rsub ropp req) |- (forall x y : Z, Zeq_bool x y = true -> [x] == [y])
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Setoid_Theory R req), Reqe : (ring_eq_ext radd rmul ropp req), Rth : (ring_theory 0 1 radd rmul rsub ropp req), ARth := (Rth_ARth Rsth Reqe Rth) : (almost_ring_theory 0 1 radd rmul rsub ropp req) |- (forall x y : Z, Zeq_bool x y = true -> [x] == [y]) OUTPUT
intros
intros ?
simpl
destruct x
trivial
intros until y
easy
destruct y
intros until x
apply gen_phiZ
Prediction takes 0.09419059753417969 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct x",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "intros until y",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "destruct y",
      confidence = 0.5 ),
    ( tacticText = "intros until x",
      confidence = 0.5 ),
    ( tacticText = "apply gen_phiZ",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
 |- (forall s s' : t, compare s s' = Eq -> eq s s')
----
 |- (forall s s' : t, compare s s' = Eq -> eq s s') OUTPUT
intros
unfold compare
intros ?
unfold eq
induction s
unfold s'
unfold equal
unfold lt
intros until s
induction 1
Prediction takes 3.3859219551086426 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold compare",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "unfold eq", confidence = 0.5),
    ( tacticText = "induction s",
      confidence = 0.5 ),
    ( tacticText = "unfold s\'",
      confidence = 0.5 ),
    ( tacticText = "unfold equal",
      confidence = 0.5 ),
    (tacticText = "unfold lt", confidence = 0.5),
    ( tacticText = "intros until s",
      confidence = 0.5 ),
    ( tacticText = "induction 1",
      confidence = 0.5 ) ] )
STATE
s : t, s' : t, H : (compare s s' = Eq) |- (eq s s')
----
s : t, s' : t, H : (compare s s' = Eq) |- (eq s s') OUTPUT
auto
apply compare_eq_iff
destruct (compare_spec s s')
rewrite <- compare_eq_iff
apply compare_eq
auto with relations
case (compare_spec s s')
rewrite compare_eq_iff
easy
apply compare_eq_iff in H
Prediction takes 0.11743450164794922 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "apply compare_eq_iff",
      confidence = 0.5 ),
    ( tacticText = "destruct (compare_spec s s\')",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- compare_eq_iff",
      confidence = 0.5 ),
    ( tacticText = "apply compare_eq",
      confidence = 0.5 ),
    ( tacticText = "auto with relations",
      confidence = 0.5 ),
    ( tacticText = "case (compare_spec s s\')",
      confidence = 0.5 ),
    ( tacticText = "rewrite compare_eq_iff",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply compare_eq_iff in H",
      confidence = 0.5 ) ] )
STATE
 |- (forall s s' : t, (fix compare (m m' : t) {struct m} : comparison := match m with | Leaf => if is_empty m' then Eq else Lt | Node l o r => match m' with | Leaf => if is_empty m then Eq else Gt | Node l' o' r' => lex (compare_bool o o') (lex (compare l l') (compare r r')) end end) s s' = Eq -> eq s s')
----
 |- (forall s s' : t, (fix compare (m m' : t) {struct m} : comparison := match m with | Leaf => if is_empty m' then Eq else Lt | Node l o r => match m' with | Leaf => if is_empty m then Eq else Gt | Node l' o' r' => lex (compare_bool o o') (lex (compare l l') (compare r r')) end end) s s' = Eq -> eq s s') OUTPUT
intros ?
intros
unfold compare
simpl
intros until s
destruct s
destruct o
auto
destruct s'
induction s
Prediction takes 0.06893062591552734 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold compare",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "intros until s",
      confidence = 0.5 ),
    ( tacticText = "destruct s",
      confidence = 0.5 ),
    ( tacticText = "destruct o",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "destruct s\'",
      confidence = 0.5 ),
    ( tacticText = "induction s",
      confidence = 0.5 ) ] )
STATE
s : t |- (forall s' : t, (fix compare (m m' : t) {struct m} : comparison := match m with | Leaf => if is_empty m' then Eq else Lt | Node l o r => match m' with | Leaf => if is_empty m then Eq else Gt | Node l' o' r' => lex (compare_bool o o') (lex (compare l l') (compare r r')) end end) s s' = Eq -> eq s s')
----
s : t |- (forall s' : t, (fix compare (m m' : t) {struct m} : comparison := match m with | Leaf => if is_empty m' then Eq else Lt | Node l o r => match m' with | Leaf => if is_empty m then Eq else Gt | Node l' o' r' => lex (compare_bool o o') (lex (compare l l') (compare r r')) end end) s s' = Eq -> eq s s') OUTPUT
intros ?
unfold compare
intros until s
destruct s
intros
simpl
auto
induction s
destruct s'
case compare
Prediction takes 0.0760047435760498 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold compare",
      confidence = 0.5 ),
    ( tacticText = "intros until s",
      confidence = 0.5 ),
    ( tacticText = "destruct s",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "induction s",
      confidence = 0.5 ),
    ( tacticText = "destruct s\'",
      confidence = 0.5 ),
    ( tacticText = "case compare",
      confidence = 0.5 ) ] )
STATE
s : t, s' : t |- ((fix compare (m m' : t) {struct m} : comparison := match m with | Leaf => if is_empty m' then Eq else Lt | Node l o r => match m' with | Leaf => if is_empty m then Eq else Gt | Node l' o' r' => lex (compare_bool o o') (lex (compare l l') (compare r r')) end end) s s' = Eq -> eq s s')
----
s : t, s' : t |- ((fix compare (m m' : t) {struct m} : comparison := match m with | Leaf => if is_empty m' then Eq else Lt | Node l o r => match m' with | Leaf => if is_empty m then Eq else Gt | Node l' o' r' => lex (compare_bool o o') (lex (compare l l') (compare r r')) end end) s s' = Eq -> eq s s') OUTPUT
intros ?
unfold compare
destruct s
auto
intros
intros until s
destruct s'
case compare_spec
rewrite compare_eq
intros until s'
Prediction takes 0.0787208080291748 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold compare",
      confidence = 0.5 ),
    ( tacticText = "destruct s",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "intros until s",
      confidence = 0.5 ),
    ( tacticText = "destruct s\'",
      confidence = 0.5 ),
    ( tacticText = "case compare_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite compare_eq",
      confidence = 0.5 ),
    ( tacticText = "intros until s\'",
      confidence = 0.5 ) ] )
STATE
s : t, s' : t, H : ((fix compare (m m' : t) {struct m} : comparison := match m with | Leaf => if is_empty m' then Eq else Lt | Node l o r => match m' with | Leaf => if is_empty m then Eq else Gt | Node l' o' r' => lex (compare_bool o o') (lex (compare l l') (compare r r')) end end) s s' = Eq) |- (eq s s')
----
s : t, s' : t, H : ((fix compare (m m' : t) {struct m} : comparison := match m with | Leaf => if is_empty m' then Eq else Lt | Node l o r => match m' with | Leaf => if is_empty m then Eq else Gt | Node l' o' r' => lex (compare_bool o o') (lex (compare l l') (compare r r')) end end) s s' = Eq) |- (eq s s') OUTPUT
auto
unfold compare
simpl
destruct compare
apply compare_eq
rewrite compare_eq
destruct (compare_dec s s')
rewrite compare_eq_iff
rewrite <- compare_eq
rewrite <- compare_eq_iff
Prediction takes 0.11069607734680176 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold compare",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct compare",
      confidence = 0.5 ),
    ( tacticText = "apply compare_eq",
      confidence = 0.5 ),
    ( tacticText = "rewrite compare_eq",
      confidence = 0.5 ),
    ( tacticText = "destruct (compare_dec s s\')",
      confidence = 0.5 ),
    ( tacticText = "rewrite compare_eq_iff",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- compare_eq",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- compare_eq_iff",
      confidence = 0.5 ) ] )
STATE
s : t, s' : t, H : ((fix compare (m m' : t) {struct m} : comparison := match m with | Leaf => if is_empty m' then Eq else Lt | Node l o r => match m' with | Leaf => if is_empty m then Eq else Gt | Node l' o' r' => lex (compare_bool o o') (lex (compare l l') (compare r r')) end end) s s' = Eq) |- (eq s s')
----
Model Loaded
0
STATE
 |- (forall s1 s2 : tree, Ok s1 -> Ok s2 -> Ok (inter s1 s2) /\ (forall y : elt, InT y (inter s1 s2) <-> InT y s1 /\ InT y s2))
----
 |- (forall s1 s2 : tree, Ok s1 -> Ok s2 -> Ok (inter s1 s2) /\ (forall y : elt, InT y (inter s1 s2) <-> InT y s1 /\ InT y s2)) OUTPUT
intros
intros ?
intuition
simpl
induction s1
split
induction s2
unfold Subset
red
unfold inter
Prediction takes 3.2925572395324707 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "induction s1",
      confidence = 0.5 ),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "induction s2",
      confidence = 0.5 ),
    ( tacticText = "unfold Subset",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold inter",
      confidence = 0.5 ) ] )
STATE
s1 : tree, s2 : tree, H : (Ok s1), H0 : (Ok s2) |- (Ok (inter s1 s2) /\ (forall y : elt, InT y (inter s1 s2) <-> InT y s1 /\ InT y s2))
----
s1 : tree, s2 : tree, H : (Ok s1), H0 : (Ok s2) |- (Ok (inter s1 s2) /\ (forall y : elt, InT y (inter s1 s2) <-> InT y s1 /\ InT y s2)) OUTPUT
split
intros
rewrite inter_spec
intros ?
unfold inter
auto
intuition
unfold Subset
simpl inter_spec
apply inter_ok
Prediction takes 0.06685566902160645 seconds
( textPrediction = [
    (tacticText = "split", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "rewrite inter_spec",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold inter",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    ( tacticText = "unfold Subset",
      confidence = 0.5 ),
    ( tacticText = "simpl inter_spec",
      confidence = 0.5 ),
    ( tacticText = "apply inter_ok",
      confidence = 0.5 ) ] )
STATE
s1 : tree, s2 : tree, H : (Ok s1), H0 : (Ok s2) |- (Ok (inter s1 s2))
----
s1 : tree, s2 : tree, H : (Ok s1), H0 : (Ok s2) |- (Ok (inter s1 s2)) OUTPUT
auto_tc
unfold inter
auto
unfold Subset
apply equal_ok
apply inter_ok
intros ?
unfold union
unfold equal
unfold inter_ok
Prediction takes 0.06523299217224121 seconds
( textPrediction = [
    (tacticText = "auto_tc", confidence = 0.5),
    ( tacticText = "unfold inter",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold Subset",
      confidence = 0.5 ),
    ( tacticText = "apply equal_ok",
      confidence = 0.5 ),
    ( tacticText = "apply inter_ok",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold union",
      confidence = 0.5 ),
    ( tacticText = "unfold equal",
      confidence = 0.5 ),
    ( tacticText = "unfold inter_ok",
      confidence = 0.5 ) ] )
STATE
s1 : tree, s2 : tree, H : (Ok s1), H0 : (Ok s2) |- (Ok ((fix inter (s1 s2 : tree) {struct s1} : tree := match s1 with | Leaf => Leaf | Node _ l1 x1 r1 => match s2 with | Leaf => Leaf | Node _ _ _ _ => let (l2', pres, r2') := split x1 s2 in if pres then join (inter l1 l2') x1 (inter r1 r2') else concat (inter l1 l2') (inter r1 r2') end end) s1 s2))
----
s1 : tree, s2 : tree, H : (Ok s1), H0 : (Ok s2) |- (Ok ((fix inter (s1 s2 : tree) {struct s1} : tree := match s1 with | Leaf => Leaf | Node _ l1 x1 r1 => match s2 with | Leaf => Leaf | Node _ _ _ _ => let (l2', pres, r2') := split x1 s2 in if pres then join (inter l1 l2') x1 (inter r1 r2') else concat (inter l1 l2') (inter r1 r2') end end) s1 s2)) OUTPUT
auto
simpl
unfold inter
destruct compare
destruct compare_spec
let rec constructors := constructors
let rec constructors := repeat constructor in constructors
destruct (IHs1 s2)
destruct (compare_spec s1 s2)
elim (IHs1 s2)
Prediction takes 0.1570899486541748 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold inter",
      confidence = 0.5 ),
    ( tacticText = "destruct compare",
      confidence = 0.5 ),
    ( tacticText = "destruct compare_spec",
      confidence = 0.5 ),
    ( tacticText = "let rec constructors := constructors",
      confidence = 0.5 ),
    ( tacticText = "let rec constructors := repeat constructor in constructors",
      confidence = 0.5 ),
    ( tacticText = "destruct (IHs1 s2)",
      confidence = 0.5 ),
    ( tacticText = "destruct (compare_spec s1 s2)",
      confidence = 0.5 ),
    ( tacticText = "elim (IHs1 s2)",
      confidence = 0.5 ) ] )
STATE
s1 : tree |- (forall s2 : tree, Ok s1 -> Ok s2 -> Ok (inter s1 s2) /\ (forall y : elt, InT y (inter s1 s2) <-> InT y s1 /\ InT y s2))
----
s1 : tree |- (forall s2 : tree, Ok s1 -> Ok s2 -> Ok (inter s1 s2) /\ (forall y : elt, InT y (inter s1 s2) <-> InT y s1 /\ InT y s2)) OUTPUT
intros ?
induction s1
intros
induction s2
simpl
unfold Subset
unfold inter
intuition
induction s
unfold flip
Prediction takes 0.0650942325592041 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "induction s1",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction s2",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold Subset",
      confidence = 0.5 ),
    ( tacticText = "unfold inter",
      confidence = 0.5 ),
    (tacticText = "intuition", confidence = 0.5),
    ( tacticText = "induction s",
      confidence = 0.5 ),
    ( tacticText = "unfold flip",
      confidence = 0.5 ) ] )
STATE
s1 : tree, s2 : tree |- (Ok s1 -> Ok s2 -> Ok (inter s1 s2) /\ (forall y : elt, InT y (inter s1 s2) <-> InT y s1 /\ InT y s2))
----
s1 : tree, s2 : tree |- (Ok s1 -> Ok s2 -> Ok (inter s1 s2) /\ (forall y : elt, InT y (inter s1 s2) <-> InT y s1 /\ InT y s2)) OUTPUT
intros ?
intros
induction s1
intuition
simpl
induction s2
revert s1
unfold Subset
unfold inter
revert s2
Prediction takes 0.05139446258544922 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction s1",
      confidence = 0.5 ),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "induction s2",
      confidence = 0.5 ),
    (tacticText = "revert s1", confidence = 0.5),
    ( tacticText = "unfold Subset",
      confidence = 0.5 ),
    ( tacticText = "unfold inter",
      confidence = 0.5 ),
    (tacticText = "revert s2", confidence = 0.5) ] )
STATE
s1 : tree, s2 : tree, H : (Ok s1) |- (Ok s2 -> Ok (inter s1 s2) /\ (forall y : elt, InT y (inter s1 s2) <-> InT y s1 /\ InT y s2))
----
s1 : tree, s2 : tree, H : (Ok s1) |- (Ok s2 -> Ok (inter s1 s2) /\ (forall y : elt, InT y (inter s1 s2) <-> InT y s1 /\ InT y s2)) OUTPUT
intros ?
intros
simpl
induction s1
intuition
split
revert s1
intuition_in
simpl inter
induction s2
Prediction takes 0.05487942695617676 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "induction s1",
      confidence = 0.5 ),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "split", confidence = 0.5),
    (tacticText = "revert s1", confidence = 0.5),
    ( tacticText = "intuition_in",
      confidence = 0.5 ),
    ( tacticText = "simpl inter",
      confidence = 0.5 ),
    ( tacticText = "induction s2",
      confidence = 0.5 ) ] )
STATE
s1 : tree, s2 : tree, H : (Ok s1), H0 : (Ok s2) |- (Ok (inter s1 s2) /\ (forall y : elt, InT y (inter s1 s2) <-> InT y s1 /\ InT y s2))
----
s1 : tree, s2 : tree, H : (Ok s1), H0 : (Ok s2) |- (Ok (inter s1 s2) /\ (forall y : elt, InT y (inter s1 s2) <-> InT y s1 /\ InT y s2)) OUTPUT
split
intros
rewrite inter_spec
intros ?
unfold inter
auto
intuition
unfold Subset
simpl inter_spec
apply inter_ok
Prediction takes 0.06186199188232422 seconds
Model Loaded
0
STATE
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), n : nat, lmp : (list (Mon * Pol)), subst_l := (fun P : Pol => PNSubstL P lmp n n) : (Pol -> Pol), Pmul_subst := (fun P1 P2 : Pol => subst_l (P1 ** P2)) : (Pol -> Pol -> Pol), Ppow_subst := (Ppow_N subst_l) : (Pol -> N -> Pol), l : (Env R), pe : PExpr |- (PEeval l pe == (norm_aux pe) @ l)
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), n : nat, lmp : (list (Mon * Pol)), subst_l := (fun P : Pol => PNSubstL P lmp n n) : (Pol -> Pol), Pmul_subst := (fun P1 P2 : Pol => subst_l (P1 ** P2)) : (Pol -> Pol -> Pol), Ppow_subst := (Ppow_N subst_l) : (Pol -> N -> Pol), l : (Env R), pe : PExpr |- (PEeval l pe == (norm_aux pe) @ l) OUTPUT
simpl
easy
rewrite IHpe
rewrite Padd_ok
reflexivity
Esimpl
revert pe
rewrite norm_ok
trivial
induction pe
Prediction takes 2.8631856441497803 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite IHpe",
      confidence = 0.5 ),
    ( tacticText = "rewrite Padd_ok",
      confidence = 0.5 ),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "Esimpl", confidence = 0.5),
    (tacticText = "revert pe", confidence = 0.5),
    ( tacticText = "rewrite norm_ok",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "induction pe",
      confidence = 0.5 ) ] )
STATE
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), n : nat, lmp : (list (Mon * Pol)), subst_l := (fun P : Pol => PNSubstL P lmp n n) : (Pol -> Pol), Pmul_subst := (fun P1 P2 : Pol => subst_l (P1 ** P2)) : (Pol -> Pol -> Pol), Ppow_subst := (Ppow_N subst_l) : (Pol -> N -> Pol), l : (Env R), pe : PExpr |- (PEeval l pe == (norm_aux pe) @ l)
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), n : nat, lmp : (list (Mon * Pol)), subst_l := (fun P : Pol => PNSubstL P lmp n n) : (Pol -> Pol), Pmul_subst := (fun P1 P2 : Pol => subst_l (P1 ** P2)) : (Pol -> Pol -> Pol), Ppow_subst := (Ppow_N subst_l) : (Pol -> N -> Pol), l : (Env R), pe : PExpr |- (PEeval l pe == (norm_aux pe) @ l) OUTPUT
simpl
easy
rewrite IHpe
rewrite Padd_ok
reflexivity
Esimpl
revert pe
rewrite norm_ok
trivial
induction pe
Prediction takes 0.0700223445892334 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite IHpe",
      confidence = 0.5 ),
    ( tacticText = "rewrite Padd_ok",
      confidence = 0.5 ),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "Esimpl", confidence = 0.5),
    (tacticText = "revert pe", confidence = 0.5),
    ( tacticText = "rewrite norm_ok",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "induction pe",
      confidence = 0.5 ) ] )
STATE
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), n : nat, lmp : (list (Mon * Pol)), subst_l := (fun P : Pol => PNSubstL P lmp n n) : (Pol -> Pol), Pmul_subst := (fun P1 P2 : Pol => subst_l (P1 ** P2)) : (Pol -> Pol -> Pol), Ppow_subst := (Ppow_N subst_l) : (Pol -> N -> Pol), l : (Env R), pe : PExpr |- (PEeval l pe == (norm_aux pe) @ l)
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), n : nat, lmp : (list (Mon * Pol)), subst_l := (fun P : Pol => PNSubstL P lmp n n) : (Pol -> Pol), Pmul_subst := (fun P1 P2 : Pol => subst_l (P1 ** P2)) : (Pol -> Pol -> Pol), Ppow_subst := (Ppow_N subst_l) : (Pol -> N -> Pol), l : (Env R), pe : PExpr |- (PEeval l pe == (norm_aux pe) @ l) OUTPUT
simpl
easy
rewrite IHpe
rewrite Padd_ok
reflexivity
Esimpl
revert pe
rewrite norm_ok
trivial
induction pe
Prediction takes 0.0770876407623291 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite IHpe",
      confidence = 0.5 ),
    ( tacticText = "rewrite Padd_ok",
      confidence = 0.5 ),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "Esimpl", confidence = 0.5),
    (tacticText = "revert pe", confidence = 0.5),
    ( tacticText = "rewrite norm_ok",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "induction pe",
      confidence = 0.5 ) ] )
STATE
s : t, s' : t, H : ((fix compare (m m' : t) {struct m} : comparison := match m with | Leaf => if is_empty m' then Eq else Lt | Node l o r => match m' with | Leaf => if is_empty m then Eq else Gt | Node l' o' r' => lex (compare_bool o o') (lex (compare l l') (compare r r')) end end) s s' = Eq) |- (eq s s') OUTPUT
auto
unfold compare
simpl
destruct compare
apply compare_eq
rewrite compare_eq
destruct (compare_dec s s')
rewrite compare_eq_iff
rewrite <- compare_eq
rewrite <- compare_eq_iff
Prediction takes 0.1094980239868164 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold compare",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct compare",
      confidence = 0.5 ),
    ( tacticText = "apply compare_eq",
      confidence = 0.5 ),
    ( tacticText = "rewrite compare_eq",
      confidence = 0.5 ),
    ( tacticText = "destruct (compare_dec s s\')",
      confidence = 0.5 ),
    ( tacticText = "rewrite compare_eq_iff",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- compare_eq",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- compare_eq_iff",
      confidence = 0.5 ) ] )
STATE
s : t |- (forall s' : t, compare s s' = Eq -> eq s s')
----
s : t |- (forall s' : t, compare s s' = Eq -> eq s s') OUTPUT
intros ?
unfold compare
intros
induction s
unfold eq
unfold equal
intros until s
unfold s
unfold lt
unfold s'
Prediction takes 0.0568079948425293 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold compare",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction s",
      confidence = 0.5 ),
    (tacticText = "unfold eq", confidence = 0.5),
    ( tacticText = "unfold equal",
      confidence = 0.5 ),
    ( tacticText = "intros until s",
      confidence = 0.5 ),
    (tacticText = "unfold s", confidence = 0.5),
    (tacticText = "unfold lt", confidence = 0.5),
    ( tacticText = "unfold s\'",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), cdiv : (C -> C -> C * C), div_th : (div_theory req cadd cmul phi cdiv), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get_sign) |- (forall (n : nat) (lH : list (PExpr * PExpr)) (l : list R), interp_PElist l lH -> forall lmp : list (C * Mon * Pol), mk_monpol_list lH = lmp -> forall (pe : PExpr) (npe : Pol), norm_subst n lmp pe = npe -> PEeval l pe == Pphi_pow l npe)
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), cdiv : (C -> C -> C * C), div_th : (div_theory req cadd cmul phi cdiv), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get_sign) |- (forall (n : nat) (lH : list (PExpr * PExpr)) (l : list R), interp_PElist l lH -> forall lmp : list (C * Mon * Pol), mk_monpol_list lH = lmp -> forall (pe : PExpr) (npe : Pol), norm_subst n lmp pe = npe -> PEeval l pe == Pphi_pow l npe) OUTPUT
intros
intros ?
simpl
induction pe
induction n
intros until pe
destruct pe
auto
induction P
intros subst
Prediction takes 2.835348129272461 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "induction pe",
      confidence = 0.5 ),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    ( tacticText = "intros until pe",
      confidence = 0.5 ),
    ( tacticText = "destruct pe",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "induction P",
      confidence = 0.5 ),
    ( tacticText = "intros subst",
      confidence = 0.5 ) ] )
STATE
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), cdiv : (C -> C -> C * C), div_th : (div_theory req cadd cmul phi cdiv), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get_sign), n : nat, lH : (list (PExpr * PExpr)), l : (list R), H : (interp_PElist l lH), lmp : (list (C * Mon * Pol)), H0 : (mk_monpol_list lH = lmp), pe : PExpr, npe : Pol, H1 : (norm_subst n lmp pe = npe) |- (PEeval l pe == Pphi_pow l npe)
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), cdiv : (C -> C -> C * C), div_th : (div_theory req cadd cmul phi cdiv), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get_sign), n : nat, lH : (list (PExpr * PExpr)), l : (list R), H : (interp_PElist l lH), lmp : (list (C * Mon * Pol)), H0 : (mk_monpol_list lH = lmp), pe : PExpr, npe : Pol, H1 : (norm_subst n lmp pe = npe) |- (PEeval l pe == Pphi_pow l npe) OUTPUT
easy
simpl
rewrite H1
auto
Esimpl
trivial
reflexivity
rewrite <- H1
rewrite H
rewrite H0
Prediction takes 0.15262436866760254 seconds
( textPrediction = [
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "rewrite H1",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "Esimpl", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- H1",
      confidence = 0.5 ),
    (tacticText = "rewrite H", confidence = 0.5),
    ( tacticText = "rewrite H0",
      confidence = 0.5 ) ] )
STATE
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), cdiv : (C -> C -> C * C), div_th : (div_theory req cadd cmul phi cdiv), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get_sign), n : nat |- (forall (lH : list (PExpr * PExpr)) (l : list R), interp_PElist l lH -> forall lmp : list (C * Mon * Pol), mk_monpol_list lH = lmp -> forall (pe : PExpr) (npe : Pol), norm_subst n lmp pe = npe -> PEeval l pe == Pphi_pow l npe)
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), cdiv : (C -> C -> C * C), div_th : (div_theory req cadd cmul phi cdiv), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get_sign), n : nat |- (forall (lH : list (PExpr * PExpr)) (l : list R), interp_PElist l lH -> forall lmp : list (C * Mon * Pol), mk_monpol_list lH = lmp -> forall (pe : PExpr) (npe : Pol), norm_subst n lmp pe = npe -> PEeval l pe == Pphi_pow l npe) OUTPUT
intros
intros ?
simpl
intros until pe
induction pe
induction n
destruct pe
auto
intros until n
induction LM
Prediction takes 0.12723731994628906 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "intros until pe",
      confidence = 0.5 ),
    ( tacticText = "induction pe",
      confidence = 0.5 ),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    ( tacticText = "destruct pe",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "intros until n",
      confidence = 0.5 ),
    ( tacticText = "induction LM",
      confidence = 0.5 ) ] )
STATE
( textPrediction = [
    (tacticText = "split", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "rewrite inter_spec",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold inter",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    ( tacticText = "unfold Subset",
      confidence = 0.5 ),
    ( tacticText = "simpl inter_spec",
      confidence = 0.5 ),
    ( tacticText = "apply inter_ok",
      confidence = 0.5 ) ] )
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), n : nat, lmp : (list (Mon * Pol)), subst_l := (fun P : Pol => PNSubstL P lmp n n) : (Pol -> Pol), Pmul_subst := (fun P1 P2 : Pol => subst_l (P1 ** P2)) : (Pol -> Pol -> Pol), Ppow_subst := (Ppow_N subst_l) : (Pol -> N -> Pol), l : (Env R), pe : PExpr |- (PEeval l pe == (norm_aux pe) @ l)
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), n : nat, lmp : (list (Mon * Pol)), subst_l := (fun P : Pol => PNSubstL P lmp n n) : (Pol -> Pol), Pmul_subst := (fun P1 P2 : Pol => subst_l (P1 ** P2)) : (Pol -> Pol -> Pol), Ppow_subst := (Ppow_N subst_l) : (Pol -> N -> Pol), l : (Env R), pe : PExpr |- (PEeval l pe == (norm_aux pe) @ l) OUTPUT
simpl
easy
rewrite IHpe
rewrite Padd_ok
reflexivity
Esimpl
revert pe
rewrite norm_ok
trivial
induction pe
Prediction takes 0.07601094245910645 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite IHpe",
      confidence = 0.5 ),
    ( tacticText = "rewrite Padd_ok",
      confidence = 0.5 ),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "Esimpl", confidence = 0.5),
    (tacticText = "revert pe", confidence = 0.5),
    ( tacticText = "rewrite norm_ok",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "induction pe",
      confidence = 0.5 ) ] )
STATE
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), n : nat, lmp : (list (Mon * Pol)), subst_l := (fun P : Pol => PNSubstL P lmp n n) : (Pol -> Pol), Pmul_subst := (fun P1 P2 : Pol => subst_l (P1 ** P2)) : (Pol -> Pol -> Pol), Ppow_subst := (Ppow_N subst_l) : (Pol -> N -> Pol), l : (Env R) |- (forall pe : PExpr, PEeval l pe == (norm_aux pe) @ l)
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), n : nat, lmp : (list (Mon * Pol)), subst_l := (fun P : Pol => PNSubstL P lmp n n) : (Pol -> Pol), Pmul_subst := (fun P1 P2 : Pol => subst_l (P1 ** P2)) : (Pol -> Pol -> Pol), Ppow_subst := (Ppow_N subst_l) : (Pol -> N -> Pol), l : (Env R) |- (forall pe : PExpr, PEeval l pe == (norm_aux pe) @ l) OUTPUT
simpl
intros
induction pe
intros ?
intros until pe
trivial
destruct pe
induction P
auto
induction n
Prediction takes 0.06344032287597656 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction pe",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "intros until pe",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "destruct pe",
      confidence = 0.5 ),
    ( tacticText = "induction P",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "induction n",
      confidence = 0.5 ) ] )
STATE
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), n : nat, lmp : (list (Mon * Pol)), subst_l := (fun P : Pol => PNSubstL P lmp n n) : (Pol -> Pol), Pmul_subst := (fun P1 P2 : Pol => subst_l (P1 ** P2)) : (Pol -> Pol -> Pol), Ppow_subst := (Ppow_N subst_l) : (Pol -> N -> Pol), l : (Env R), pe : PExpr |- (PEeval l pe == (norm_aux pe) @ l)
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), n : nat, lmp : (list (Mon * Pol)), subst_l := (fun P : Pol => PNSubstL P lmp n n) : (Pol -> Pol), Pmul_subst := (fun P1 P2 : Pol => subst_l (P1 ** P2)) : (Pol -> Pol -> Pol), Ppow_subst := (Ppow_N subst_l) : (Pol -> N -> Pol), l : (Env R), pe : PExpr |- (PEeval l pe == (norm_aux pe) @ l) OUTPUT
simpl
easy
rewrite IHpe
rewrite Padd_ok
reflexivity
Esimpl
revert pe
rewrite norm_ok
trivial
induction pe
Prediction takes 0.07394886016845703 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite IHpe",
      confidence = 0.5 ),
    ( tacticText = "rewrite Padd_ok",
      confidence = 0.5 ),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "Esimpl", confidence = 0.5),
    (tacticText = "revert pe", confidence = 0.5),
    ( tacticText = "rewrite norm_ok",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "induction pe",
      confidence = 0.5 ) ] )
STATE
Model Loaded
0
STATE
n : Z, m : Z |- (n > m -> n + - m > 0)
----
n : Z, m : Z |- (n > m -> n + - m > 0) OUTPUT
intros ?
intros
rewrite sub_0_r
rewrite sub_0_l
apply Z.swap_swap
auto with zarith
apply Z.sub_le
Z.swap_greate
Z.swap_greflexivity
rewrite sub_0_le
Prediction takes 2.7731688022613525 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "rewrite sub_0_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_0_l",
      confidence = 0.5 ),
    ( tacticText = "apply Z.swap_swap",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    ( tacticText = "apply Z.sub_le",
      confidence = 0.5 ),
    ( tacticText = "Z.swap_greate",
      confidence = 0.5 ),
    ( tacticText = "Z.swap_greflexivity",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_0_le",
      confidence = 0.5 ) ] )
STATE
n : Z, m : Z, H : (n > m) |- (n + - m > 0)
----
n : Z, m : Z, H : (n > m) |- (n + - m > 0) OUTPUT
rewrite sub_0_r
rewrite sub_0_l
auto with real
rewrite sub_diag
lia
auto with zarith
rewrite opp_involutive
rewrite sub_0_le
rewrite sub_opp_r
apply sub_gt
Prediction takes 0.1356830596923828 seconds
( textPrediction = [
    ( tacticText = "rewrite sub_0_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_0_l",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_diag",
      confidence = 0.5 ),
    (tacticText = "lia", confidence = 0.5),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    ( tacticText = "rewrite opp_involutive",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_0_le",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_opp_r",
      confidence = 0.5 ),
    ( tacticText = "apply sub_gt",
      confidence = 0.5 ) ] )
STATE
n : Z, m : Z, H : (n > m) |- (n + - m > 0)
----
n : Z, m : Z, H : (n > m) |- (n + - m > 0) OUTPUT
rewrite sub_0_r
rewrite sub_0_l
auto with real
rewrite sub_diag
lia
auto with zarith
rewrite opp_involutive
rewrite sub_0_le
rewrite sub_opp_r
apply sub_gt
Prediction takes 0.20689105987548828 seconds
( textPrediction = [
    ( tacticText = "rewrite sub_0_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_0_l",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_diag",
      confidence = 0.5 ),
    (tacticText = "lia", confidence = 0.5),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    ( tacticText = "rewrite opp_involutive",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_0_le",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_opp_r",
      confidence = 0.5 ),
    ( tacticText = "apply sub_gt",
      confidence = 0.5 ) ] )
STATE
n : Z, m : Z |- (n > m -> n + - m > 0)
----
n : Z, m : Z |- (n > m -> n + - m > 0) OUTPUT
intros ?
intros
rewrite sub_0_r
rewrite sub_0_l
apply Z.swap_swap
auto with zarith
apply Z.sub_le
Z.swap_greate
Z.swap_greflexivity
rewrite sub_0_le
Prediction takes 0.16462469100952148 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "rewrite sub_0_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_0_l",
      confidence = 0.5 ),
    ( tacticText = "apply Z.swap_swap",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    ( tacticText = "apply Z.sub_le",
      confidence = 0.5 ),
    ( tacticText = "Z.swap_greate",
      confidence = 0.5 ),
    ( tacticText = "Z.swap_greflexivity",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_0_le",
      confidence = 0.5 ) ] )
STATE
n : Z, m : Z, H : (n > m) |- (n + - m > 0)
----
n : Z, m : Z, H : (n > m) |- (n + - m > 0) OUTPUT
rewrite sub_0_r
rewrite sub_0_l
auto with real
rewrite sub_diag
lia
auto with zarith
rewrite opp_involutive
rewrite sub_0_le
rewrite sub_opp_r
apply sub_gt
Prediction takes 0.12465190887451172 seconds
( textPrediction = [
    ( tacticText = "rewrite sub_0_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_0_l",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_diag",
      confidence = 0.5 ),
    (tacticText = "lia", confidence = 0.5),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    ( tacticText = "rewrite opp_involutive",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_0_le",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_opp_r",
      confidence = 0.5 ),
    ( tacticText = "apply sub_gt",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
starting proving server with connection through their stdin
using textmode optiontext
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), n : nat, lmp : (list (Mon * Pol)), subst_l := (fun P : Pol => PNSubstL P lmp n n) : (Pol -> Pol), Pmul_subst := (fun P1 P2 : Pol => subst_l (P1 ** P2)) : (Pol -> Pol -> Pol), Ppow_subst := (Ppow_N subst_l) : (Pol -> N -> Pol), l : (Env R) |- (forall pe : PExpr, PEeval l pe == (norm_aux pe) @ l)
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), n : nat, lmp : (list (Mon * Pol)), subst_l := (fun P : Pol => PNSubstL P lmp n n) : (Pol -> Pol), Pmul_subst := (fun P1 P2 : Pol => subst_l (P1 ** P2)) : (Pol -> Pol -> Pol), Ppow_subst := (Ppow_N subst_l) : (Pol -> N -> Pol), l : (Env R) |- (forall pe : PExpr, PEeval l pe == (norm_aux pe) @ l) OUTPUT
simpl
intros
induction pe
intros ?
intros until pe
trivial
destruct pe
induction P
auto
induction n
Prediction takes 0.06197857856750488 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction pe",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "intros until pe",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "destruct pe",
      confidence = 0.5 ),
    ( tacticText = "induction P",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "induction n",
      confidence = 0.5 ) ] )
STATE
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), n : nat, lmp : (list (Mon * Pol)), subst_l := (fun P : Pol => PNSubstL P lmp n n) : (Pol -> Pol), Pmul_subst := (fun P1 P2 : Pol => subst_l (P1 ** P2)) : (Pol -> Pol -> Pol), Ppow_subst := (Ppow_N subst_l) : (Pol -> N -> Pol), l : (Env R), pe : PExpr |- (PEeval l pe == (norm_aux pe) @ l)
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), n : nat, lmp : (list (Mon * Pol)), subst_l := (fun P : Pol => PNSubstL P lmp n n) : (Pol -> Pol), Pmul_subst := (fun P1 P2 : Pol => subst_l (P1 ** P2)) : (Pol -> Pol -> Pol), Ppow_subst := (Ppow_N subst_l) : (Pol -> N -> Pol), l : (Env R), pe : PExpr |- (PEeval l pe == (norm_aux pe) @ l) OUTPUT
simpl
easy
rewrite IHpe
rewrite Padd_ok
reflexivity
Esimpl
revert pe
rewrite norm_ok
trivial
induction pe
Prediction takes 0.06818222999572754 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite IHpe",
      confidence = 0.5 ),
    ( tacticText = "rewrite Padd_ok",
      confidence = 0.5 ),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "Esimpl", confidence = 0.5),
    (tacticText = "revert pe", confidence = 0.5),
    ( tacticText = "rewrite norm_ok",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "induction pe",
      confidence = 0.5 ) ] )
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), cdiv : (C -> C -> C * C), div_th : (div_theory req cadd cmul phi cdiv), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get_sign), n : nat, lH : (list (PExpr * PExpr)), l : (list R), H : (interp_PElist l lH), lmp : (list (C * Mon * Pol)), H0 : (mk_monpol_list lH = lmp), pe : PExpr, npe : Pol, H1 : (norm_subst n lmp pe = npe) |- (PEeval l pe == Pphi_pow l npe)
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), cdiv : (C -> C -> C * C), div_th : (div_theory req cadd cmul phi cdiv), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get_sign), n : nat, lH : (list (PExpr * PExpr)), l : (list R), H : (interp_PElist l lH), lmp : (list (C * Mon * Pol)), H0 : (mk_monpol_list lH = lmp), pe : PExpr, npe : Pol, H1 : (norm_subst n lmp pe = npe) |- (PEeval l pe == Pphi_pow l npe) OUTPUT
easy
simpl
rewrite H1
auto
Esimpl
trivial
reflexivity
rewrite <- H1
rewrite H
rewrite H0
Prediction takes 0.13338971138000488 seconds
( textPrediction = [
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "rewrite H1",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "Esimpl", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- H1",
      confidence = 0.5 ),
    (tacticText = "rewrite H", confidence = 0.5),
    ( tacticText = "rewrite H0",
      confidence = 0.5 ) ] )
STATE
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), cdiv : (C -> C -> C * C), div_th : (div_theory req cadd cmul phi cdiv), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get_sign), n : nat, lH : (list (PExpr * PExpr)) |- (forall l : list R, interp_PElist l lH -> forall lmp : list (C * Mon * Pol), mk_monpol_list lH = lmp -> forall (pe : PExpr) (npe : Pol), norm_subst n lmp pe = npe -> PEeval l pe == Pphi_pow l npe)
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), cdiv : (C -> C -> C * C), div_th : (div_theory req cadd cmul phi cdiv), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get_sign), n : nat, lH : (list (PExpr * PExpr)) |- (forall l : list R, interp_PElist l lH -> forall lmp : list (C * Mon * Pol), mk_monpol_list lH = lmp -> forall (pe : PExpr) (npe : Pol), norm_subst n lmp pe = npe -> PEeval l pe == Pphi_pow l npe) OUTPUT
intros
intros ?
simpl
intros until pe
induction n
induction pe
destruct pe
auto
intros until n
intros subst
Prediction takes 0.07507491111755371 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "intros until pe",
      confidence = 0.5 ),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    ( tacticText = "induction pe",
      confidence = 0.5 ),
    ( tacticText = "destruct pe",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "intros until n",
      confidence = 0.5 ),
    ( tacticText = "intros subst",
      confidence = 0.5 ) ] )
STATE
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), cdiv : (C -> C -> C * C), div_th : (div_theory req cadd cmul phi cdiv), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get_sign), n : nat, lH : (list (PExpr * PExpr)), l : (list R), H : (interp_PElist l lH), lmp : (list (C * Mon * Pol)), H0 : (mk_monpol_list lH = lmp) |- (forall npe : Pol, norm_subst n lmp PEO = npe -> PEeval l PEO == Pphi_pow l npe)
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), cdiv : (C -> C -> C * C), div_th : (div_theory req cadd cmul phi cdiv), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get_sign), n : nat, lH : (list (PExpr * PExpr)), l : (list R), H : (interp_PElist l lH), lmp : (list (C * Mon * Pol)), H0 : (mk_monpol_list lH = lmp) |- (forall npe : Pol, norm_subst n lmp PEO = npe -> PEeval l PEO == Pphi_pow l npe) OUTPUT
intros
simpl
intros ?
auto
trivial
destruct pe
intros until pe
easy
induction n
intros until n
Prediction takes 0.09364676475524902 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "destruct pe",
      confidence = 0.5 ),
    ( tacticText = "intros until pe",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    ( tacticText = "intros until n",
      confidence = 0.5 ) ] )
STATE
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), cdiv : (C -> C -> C * C), div_th : (div_theory req cadd cmul phi cdiv), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get_sign) |- (forall (n : nat) (lH : list (PExpr * PExpr)) (l : list R), interp_PElist l lH -> forall lmp : list (C * Mon * Pol), mk_monpol_list lH = lmp -> forall (pe : PExpr) (npe : Pol), norm_subst n lmp pe = npe -> PEeval l pe == Pphi_pow l npe)
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), cdiv : (C -> C -> C * C), div_th : (div_theory req cadd cmul phi cdiv), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get_sign) |- (forall (n : nat) (lH : list (PExpr * PExpr)) (l : list R), interp_PElist l lH -> forall lmp : list (C * Mon * Pol), mk_monpol_list lH = lmp -> forall (pe : PExpr) (npe : Pol), norm_subst n lmp pe = npe -> PEeval l pe == Pphi_pow l npe) OUTPUT
intros
intros ?
simpl
induction pe
induction n
intros until pe
destruct pe
auto
induction P
intros subst
Prediction takes 0.10202193260192871 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "induction pe",
      confidence = 0.5 ),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    ( tacticText = "intros until pe",
      confidence = 0.5 ),
    ( tacticText = "destruct pe",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "induction P",
      confidence = 0.5 ),
    ( tacticText = "intros subst",
      confidence = 0.5 ) ] )
STATE
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), cdiv : (C -> C -> C * C), div_th : (div_theory req cadd cmul phi cdiv), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get_sign), n : nat, lH : (list (PExpr * PExpr)), l : (list R), H : (interp_PElist l lH), lmp : (list (C * Mon * Pol)), H0 : (mk_monpol_list lH = lmp), pe : PExpr, npe : Pol, H1 : (norm_subst n lmp pe = npe) |- (PEeval l pe == Pphi_pow l npe)
----
R : Type, rO : R, rI : R, radd : (R -> R -> R), rmul : (R -> R -> R), rsub : (R -> R -> R), ropp : (R -> R), req : (R -> R -> Prop), Rsth : (Equivalence req), Reqe : (ring_eq_ext radd rmul ropp req), ARth : (almost_ring_theory 0 1 radd rmul rsub ropp req), C : Type, cO : C, cI : C, cadd : (C -> C -> C), cmul : (C -> C -> C), csub : (C -> C -> C), copp : (C -> C), ceqb : (C -> C -> bool), phi : (C -> R), CRmorph : (ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp ceqb phi), Cpow : Type, Cp_phi : (N -> Cpow), rpow : (R -> Cpow -> R), pow_th : (power_theory 1 rmul req Cp_phi rpow), cdiv : (C -> C -> C * C), div_th : (div_theory req cadd cmul phi cdiv), get_sign : (C -> option C), get_sign_spec : (sign_theory copp ceqb get_sign), n : nat, lH : (list (PExpr * PExpr)), l : (list R), H : (interp_PElist l lH), lmp : (list (C * Mon * Pol)), H0 : (mk_monpol_list lH = lmp), pe : PExpr, npe : Pol, H1 : (norm_subst n lmp pe = npe) |- (PEeval l pe == Pphi_pow l npe) OUTPUT
easy
simpl
rewrite H1
auto
Esimpl
trivial
reflexivity
rewrite <- H1
rewrite H
rewrite H0
Prediction takes 0.08432269096374512 seconds
( textPrediction = [
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "rewrite H1",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "Esimpl", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- H1",
      confidence = 0.5 ),
    (tacticText = "rewrite H", confidence = 0.5),
    ( tacticText = "rewrite H0",
      confidence = 0.5 ) ] )
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
n : nat, t : tree |- (arbt n t -> notredred t -> rbt n t)
----
n : nat, t : tree |- (arbt n t -> notredred t -> rbt n t) OUTPUT
intros ?
auto
simpl
intros
constructor
inversion_clear 1
red
induction n
invrb
inversion_clear H
Prediction takes 2.7972216606140137 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    ( tacticText = "inversion_clear 1",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    (tacticText = "invrb", confidence = 0.5),
    ( tacticText = "inversion_clear H",
      confidence = 0.5 ) ] )
STATE
n : nat, t : tree, H : (arbt n t) |- (notredred t -> rbt n t)
----
n : nat, t : tree, H : (arbt n t) |- (notredred t -> rbt n t) OUTPUT
intros ?
auto
constructor
invrb
simpl
trivial
easy
intros
inversion H
red
Prediction takes 0.11667394638061523 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    (tacticText = "invrb", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "inversion H",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5) ] )
STATE
n : nat, t : tree, H : (arbt n t), H0 : (notredred t) |- (rbt n t)
----
n : nat, t : tree, H : (arbt n t), H0 : (notredred t) |- (rbt n t) OUTPUT
auto
constructor
invrb
inversion H0
trivial
ok
eauto
easy
inversion H
invred
Prediction takes 0.1643505096435547 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    (tacticText = "invrb", confidence = 0.5),
    ( tacticText = "inversion H0",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "ok", confidence = 0.5),
    (tacticText = "eauto", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "inversion H",
      confidence = 0.5 ),
    (tacticText = "invred", confidence = 0.5) ] )
STATE
n : nat, t : tree, H : (arbt n t), H0 : (notredred t) |- (rbt n t)
----
n : nat, t : tree, H : (arbt n t), H0 : (notredred t) |- (rbt n t) OUTPUT
auto
constructor
invrb
inversion H0
trivial
ok
eauto
easy
inversion H
invred
Prediction takes 0.11859655380249023 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    (tacticText = "invrb", confidence = 0.5),
    ( tacticText = "inversion H0",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "ok", confidence = 0.5),
    (tacticText = "eauto", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "inversion H",
      confidence = 0.5 ),
    (tacticText = "invred", confidence = 0.5) ] )
STATE
n : nat, t : tree |- (arbt n t -> notredred t -> rbt n t)
----
n : nat, t : tree |- (arbt n t -> notredred t -> rbt n t) OUTPUT
intros ?
auto
simpl
intros
constructor
inversion_clear 1
red
induction n
invrb
inversion_clear H
Prediction takes 0.16925597190856934 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    ( tacticText = "inversion_clear 1",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    (tacticText = "invrb", confidence = 0.5),
    ( tacticText = "inversion_clear H",
      confidence = 0.5 ) ] )
STATE
n : nat, t : tree, H : (arbt n t) |- (notredred t -> rbt n t)
----
n : nat, t : tree, H : (arbt n t) |- (notredred t -> rbt n t) OUTPUT
intros ?
auto
constructor
invrb
simpl
trivial
easy
intros
inversion H
red
Prediction takes 0.08996224403381348 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    (tacticText = "invrb", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "inversion H",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5) ] )
STATE
n : nat, t : tree, H : (arbt n t), H0 : (notredred t) |- (rbt n t)
----
n : nat, t : tree, H : (arbt n t), H0 : (notredred t) |- (rbt n t) OUTPUT
auto
constructor
invrb
inversion H0
trivial
ok
eauto
easy
inversion H
invred
Prediction takes 0.11419510841369629 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    (tacticText = "invrb", confidence = 0.5),
    ( tacticText = "inversion H0",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "ok", confidence = 0.5),
    (tacticText = "eauto", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "inversion H",
      confidence = 0.5 ),
    (tacticText = "invred", confidence = 0.5) ] )
STATE
n : nat, t : tree, H : (arbt n t), H0 : (notredred t) |- (rbt n t)
----
n : nat, t : tree, H : (arbt n t), H0 : (notredred t) |- (rbt n t) OUTPUT
auto
constructor
invrb
inversion H0
trivial
ok
eauto
easy
inversion H
invred
Prediction takes 0.10382866859436035 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    (tacticText = "invrb", confidence = 0.5),
    ( tacticText = "inversion H0",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "ok", confidence = 0.5),
    (tacticText = "eauto", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "inversion H",
      confidence = 0.5 ),
    (tacticText = "invred", confidence = 0.5) ] )
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
i : Z, j : Z |- ({i >= j} + {i < j})
----
i : Z, j : Z |- ({i >= j} + {i < j}) OUTPUT
left
right
intros ?
auto with zarith
apply Z.lt_ge
apply Z.lt_dec
generalize (i / j)
apply Z.lt_le
apply Z_lt_dec
unfold Z.lt
Prediction takes 2.87081241607666 seconds
( textPrediction = [
    (tacticText = "left", confidence = 0.5),
    (tacticText = "right", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_ge",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_dec",
      confidence = 0.5 ),
    ( tacticText = "generalize (i / j)",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_le",
      confidence = 0.5 ),
    ( tacticText = "apply Z_lt_dec",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.lt",
      confidence = 0.5 ) ] )
STATE
i : Z, j : Z |- (i >= j)
----
i : Z, j : Z |- (i >= j) OUTPUT
auto with zarith
easy
auto
lia
Z.order
order
intros ?
constructor
Z.compare
Z.le
Prediction takes 0.05324530601501465 seconds
( textPrediction = [
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "lia", confidence = 0.5),
    (tacticText = "Z.order", confidence = 0.5),
    (tacticText = "order", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    (tacticText = "Z.compare", confidence = 0.5),
    (tacticText = "Z.le", confidence = 0.5) ] )
STATE
i : Z, j : Z |- (i < j)
----
i : Z, j : Z |- (i < j) OUTPUT
easy
auto with zarith
auto
apply Z.lt_trans
apply Z.lt_ge
apply Z.lt_le
assumption
lia
destruct j
trivial
Prediction takes 0.11451387405395508 seconds
( textPrediction = [
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "apply Z.lt_trans",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_ge",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_le",
      confidence = 0.5 ),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    (tacticText = "lia", confidence = 0.5),
    ( tacticText = "destruct j",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5) ] )
STATE
i : Z, j : Z |- ({i >= j} + {i < j})
----
i : Z, j : Z |- ({i >= j} + {i < j}) OUTPUT
left
right
intros ?
auto with zarith
apply Z.lt_ge
apply Z.lt_dec
generalize (i / j)
apply Z.lt_le
apply Z_lt_dec
unfold Z.lt
Prediction takes 0.1496274471282959 seconds
( textPrediction = [
    (tacticText = "left", confidence = 0.5),
    (tacticText = "right", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_ge",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_dec",
      confidence = 0.5 ),
    ( tacticText = "generalize (i / j)",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_le",
      confidence = 0.5 ),
    ( tacticText = "apply Z_lt_dec",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.lt",
      confidence = 0.5 ) ] )
STATE
i : Z, j : Z |- (i >= j)
----
i : Z, j : Z |- (i >= j) OUTPUT
auto with zarith
easy
auto
lia
Z.order
order
intros ?
constructor
Z.compare
Z.le
Prediction takes 0.09041380882263184 seconds
( textPrediction = [
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "lia", confidence = 0.5),
    (tacticText = "Z.order", confidence = 0.5),
    (tacticText = "order", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    (tacticText = "Z.compare", confidence = 0.5),
    (tacticText = "Z.le", confidence = 0.5) ] )
Model Loaded
0
STATE
 |- (Reflexive nat le)
----
 |- (Reflexive nat le) OUTPUT
exact le_refl
red
exact le_trans
auto with *
intros ?
constructor
apply le_refl
unfold le
firstorder
exact le_irrefl
Prediction takes 2.6803290843963623 seconds
( textPrediction = [
    ( tacticText = "exact le_refl",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "exact le_trans",
      confidence = 0.5 ),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    ( tacticText = "apply le_refl",
      confidence = 0.5 ),
    (tacticText = "unfold le", confidence = 0.5),
    ( tacticText = "firstorder",
      confidence = 0.5 ),
    ( tacticText = "exact le_irrefl",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
 |- (Empty empty)
----
 |- (Empty empty) OUTPUT
unfold Empty
auto
intros ?
constructor
red
auto with *
intros
auto with arith
auto with set
auto with sets
Prediction takes 2.9454030990600586 seconds
( textPrediction = [
    ( tacticText = "unfold Empty",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "auto with arith",
      confidence = 0.5 ),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    ( tacticText = "auto with sets",
      confidence = 0.5 ) ] )
STATE
 |- (forall a : elt, ~ In a empty)
----
 |- (forall a : elt, ~ In a empty) OUTPUT
intros
intros ?
red
auto
firstorder
unfold empty
inversion 1
unfold Empty
constructor
unfold empty_empty
Prediction takes 0.17035293579101562 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "firstorder",
      confidence = 0.5 ),
    ( tacticText = "unfold empty",
      confidence = 0.5 ),
    ( tacticText = "inversion 1",
      confidence = 0.5 ),
    ( tacticText = "unfold Empty",
      confidence = 0.5 ),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    ( tacticText = "unfold empty_empty",
      confidence = 0.5 ) ] )
STATE
a : elt |- (~ In a empty)
----
a : elt |- (~ In a empty) OUTPUT
intros ?
split
intuition
auto
auto with *
constructor
red
easy
auto with set
auto with relations
Prediction takes 0.09779620170593262 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "split", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "auto with set",
      confidence = 0.5 ),
    ( tacticText = "auto with relations",
      confidence = 0.5 ) ] )
STATE
a : elt, H : (In a empty) |- False
----
a : elt, H : (In a empty) |- False OUTPUT
inv
inversion H
discriminate
apply (H a)
apply H
elim (H a)
auto
elim H
rewrite H
generalize (H a)
Prediction takes 0.09000134468078613 seconds
( textPrediction = [
    (tacticText = "inv", confidence = 0.5),
    ( tacticText = "inversion H",
      confidence = 0.5 ),
    ( tacticText = "discriminate",
      confidence = 0.5 ),
    ( tacticText = "apply (H a)",
      confidence = 0.5 ),
    (tacticText = "apply H", confidence = 0.5),
    ( tacticText = "elim (H a)",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "elim H", confidence = 0.5),
    (tacticText = "rewrite H", confidence = 0.5),
    ( tacticText = "generalize (H a)",
      confidence = 0.5 ) ] )
Model Loaded
0
STATE
n : Z, m : Z |- (0 <= m -> Z.abs_N (n ^ m) = (Z.abs_N n ^ Z.abs_N m)%N)
----
n : Z, m : Z |- (0 <= m -> Z.abs_N (n ^ m) = (Z.abs_N n ^ Z.abs_N m)%N) OUTPUT
intros ?
intros
destruct n
apply Z.abs_nonneg
trivial
auto
destruct m
easy
unfold Z.abs_N
apply Z.abs_N
Prediction takes 3.4044699668884277 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "destruct n",
      confidence = 0.5 ),
    ( tacticText = "apply Z.abs_nonneg",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "destruct m",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "unfold Z.abs_N",
      confidence = 0.5 ),
    ( tacticText = "apply Z.abs_N",
      confidence = 0.5 ) ] )
STATE
n : Z, m : Z, H : (0 <= m) |- (Z.abs_N (n ^ m) = (Z.abs_N n ^ Z.abs_N m)%N)
----
n : Z, m : Z, H : (0 <= m) |- (Z.abs_N (n ^ m) = (Z.abs_N n ^ Z.abs_N m)%N) OUTPUT
apply Z.abs_nonneg
symmetry
easy
rewrite Z.mul_1_l
rewrite Z.mul_opp_l
apply Z.mul_nonneg
apply Z.abs_N_nonneg
rewrite Z.abs_N_N
rewrite (Z.mul_1_l m)
destruct (Z.abs_N n)
Prediction takes 0.14394569396972656 seconds
( textPrediction = [
    ( tacticText = "apply Z.abs_nonneg",
      confidence = 0.5 ),
    (tacticText = "symmetry", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite Z.mul_1_l",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.mul_opp_l",
      confidence = 0.5 ),
    ( tacticText = "apply Z.mul_nonneg",
      confidence = 0.5 ),
    ( tacticText = "apply Z.abs_N_nonneg",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.abs_N_N",
      confidence = 0.5 ),
    ( tacticText = "rewrite (Z.mul_1_l m)",
      confidence = 0.5 ),
    ( tacticText = "destruct (Z.abs_N n)",
      confidence = 0.5 ) ] )
STATE
n : Z, m : Z, H : (0 <= m) |- ((Z.abs_N n ^ Z.abs_N m)%N = Z.abs_N (n ^ m))
----
n : Z, m : Z, H : (0 <= m) |- ((Z.abs_N n ^ Z.abs_N m)%N = Z.abs_N (n ^ m)) OUTPUT
apply Z.abs_nonneg
easy
symmetry
rewrite pow_abs_r
rewrite Z.abs_N_N
apply pow_nonneg
rewrite Z.abs_N
destruct (Z.abs_N n)
rewrite (Z.abs_N n)
apply Z.abs_N_nonneg
Prediction takes 0.1300795078277588 seconds
( textPrediction = [
    ( tacticText = "apply Z.abs_nonneg",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "rewrite pow_abs_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.abs_N_N",
      confidence = 0.5 ),
    ( tacticText = "apply pow_nonneg",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.abs_N",
      confidence = 0.5 ),
    ( tacticText = "destruct (Z.abs_N n)",
      confidence = 0.5 ),
    ( tacticText = "rewrite (Z.abs_N n)",
      confidence = 0.5 ),
    ( tacticText = "apply Z.abs_N_nonneg",
      confidence = 0.5 ) ] )
STATE
n : Z, m : Z, H : (0 <= m) |- (Z.abs_N (n ^ m) = (Z.abs_N n ^ Z.abs_N m)%N)
----
n : Z, m : Z, H : (0 <= m) |- (Z.abs_N (n ^ m) = (Z.abs_N n ^ Z.abs_N m)%N) OUTPUT
apply Z.abs_nonneg
symmetry
easy
rewrite Z.mul_1_l
rewrite Z.mul_opp_l
apply Z.mul_nonneg
apply Z.abs_N_nonneg
rewrite Z.abs_N_N
rewrite (Z.mul_1_l m)
destruct (Z.abs_N n)
Prediction takes 0.1399991512298584 seconds
( textPrediction = [
    ( tacticText = "apply Z.abs_nonneg",
      confidence = 0.5 ),
    (tacticText = "symmetry", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite Z.mul_1_l",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.mul_opp_l",
      confidence = 0.5 ),
    ( tacticText = "apply Z.mul_nonneg",
      confidence = 0.5 ),
    ( tacticText = "apply Z.abs_N_nonneg",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.abs_N_N",
      confidence = 0.5 ),
    ( tacticText = "rewrite (Z.mul_1_l m)",
      confidence = 0.5 ),
    ( tacticText = "destruct (Z.abs_N n)",
      confidence = 0.5 ) ] )
STATE
n : Z, m : Z, H : (0 <= m) |- ((Z.abs_N n ^ Z.abs_N m)%N = Z.abs_N (n ^ m))
----
n : Z, m : Z, H : (0 <= m) |- ((Z.abs_N n ^ Z.abs_N m)%N = Z.abs_N (n ^ m)) OUTPUT
apply Z.abs_nonneg
easy
symmetry
rewrite pow_abs_r
rewrite Z.abs_N_N
apply pow_nonneg
rewrite Z.abs_N
destruct (Z.abs_N n)
rewrite (Z.abs_N n)
apply Z.abs_N_nonneg
Prediction takes 0.11623024940490723 seconds
( textPrediction = [
    ( tacticText = "apply Z.abs_nonneg",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "rewrite pow_abs_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.abs_N_N",
      confidence = 0.5 ),
    ( tacticText = "apply pow_nonneg",
      confidence = 0.5 ),
    ( tacticText = "rewrite Z.abs_N",
      confidence = 0.5 ),
    ( tacticText = "destruct (Z.abs_N n)",
      confidence = 0.5 ),
    ( tacticText = "rewrite (Z.abs_N n)",
      confidence = 0.5 ),
    ( tacticText = "apply Z.abs_N_nonneg",
      confidence = 0.5 ) ] )
STATE
m : Z |- (0 <= m -> Z.abs_N (0 ^ m) = (Z.abs_N 0 ^ Z.abs_N m)%N)
----
m : Z |- (0 <= m -> Z.abs_N (0 ^ m) = (Z.abs_N 0 ^ Z.abs_N m)%N) OUTPUT
destruct m
intros ?
intros
trivial
auto
simpl
easy
intros until m
unfold Z.abs
intros until n
Prediction takes 0.0630948543548584 seconds
( textPrediction = [
    ( tacticText = "destruct m",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "intros until m",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.abs",
      confidence = 0.5 ),
    ( tacticText = "intros until n",
      confidence = 0.5 ) ] )
STATE
n : nat, m : nat |- (Z.of_nat n = Z.of_nat m <-> n = m)
----
n : nat, m : nat |- (Z.of_nat n = Z.of_nat m <-> n = m) OUTPUT
split
symmetry
destruct n
unfold Z.of_nat
destruct m
apply Z.of_nat_nat
unfold Z.compare
apply Z.lt_le_incl
apply Z.lt_eq_cases
apply Z.of_nat
Prediction takes 0.10082721710205078 seconds
( textPrediction = [
    (tacticText = "split", confidence = 0.5),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "destruct n",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.of_nat",
      confidence = 0.5 ),
    ( tacticText = "destruct m",
      confidence = 0.5 ),
    ( tacticText = "apply Z.of_nat_nat",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.compare",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_le_incl",
      confidence = 0.5 ),
    ( tacticText = "apply Z.lt_eq_cases",
      confidence = 0.5 ),
    ( tacticText = "apply Z.of_nat",
      confidence = 0.5 ) ] )
STATE
n : nat, m : nat |- (Z.of_nat n = Z.of_nat m -> n = m)
----
n : nat, m : nat |- (Z.of_nat n = Z.of_nat m -> n = m) OUTPUT
induction n
destruct n
intros ?
intros
unfold Z.of_nat
auto
apply Z.of_nat
cbv[of_nat]
unfold Z.compare
cbv[of_nat n]
Prediction takes 0.11924219131469727 seconds
( textPrediction = [
    ( tacticText = "induction n",
      confidence = 0.5 ),
    ( tacticText = "destruct n",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold Z.of_nat",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "apply Z.of_nat",
      confidence = 0.5 ),
    ( tacticText = "cbv[of_nat]",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.compare",
      confidence = 0.5 ),
    ( tacticText = "cbv[of_nat n]",
      confidence = 0.5 ) ] )
STATE
m : nat |- (Z.of_nat 0 = Z.of_nat m -> 0%nat = m)
----
m : nat |- (Z.of_nat 0 = Z.of_nat m -> 0%nat = m) OUTPUT
destruct m
easy
intros
trivial
intros ?
auto
discriminate
simpl
unfold Z.eq
unfold Z.compare
Prediction takes 0.09458017349243164 seconds
starting proving server with connection through their stdin
using textmode optiontext
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
a : Z, b : Z |- (rem a (- b) = rem a b)
----
a : Z, b : Z |- (rem a (- b) = rem a b) OUTPUT
destruct (le_ge_cases a b)
rewrite rem_opp_r
destruct (le_gt_cases a b)
rewrite rem_opp_l
destruct (le_ge_cases a 0)
symmetry
zero_or_not b
bitwise
destruct (le_gt_cases a 0)
apply rem_opp_l
Prediction takes 2.9061830043792725 seconds
( textPrediction = [
    ( tacticText = "destruct (le_ge_cases a b)",
      confidence = 0.5 ),
    ( tacticText = "rewrite rem_opp_r",
      confidence = 0.5 ),
    ( tacticText = "destruct (le_gt_cases a b)",
      confidence = 0.5 ),
    ( tacticText = "rewrite rem_opp_l",
      confidence = 0.5 ),
    ( tacticText = "destruct (le_ge_cases a 0)",
      confidence = 0.5 ),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "zero_or_not b",
      confidence = 0.5 ),
    (tacticText = "bitwise", confidence = 0.5),
    ( tacticText = "destruct (le_gt_cases a 0)",
      confidence = 0.5 ),
    ( tacticText = "apply rem_opp_l",
      confidence = 0.5 ) ] )
STATE
a : Z, b : Z, H : (a <= b) |- (rem a (- b) = rem a b)
----
a : Z, b : Z, H : (a <= b) |- (rem a (- b) = rem a b) OUTPUT
symmetry
rewrite rem_opp_r
destruct (le_gt_cases a b)
destruct (le_ge_cases a b)
rewrite rem_opp_l
rewrite rem_eq
apply rem_unique with a
rewrite rem_opp
destruct (le_ge_cases a 0)
destruct (le_gt_cases a 0)
Prediction takes 0.1706409454345703 seconds
( textPrediction = [
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "rewrite rem_opp_r",
      confidence = 0.5 ),
    ( tacticText = "destruct (le_gt_cases a b)",
      confidence = 0.5 ),
    ( tacticText = "destruct (le_ge_cases a b)",
      confidence = 0.5 ),
    ( tacticText = "rewrite rem_opp_l",
      confidence = 0.5 ),
    ( tacticText = "rewrite rem_eq",
      confidence = 0.5 ),
    ( tacticText = "apply rem_unique with a",
      confidence = 0.5 ),
    ( tacticText = "rewrite rem_opp",
      confidence = 0.5 ),
    ( tacticText = "destruct (le_ge_cases a 0)",
      confidence = 0.5 ),
    ( tacticText = "destruct (le_gt_cases a 0)",
      confidence = 0.5 ) ] )
STATE
a : Z, b : Z, H : (a <= b) |- (rem a b = rem a (- b))
----
a : Z, b : Z, H : (a <= b) |- (rem a b = rem a (- b)) OUTPUT
symmetry
rewrite rem_opp_r
rewrite rem_opp_l
destruct (le_gt_cases a b)
destruct (le_ge_cases a b)
apply Private_Div.NZQuot.mod_le
apply rem_le
apply rem_unique with a
destruct (le_gt_cases a 0)
apply Private_Div.NZQuot.mod_small
Prediction takes 0.19524908065795898 seconds
( textPrediction = [
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "rewrite rem_opp_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite rem_opp_l",
      confidence = 0.5 ),
    ( tacticText = "destruct (le_gt_cases a b)",
      confidence = 0.5 ),
    ( tacticText = "destruct (le_ge_cases a b)",
      confidence = 0.5 ),
    ( tacticText = "apply Private_Div.NZQuot.mod_le",
      confidence = 0.5 ),
    ( tacticText = "apply rem_le",
      confidence = 0.5 ),
    ( tacticText = "apply rem_unique with a",
      confidence = 0.5 ),
    ( tacticText = "destruct (le_gt_cases a 0)",
      confidence = 0.5 ),
    ( tacticText = "apply Private_Div.NZQuot.mod_small",
      confidence = 0.5 ) ] )
STATE
a : Z, b : Z, H : (a <= b) |- (rem a (- b) = rem a b)
----
a : Z, b : Z, H : (a <= b) |- (rem a (- b) = rem a b) OUTPUT
symmetry
rewrite rem_opp_r
destruct (le_gt_cases a b)
destruct (le_ge_cases a b)
rewrite rem_opp_l
rewrite rem_eq
apply rem_unique with a
rewrite rem_opp
destruct (le_ge_cases a 0)
destruct (le_gt_cases a 0)
Prediction takes 0.1593611240386963 seconds
( textPrediction = [
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "rewrite rem_opp_r",
      confidence = 0.5 ),
    ( tacticText = "destruct (le_gt_cases a b)",
      confidence = 0.5 ),
    ( tacticText = "destruct (le_ge_cases a b)",
      confidence = 0.5 ),
    ( tacticText = "rewrite rem_opp_l",
      confidence = 0.5 ),
    ( tacticText = "rewrite rem_eq",
      confidence = 0.5 ),
    ( tacticText = "apply rem_unique with a",
      confidence = 0.5 ),
    ( tacticText = "rewrite rem_opp",
      confidence = 0.5 ),
    ( tacticText = "destruct (le_ge_cases a 0)",
      confidence = 0.5 ),
    ( tacticText = "destruct (le_gt_cases a 0)",
      confidence = 0.5 ) ] )
STATE
a : Z, b : Z, H : (a <= b) |- (rem a b = rem a (- b))
----
a : Z, b : Z, H : (a <= b) |- (rem a b = rem a (- b)) OUTPUT
symmetry
rewrite rem_opp_r
rewrite rem_opp_l
destruct (le_gt_cases a b)
destruct (le_ge_cases a b)
apply Private_Div.NZQuot.mod_le
apply rem_le
apply rem_unique with a
destruct (le_gt_cases a 0)
apply Private_Div.NZQuot.mod_small
Prediction takes 0.13628602027893066 seconds
( textPrediction = [
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "rewrite rem_opp_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite rem_opp_l",
      confidence = 0.5 ),
    ( tacticText = "destruct (le_gt_cases a b)",
      confidence = 0.5 ),
    ( tacticText = "destruct (le_ge_cases a b)",
      confidence = 0.5 ),
    ( tacticText = "apply Private_Div.NZQuot.mod_le",
      confidence = 0.5 ),
    ( tacticText = "apply rem_le",
      confidence = 0.5 ),
    ( tacticText = "apply rem_unique with a",
      confidence = 0.5 ),
    ( tacticText = "destruct (le_gt_cases a 0)",
      confidence = 0.5 ),
    ( tacticText = "apply Private_Div.NZQuot.mod_small",
      confidence = 0.5 ) ] )
STATE
a : Z, b : Z, H : (a <= b) |- (rem a (- b) = rem a b)
----
a : Z, b : Z, H : (a <= b) |- (rem a (- b) = rem a b) OUTPUT
symmetry
rewrite rem_opp_r
destruct (le_gt_cases a b)
destruct (le_ge_cases a b)
rewrite rem_opp_l
rewrite rem_eq
apply rem_unique with a
rewrite rem_opp
destruct (le_ge_cases a 0)
destruct (le_gt_cases a 0)
Prediction takes 0.11861586570739746 seconds
( textPrediction = [
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "rewrite rem_opp_r",
      confidence = 0.5 ),
    ( tacticText = "destruct (le_gt_cases a b)",
      confidence = 0.5 ),
    ( tacticText = "destruct (le_ge_cases a b)",
      confidence = 0.5 ),
    ( tacticText = "rewrite rem_opp_l",
      confidence = 0.5 ),
    ( tacticText = "rewrite rem_eq",
      confidence = 0.5 ),
    ( tacticText = "apply rem_unique with a",
      confidence = 0.5 ),
    ( tacticText = "rewrite rem_opp",
      confidence = 0.5 ),
    ( tacticText = "destruct (le_ge_cases a 0)",
      confidence = 0.5 ),
    ( tacticText = "destruct (le_gt_cases a 0)",
      confidence = 0.5 ) ] )
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
 |- (forall n m : t, (n << m) = false <-> m <= n)
----
 |- (forall n m : t, (n << m) = false <-> m <= n) OUTPUT
intros ?
intros
split
intros until n
cases n
unfold le
unfold eq
unfold le_antisym
apply eq_refl
cases n)
Prediction takes 2.7616653442382812 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "intros until n",
      confidence = 0.5 ),
    (tacticText = "cases n", confidence = 0.5),
    (tacticText = "unfold le", confidence = 0.5),
    (tacticText = "unfold eq", confidence = 0.5),
    ( tacticText = "unfold le_antisym",
      confidence = 0.5 ),
    ( tacticText = "apply eq_refl",
      confidence = 0.5 ),
    (tacticText = "cases n)", confidence = 0.5) ] )
STATE
n : t |- (forall m : t, (n << m) = false <-> m <= n)
----
n : t |- (forall m : t, (n << m) = false <-> m <= n) OUTPUT
intros ?
intros
split
cases n
intros until n
symmetry
apply le_refl
apply le_antisym
apply gt_le
cases
Prediction takes 0.08619403839111328 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "split", confidence = 0.5),
    (tacticText = "cases n", confidence = 0.5),
    ( tacticText = "intros until n",
      confidence = 0.5 ),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "apply le_refl",
      confidence = 0.5 ),
    ( tacticText = "apply le_antisym",
      confidence = 0.5 ),
    ( tacticText = "apply gt_le",
      confidence = 0.5 ),
    (tacticText = "cases", confidence = 0.5) ] )
STATE
n : t, m : t |- ((n << m) = false <-> m <= n)
----
n : t, m : t |- ((n << m) = false <-> m <= n) OUTPUT
rewrite lt_eq_cases
rewrite shiftr_spec
apply lt_le_incl
rewrite bits_false_iff
apply eq_refl
apply lt_true_iff
apply Z.le_antisym
rewrite bits_iff_iff
rewrite le_sub_iff
destruct (le_gt_cases m)
Prediction takes 0.14417386054992676 seconds
( textPrediction = [
    ( tacticText = "rewrite lt_eq_cases",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftr_spec",
      confidence = 0.5 ),
    ( tacticText = "apply lt_le_incl",
      confidence = 0.5 ),
    ( tacticText = "rewrite bits_false_iff",
      confidence = 0.5 ),
    ( tacticText = "apply eq_refl",
      confidence = 0.5 ),
    ( tacticText = "apply lt_true_iff",
      confidence = 0.5 ),
    ( tacticText = "apply Z.le_antisym",
      confidence = 0.5 ),
    ( tacticText = "rewrite bits_iff_iff",
      confidence = 0.5 ),
    ( tacticText = "rewrite le_sub_iff",
      confidence = 0.5 ),
    ( tacticText = "destruct (le_gt_cases m)",
      confidence = 0.5 ) ] )
STATE
n : t, m : t |- ((n << m) = false <-> m < n \/ m == n)
----
n : t, m : t |- ((n << m) = false <-> m < n \/ m == n) OUTPUT
destruct (lt_trichotomy n m)
cases n
rewrite shiftr_spec
rewrite lt_eq_cases
destruct (lt_trichotomy n 1)
destruct (lt_trichotomy n 0)
rewrite not_true_iff
rewrite ones_spec
rewrite not_false_iff
destruct (lt_trichotomy m n)
Prediction takes 0.10442996025085449 seconds
( textPrediction = [
    ( tacticText = "destruct (lt_trichotomy n m)",
      confidence = 0.5 ),
    (tacticText = "cases n", confidence = 0.5),
    ( tacticText = "rewrite shiftr_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite lt_eq_cases",
      confidence = 0.5 ),
    ( tacticText = "destruct (lt_trichotomy n 1)",
      confidence = 0.5 ),
    ( tacticText = "destruct (lt_trichotomy n 0)",
      confidence = 0.5 ),
    ( tacticText = "rewrite not_true_iff",
      confidence = 0.5 ),
    ( tacticText = "rewrite ones_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite not_false_iff",
      confidence = 0.5 ),
    ( tacticText = "destruct (lt_trichotomy m n)",
      confidence = 0.5 ) ] )
STATE
 |- (Proper (eq ==> eq ==> eq) pow)
----
 |- (Proper (eq ==> eq ==> eq) pow) OUTPUT
intros ?
red
auto with *
unfold eq
firstorder
unfold le
constructor
reflexivity
simpl
unfold le)
Prediction takes 0.06437468528747559 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    (tacticText = "unfold eq", confidence = 0.5),
    ( tacticText = "firstorder",
      confidence = 0.5 ),
    (tacticText = "unfold le", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold le)",
      confidence = 0.5 ) ] )
STATE
x : t |- (forall y : t, x == y -> (eq ==> eq)%signature (pow x) (pow y))
----
x : t |- (forall y : t, x == y -> (eq ==> eq)%signature (pow x) (pow y)) OUTPUT
intros ?
red
intros
unfold Qeq
unfold lxor
unfold log2
unfold lor
unfold land
unfold le
simpl
Prediction takes 0.06853294372558594 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold Qeq",
      confidence = 0.5 ),
    ( tacticText = "unfold lxor",
      confidence = 0.5 ),
    ( tacticText = "unfold log2",
      confidence = 0.5 ),
    ( tacticText = "unfold lor",
      confidence = 0.5 ),
    ( tacticText = "unfold land",
      confidence = 0.5 ),
    (tacticText = "unfold le", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5) ] )
STATE
x : t, y : t |- (x == y -> (eq ==> eq)%signature (pow x) (pow y))
----
x : t, y : t |- (x == y -> (eq ==> eq)%signature (pow x) (pow y)) OUTPUT
intros ?
red
intros
unfold Qeq
unfold lxor
apply log2_unique
trivial
apply compare_antisym
apply compare_eq_iff
apply log2_unique with x
Prediction takes 0.11694121360778809 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold Qeq",
      confidence = 0.5 ),
    ( tacticText = "unfold lxor",
      confidence = 0.5 ),
    ( tacticText = "apply log2_unique",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "apply compare_antisym",
      confidence = 0.5 ),
    ( tacticText = "apply compare_eq_iff",
      confidence = 0.5 ),
    ( tacticText = "apply log2_unique with x",
      confidence = 0.5 ) ] )
STATE
x : t, y : t, H : (x == y) |- ((eq ==> eq)%signature (pow x) (pow y))
----
x : t, y : t, H : (x == y) |- ((eq ==> eq)%signature (pow x) (pow y)) OUTPUT
intros ?
red
apply log2_unique
apply compare_eq_iff
apply compare_antisym
apply div_unique
destruct (eq_dec x y)
apply log2_unique with x
apply MO.eq_sym
apply MO.Private_OrderTac.order
Prediction takes 0.124481201171875 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "apply log2_unique",
      confidence = 0.5 ),
    ( tacticText = "apply compare_eq_iff",
      confidence = 0.5 ),
    ( tacticText = "apply compare_antisym",
      confidence = 0.5 ),
    ( tacticText = "apply div_unique",
      confidence = 0.5 ),
    ( tacticText = "destruct (eq_dec x y)",
      confidence = 0.5 ),
    ( tacticText = "apply log2_unique with x",
      confidence = 0.5 ),
    ( tacticText = "apply MO.eq_sym",
      confidence = 0.5 ),
    ( tacticText = "apply MO.Private_OrderTac.order",
      confidence = 0.5 ) ] )
STATE
x : t, y : t, H : (x == y), x0 : t |- (forall y0 : t, x0 == y0 -> x ^^ x0 == y ^^ y0)
----
x : t, y : t, H : (x == y), x0 : t |- (forall y0 : t, x0 == y0 -> x ^^ x0 == y ^^ y0) OUTPUT
intros ?
intros
clear H
trivial
red
subst
clear y
auto with real
clear x0
auto with zarith
Prediction takes 0.07149481773376465 seconds
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
( textPrediction = [
    ( tacticText = "destruct m",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "discriminate",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold Z.eq",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.compare",
      confidence = 0.5 ) ] )
STATE
 |- (Z.of_nat 0 = Z.of_nat 0 -> 0%nat = 0%nat)
----
 |- (Z.of_nat 0 = Z.of_nat 0 -> 0%nat = 0%nat) OUTPUT
intros
easy
discriminate
simpl
trivial
auto
intros ?
destruct 1
subst
intros until y
Prediction takes 0.062162160873413086 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "discriminate",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "destruct 1",
      confidence = 0.5 ),
    (tacticText = "subst", confidence = 0.5),
    ( tacticText = "intros until y",
      confidence = 0.5 ) ] )
STATE
H : (Z.of_nat 0 = Z.of_nat 0) |- (0%nat = 0%nat)
----
H : (Z.of_nat 0 = Z.of_nat 0) |- (0%nat = 0%nat) OUTPUT
easy
discriminate
subst
trivial
simpl
auto
reflexivity
lia
auto with real
rewrite <- H
Prediction takes 0.058164119720458984 seconds
( textPrediction = [
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "discriminate",
      confidence = 0.5 ),
    (tacticText = "subst", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "lia", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ) ] )
STATE
m : nat |- (Z.of_nat 0 = Z.of_nat (S m) -> 0%nat = S m)
----
m : nat |- (Z.of_nat 0 = Z.of_nat (S m) -> 0%nat = S m) OUTPUT
intros
intros ?
destruct m
simpl
easy
discriminate
intros until m
auto
trivial
intros until H
Prediction takes 0.05607795715332031 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "destruct m",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "discriminate",
      confidence = 0.5 ),
    ( tacticText = "intros until m",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "intros until H",
      confidence = 0.5 ) ] )
STATE
m : nat, H : (Z.of_nat 0 = Z.of_nat (S m)) |- (0%nat = S m)
----
m : nat, H : (Z.of_nat 0 = Z.of_nat (S m)) |- (0%nat = S m) OUTPUT
easy
discriminate
rewrite H
simpl
auto
f_equal
subst
symmetry
rewrite <- H
rewrite <- INR_0
Prediction takes 0.07592916488647461 seconds
( textPrediction = [
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "discriminate",
      confidence = 0.5 ),
    (tacticText = "rewrite H", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "f_equal", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- INR_0",
      confidence = 0.5 ) ] )
STATE
n : nat, m : nat, IHn : (Z.of_nat n = Z.of_nat m -> n = m) |- (Z.of_nat (S n) = Z.of_nat m -> S n = m)
----
n : nat, m : nat, IHn : (Z.of_nat n = Z.of_nat m -> n = m) |- (Z.of_nat (S n) = Z.of_nat m -> S n = m) OUTPUT
intros
intros ?
auto
simpl
easy
trivial
rewrite IHn
destruct n
intros until n
intros until m
Prediction takes 0.06252384185791016 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "rewrite IHn",
      confidence = 0.5 ),
    ( tacticText = "destruct n",
      confidence = 0.5 ),
    ( tacticText = "intros until n",
      confidence = 0.5 ),
    ( tacticText = "intros until m",
      confidence = 0.5 ) ] )
STATE
n : nat, m : nat, IHn : (Z.of_nat n = Z.of_nat m -> n = m), H : (Z.of_nat (S n) = Z.of_nat m) |- (S n = m)
----
n : nat, m : nat, IHn : (Z.of_nat n = Z.of_nat m -> n = m), H : (Z.of_nat (S n) = Z.of_nat m) |- (S n = m) OUTPUT
auto
easy
rewrite H
rewrite IHn
rewrite <- IHn
trivial
simpl
rewrite <- H
rewrite inj_compare
rewrite inj_succ
Prediction takes 0.07283186912536621 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "rewrite H", confidence = 0.5),
    ( tacticText = "rewrite IHn",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- IHn",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "rewrite inj_compare",
      confidence = 0.5 ),
    ( tacticText = "rewrite inj_succ",
      confidence = 0.5 ) ] )
STATE
m : nat |- (Z.of_nat 0 = Z.of_nat m -> 0%nat = m)
----
m : nat |- (Z.of_nat 0 = Z.of_nat m -> 0%nat = m) OUTPUT
destruct m
easy
intros
trivial
intros ?
auto
discriminate
simpl
unfold Z.eq
unfold Z.compare
Prediction takes 0.08074212074279785 seconds
( textPrediction = [
    ( tacticText = "destruct m",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "discriminate",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold Z.eq",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.compare",
      confidence = 0.5 ) ] )
STATE
p : positive |- (Z.abs_nat (Z.neg p) = Pos.to_nat p)
----
p : positive |- (Z.abs_nat (Z.neg p) = Pos.to_nat p) OUTPUT
easy
simpl
trivial
destruct p
reflexivity
symmetry
auto
unfold Z.abs
unfold Z.odd
unfold Z.max
Prediction takes 0.06781172752380371 seconds
( textPrediction = [
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "destruct p",
      confidence = 0.5 ),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "symmetry", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold Z.abs",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.odd",
      confidence = 0.5 ),
    ( tacticText = "unfold Z.max",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
A : Type, B : Type, RA : (relation A), RB : (relation B) |- (relation_equivalence (RA @@1) (RA * (fun _ _ : B => True)))
----
A : Type, B : Type, RA : (relation A), RB : (relation B) |- (relation_equivalence (RA @@1) (RA * (fun _ _ : B => True))) OUTPUT
firstorder
red
intros ?
simpl
split
constructor
unfold Symmetric
setoid_rewrite
exact (relation_equivalence)
setoid_replace Symmetric
Prediction takes 2.9570865631103516 seconds
( textPrediction = [
    ( tacticText = "firstorder",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    ( tacticText = "unfold Symmetric",
      confidence = 0.5 ),
    ( tacticText = "setoid_rewrite",
      confidence = 0.5 ),
    ( tacticText = "exact (relation_equivalence)",
      confidence = 0.5 ),
    ( tacticText = "setoid_replace Symmetric",
      confidence = 0.5 ) ] )
Model Loaded
0
STATE
elt : Type, k : key, k' : key, e : elt, e' : elt, l : (list (key * elt)) |- (InA eqk (k, e) ((k', e') :: l) -> ~ D.eq k k' -> InA eqk (k, e) l)
----
elt : Type, k : key, k' : key, e : elt, e' : elt, l : (list (key * elt)) |- (InA eqk (k, e) ((k', e') :: l) -> ~ D.eq k k' -> InA eqk (k, e) l) OUTPUT
inversion 1
intros ?
intuition
simpl
auto
compute in H
subst
inversion 2
compute
compute in Hk
Prediction takes 2.9931139945983887 seconds
( textPrediction = [
    ( tacticText = "inversion 1",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "compute in H",
      confidence = 0.5 ),
    (tacticText = "subst", confidence = 0.5),
    ( tacticText = "inversion 2",
      confidence = 0.5 ),
    (tacticText = "compute", confidence = 0.5),
    ( tacticText = "compute in Hk",
      confidence = 0.5 ) ] )
STATE
elt : Type, k : key, k' : key, e : elt, e' : elt, l : (list (key * elt)), H : (InA eqk (k, e) ((k', e') :: l)), y : (key * elt)%type, l0 : (list (key * elt)), H1 : (eqk (k, e) (k', e')), H0 : (y = (k', e')), H2 : (l0 = l) |- (~ D.eq k k' -> InA eqk (k, e) l)
----
elt : Type, k : key, k' : key, e : elt, e' : elt, l : (list (key * elt)), H : (InA eqk (k, e) ((k', e') :: l)), y : (key * elt)%type, l0 : (list (key * elt)), H1 : (eqk (k, e) (k', e')), H0 : (y = (k', e')), H2 : (l0 = l) |- (~ D.eq k k' -> InA eqk (k, e) l) OUTPUT
compute in H1
compute in H2
intros ?
auto
intuition
red in H1
compute in H0
compute in H
subst
red in H2
Prediction takes 0.07606267929077148 seconds
( textPrediction = [
    ( tacticText = "compute in H1",
      confidence = 0.5 ),
    ( tacticText = "compute in H2",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "red in H1", confidence = 0.5),
    ( tacticText = "compute in H0",
      confidence = 0.5 ),
    ( tacticText = "compute in H",
      confidence = 0.5 ),
    (tacticText = "subst", confidence = 0.5),
    (tacticText = "red in H2", confidence = 0.5) ] )
STATE
elt : Type, k : key, k' : key, e : elt, e' : elt, l : (list (key * elt)), H : (InA eqk (k, e) ((k', e') :: l)), y : (key * elt)%type, l0 : (list (key * elt)), H1 : (D.eq k k'), H0 : (y = (k', e')), H2 : (l0 = l) |- (~ D.eq k k' -> InA eqk (k, e) l)
----
elt : Type, k : key, k' : key, e : elt, e' : elt, l : (list (key * elt)), H : (InA eqk (k, e) ((k', e') :: l)), y : (key * elt)%type, l0 : (list (key * elt)), H1 : (D.eq k k'), H0 : (y = (k', e')), H2 : (l0 = l) |- (~ D.eq k k' -> InA eqk (k, e) l) OUTPUT
intros ?
intuition
auto
red
subst
compute in H
compute
eauto
red in H
eauto with *
Prediction takes 0.06162881851196289 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    ( tacticText = "compute in H",
      confidence = 0.5 ),
    (tacticText = "compute", confidence = 0.5),
    (tacticText = "eauto", confidence = 0.5),
    (tacticText = "red in H", confidence = 0.5),
    ( tacticText = "eauto with *",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "clear H", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    (tacticText = "clear y", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "clear x0", confidence = 0.5),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ) ] )
STATE
x : t, y : t, H : (x == y), x0 : t, y0 : t |- (x0 == y0 -> x ^^ x0 == y ^^ y0)
----
x : t, y : t, H : (x == y), x0 : t, y0 : t |- (x0 == y0 -> x ^^ x0 == y ^^ y0) OUTPUT
intros ?
trivial
intros
clear H
subst
simpl
easy
auto with zarith
rewrite <- H
auto with real
Prediction takes 0.05860495567321777 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "clear H", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "auto with real",
      confidence = 0.5 ) ] )
STATE
x : t, y : t, H : (x == y), x0 : t, y0 : t, H0 : (x0 == y0) |- (x ^^ x0 == y ^^ y0)
----
x : t, y : t, H : (x == y), x0 : t, y0 : t, H0 : (x0 == y0) |- (x ^^ x0 == y ^^ y0) OUTPUT
rewrite H0
rewrite H
subst
easy
rewrite <- H
trivial
symmetry
apply H0
reflexivity
apply H
Prediction takes 0.06042909622192383 seconds
( textPrediction = [
    ( tacticText = "rewrite H0",
      confidence = 0.5 ),
    (tacticText = "rewrite H", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "symmetry", confidence = 0.5),
    (tacticText = "apply H0", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "apply H", confidence = 0.5) ] )
STATE
x : t, y : t, H : (x == y), x0 : t, y0 : t, H0 : (x0 == y0) |- (x ^^ x0 == y ^^ y0)
----
x : t, y : t, H : (x == y), x0 : t, y0 : t, H0 : (x0 == y0) |- (x ^^ x0 == y ^^ y0) OUTPUT
rewrite H0
rewrite H
subst
easy
rewrite <- H
trivial
symmetry
apply H0
reflexivity
apply H
Prediction takes 0.06272220611572266 seconds
( textPrediction = [
    ( tacticText = "rewrite H0",
      confidence = 0.5 ),
    (tacticText = "rewrite H", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "symmetry", confidence = 0.5),
    (tacticText = "apply H0", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "apply H", confidence = 0.5) ] )
STATE
x : t, y : t, x0 : t |- (forall y0 : t, x0 == y0 -> x ^^ x0 == y ^^ y0)
----
x : t, y : t, x0 : t |- (forall y0 : t, x0 == y0 -> x ^^ x0 == y ^^ y0) OUTPUT
intros ?
intros
red
trivial
simpl
exact le_ind
unfold le
auto with real
auto with zarith
clear y0
Prediction takes 0.1181328296661377 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "exact le_ind",
      confidence = 0.5 ),
    (tacticText = "unfold le", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "clear y0", confidence = 0.5) ] )
STATE
x : t, y : t, H : (x == y) |- (forall x0 y0 : t, x0 == y0 -> x ^^ x0 == y ^^ y0)
----
x : t, y : t, H : (x == y) |- (forall x0 y0 : t, x0 == y0 -> x ^^ x0 == y ^^ y0) OUTPUT
intros ?
intros
clear H
trivial
auto with real
red
congruence
clear x0
auto with zarith
clear x
Prediction takes 0.057767629623413086 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "clear H", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "congruence",
      confidence = 0.5 ),
    (tacticText = "clear x0", confidence = 0.5),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "clear x", confidence = 0.5) ] )
STATE
x : t, y : t, H : (x == y), x0 : t |- (forall y0 : t, x0 == y0 -> x ^^ x0 == y ^^ y0)
----
x : t, y : t, H : (x == y), x0 : t |- (forall y0 : t, x0 == y0 -> x ^^ x0 == y ^^ y0) OUTPUT
intros ?
intros
clear H
trivial
red
subst
clear y
auto with real
clear x0
auto with zarith
Prediction takes 0.06939291954040527 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "clear H", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    (tacticText = "clear y", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    (tacticText = "clear x0", confidence = 0.5),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ) ] )
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
Env : Type, Term : Type, Term' : Type, Annot : Type, unsat : (Term' -> bool), deduce : (Term' -> Term' -> option Term'), normalise : (Term -> Annot -> cnf), negate : (Term -> Annot -> cnf), eval' : (Env -> Term' -> Prop), no_middle_eval' : (forall (env : Env) (d : Term'), eval' env d \/ ~ eval' env d), unsat_prop : (forall t : Term', unsat t = true -> forall env : Env, eval' env t -> False), deduce_prop : (forall t t' u : Term', deduce t t' = Some u -> forall env : Env, eval' env t -> eval' env t' -> eval' env u) |- (forall (env : Env) (a : list (Term' * Annot)) (f : cnf), ~ make_conj (eval_tt env) a /\ eval_cnf env f <-> eval_cnf env (a :: f))
----
Env : Type, Term : Type, Term' : Type, Annot : Type, unsat : (Term' -> bool), deduce : (Term' -> Term' -> option Term'), normalise : (Term -> Annot -> cnf), negate : (Term -> Annot -> cnf), eval' : (Env -> Term' -> Prop), no_middle_eval' : (forall (env : Env) (d : Term'), eval' env d \/ ~ eval' env d), unsat_prop : (forall t : Term', unsat t = true -> forall env : Env, eval' env t -> False), deduce_prop : (forall t t' u : Term', deduce t t' = Some u -> forall env : Env, eval' env t -> eval' env t' -> eval' env u) |- (forall (env : Env) (a : list (Term' * Annot)) (f : cnf), ~ make_conj (eval_tt env) a /\ eval_cnf env f <-> eval_cnf env (a :: f)) OUTPUT
intros
simpl
intros ?
induction f
intros until a
intros until pol
split
induction a
intros until f
induction cl
Prediction takes 2.914292335510254 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "induction f",
      confidence = 0.5 ),
    ( tacticText = "intros until a",
      confidence = 0.5 ),
    ( tacticText = "intros until pol",
      confidence = 0.5 ),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "induction a",
      confidence = 0.5 ),
    ( tacticText = "intros until f",
      confidence = 0.5 ),
    ( tacticText = "induction cl",
      confidence = 0.5 ) ] )
STATE
Env : Type, Term : Type, Term' : Type, Annot : Type, unsat : (Term' -> bool), deduce : (Term' -> Term' -> option Term'), normalise : (Term -> Annot -> cnf), negate : (Term -> Annot -> cnf), eval' : (Env -> Term' -> Prop), no_middle_eval' : (forall (env : Env) (d : Term'), eval' env d \/ ~ eval' env d), unsat_prop : (forall t : Term', unsat t = true -> forall env : Env, eval' env t -> False), deduce_prop : (forall t t' u : Term', deduce t t' = Some u -> forall env : Env, eval' env t -> eval' env t' -> eval' env u), env : Env, a : (list (Term' * Annot)), f : cnf |- (~ make_conj (eval_tt env) a /\ eval_cnf env f <-> eval_cnf env (a :: f))
----
Env : Type, Term : Type, Term' : Type, Annot : Type, unsat : (Term' -> bool), deduce : (Term' -> Term' -> option Term'), normalise : (Term -> Annot -> cnf), negate : (Term -> Annot -> cnf), eval' : (Env -> Term' -> Prop), no_middle_eval' : (forall (env : Env) (d : Term'), eval' env d \/ ~ eval' env d), unsat_prop : (forall t : Term', unsat t = true -> forall env : Env, eval' env t -> False), deduce_prop : (forall t t' u : Term', deduce t t' = Some u -> forall env : Env, eval' env t -> eval' env t' -> eval' env u), env : Env, a : (list (Term' * Annot)), f : cnf |- (~ make_conj (eval_tt env) a /\ eval_cnf env f <-> eval_cnf env (a :: f)) OUTPUT
simpl
unfold eval_cnf in *
tauto
unfold eval_cnf
destruct f
unfold eval_clause in *
split
intros
unfold eval_clause
rewrite eval_cnf_correct
Prediction takes 0.08178281784057617 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold eval_cnf in *",
      confidence = 0.5 ),
    (tacticText = "tauto", confidence = 0.5),
    ( tacticText = "unfold eval_cnf",
      confidence = 0.5 ),
    ( tacticText = "destruct f",
      confidence = 0.5 ),
    ( tacticText = "unfold eval_clause in *",
      confidence = 0.5 ),
    (tacticText = "split", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold eval_clause",
      confidence = 0.5 ),
    ( tacticText = "rewrite eval_cnf_correct",
      confidence = 0.5 ) ] )
STATE
Env : Type, Term : Type, Term' : Type, Annot : Type, unsat : (Term' -> bool), deduce : (Term' -> Term' -> option Term'), normalise : (Term -> Annot -> cnf), negate : (Term -> Annot -> cnf), eval' : (Env -> Term' -> Prop), no_middle_eval' : (forall (env : Env) (d : Term'), eval' env d \/ ~ eval' env d), unsat_prop : (forall t : Term', unsat t = true -> forall env : Env, eval' env t -> False), deduce_prop : (forall t t' u : Term', deduce t t' = Some u -> forall env : Env, eval' env t -> eval' env t' -> eval' env u), env : Env, a : (list (Term' * Annot)), f : cnf |- (~ make_conj (eval_tt env) a /\ make_conj (eval_clause env) f <-> make_conj (eval_clause env) (a :: f))
----
Env : Type, Term : Type, Term' : Type, Annot : Type, unsat : (Term' -> bool), deduce : (Term' -> Term' -> option Term'), normalise : (Term -> Annot -> cnf), negate : (Term -> Annot -> cnf), eval' : (Env -> Term' -> Prop), no_middle_eval' : (forall (env : Env) (d : Term'), eval' env d \/ ~ eval' env d), unsat_prop : (forall t : Term', unsat t = true -> forall env : Env, eval' env t -> False), deduce_prop : (forall t t' u : Term', deduce t t' = Some u -> forall env : Env, eval' env t -> eval' env t' -> eval' env u), env : Env, a : (list (Term' * Annot)), f : cnf |- (~ make_conj (eval_tt env) a /\ make_conj (eval_clause env) f <-> make_conj (eval_clause env) (a :: f)) OUTPUT
simpl
tauto
unfold eval_clause
unfold eval_clause in *
unfold make_conj
destruct f
split
intuition
unfold make_conj in *
rewrite make_conj_cons
Prediction takes 0.08559679985046387 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "tauto", confidence = 0.5),
    ( tacticText = "unfold eval_clause",
      confidence = 0.5 ),
    ( tacticText = "unfold eval_clause in *",
      confidence = 0.5 ),
    ( tacticText = "unfold make_conj",
      confidence = 0.5 ),
    ( tacticText = "destruct f",
      confidence = 0.5 ),
    (tacticText = "split", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    ( tacticText = "unfold make_conj in *",
      confidence = 0.5 ),
    ( tacticText = "rewrite make_conj_cons",
      confidence = 0.5 ) ] )
STATE
Env : Type, Term : Type, Term' : Type, Annot : Type, unsat : (Term' -> bool), deduce : (Term' -> Term' -> option Term'), normalise : (Term -> Annot -> cnf), negate : (Term -> Annot -> cnf), eval' : (Env -> Term' -> Prop), no_middle_eval' : (forall (env : Env) (d : Term'), eval' env d \/ ~ eval' env d), unsat_prop : (forall t : Term', unsat t = true -> forall env : Env, eval' env t -> False), deduce_prop : (forall t t' u : Term', deduce t t' = Some u -> forall env : Env, eval' env t -> eval' env t' -> eval' env u), env : Env, a : (list (Term' * Annot)), f : cnf |- (~ make_conj (eval_tt env) a /\ make_conj (eval_clause env) f <-> match f with | nil => eval_clause env a | _ :: _ => eval_clause env a /\ make_conj (eval_clause env) f end)
----
Env : Type, Term : Type, Term' : Type, Annot : Type, unsat : (Term' -> bool), deduce : (Term' -> Term' -> option Term'), normalise : (Term -> Annot -> cnf), negate : (Term -> Annot -> cnf), eval' : (Env -> Term' -> Prop), no_middle_eval' : (forall (env : Env) (d : Term'), eval' env d \/ ~ eval' env d), unsat_prop : (forall t : Term', unsat t = true -> forall env : Env, eval' env t -> False), deduce_prop : (forall t t' u : Term', deduce t t' = Some u -> forall env : Env, eval' env t -> eval' env t' -> eval' env u), env : Env, a : (list (Term' * Annot)), f : cnf |- (~ make_conj (eval_tt env) a /\ make_conj (eval_clause env) f <-> match f with | nil => eval_clause env a | _ :: _ => eval_clause env a /\ make_conj (eval_clause env) f end) OUTPUT
simpl
destruct f
tauto
unfold eval_clause
unfold eval_clause in *
rewrite make_conj_cons
rewrite make_conj_impl in *
destruct (make_conj (eval_clause env) f)
destruct (make_conj_conj (eval_clause env) f)
destruct (make_conj (eval_clause_clause env) f)
Prediction takes 0.22030329704284668 seconds
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
 |- (forall (l : list t) (x y : t), eq x y -> In x l -> In y l)
----
 |- (forall (l : list t) (x y : t), eq x y -> In x l -> In y l) OUTPUT
intros ?
induction 1
intros
induction l
eauto
exact (In_InfA_InA eq x l)
red
exact (In_InfA_InA eq y l)
exact (In_InfA_alt)
simple induction 1
Prediction takes 3.038140058517456 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction l",
      confidence = 0.5 ),
    (tacticText = "eauto", confidence = 0.5),
    ( tacticText = "exact (In_InfA_InA eq x l)",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "exact (In_InfA_InA eq y l)",
      confidence = 0.5 ),
    ( tacticText = "exact (In_InfA_alt)",
      confidence = 0.5 ),
    ( tacticText = "simple induction 1",
      confidence = 0.5 ) ] )
STATE
l : (list t) |- (forall x y : t, eq x y -> In x l -> In y l)
----
l : (list t) |- (forall x y : t, eq x y -> In x l -> In y l) OUTPUT
intros ?
induction 1
intros
red
induction l
eauto
auto with *
inversion 1
auto
auto with ordered_type
Prediction takes 0.08595728874206543 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "induction l",
      confidence = 0.5 ),
    (tacticText = "eauto", confidence = 0.5),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    ( tacticText = "inversion 1",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "auto with ordered_type",
      confidence = 0.5 ) ] )
STATE
l : (list t), x : t |- (forall y : t, eq x y -> In x l -> In y l)
----
l : (list t), x : t |- (forall y : t, eq x y -> In x l -> In y l) OUTPUT
intros ?
intros
induction 1
red
auto with *
intros until l
inversion 1
exact (In_alt x y)
exact (In_inv x)
exact (In_alt x)
Prediction takes 0.13183951377868652 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    ( tacticText = "intros until l",
      confidence = 0.5 ),
    ( tacticText = "inversion 1",
      confidence = 0.5 ),
    ( tacticText = "exact (In_alt x y)",
      confidence = 0.5 ),
    ( tacticText = "exact (In_inv x)",
      confidence = 0.5 ),
    ( tacticText = "exact (In_alt x)",
      confidence = 0.5 ) ] )
STATE
elt : Type |- (forall (x : key * elt) (k : key) (e e' : elt), ltk (k, e) x -> ltk (k, e') x)
----
elt : Type |- (forall (x : key * elt) (k : key) (e e' : elt), ltk (k, e) x -> ltk (k, e') x) OUTPUT
unfold eqk
unfold ltk
unfold eqke
intros
intros ?
auto
unfold ltk in *
eauto
unfold eqke in *
unfold eqk in *
Prediction takes 0.07265210151672363 seconds
( textPrediction = [
    ( tacticText = "unfold eqk",
      confidence = 0.5 ),
    ( tacticText = "unfold ltk",
      confidence = 0.5 ),
    ( tacticText = "unfold eqke",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold ltk in *",
      confidence = 0.5 ),
    (tacticText = "eauto", confidence = 0.5),
    ( tacticText = "unfold eqke in *",
      confidence = 0.5 ),
    ( tacticText = "unfold eqk in *",
      confidence = 0.5 ) ] )
STATE
elt : Type |- (forall (x : key * elt) (k : key) (e e' : elt), lt (fst (k, e)) (fst x) -> lt (fst (k, e')) (fst x))
----
elt : Type |- (forall (x : key * elt) (k : key) (e e' : elt), lt (fst (k, e)) (fst x) -> lt (fst (k, e')) (fst x)) OUTPUT
simpl
unfold lt
intros ?
auto
intros
unfold lt_key
inversion 1
intuition
red
unfold lt_eq
Prediction takes 0.07112503051757812 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "unfold lt", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold lt_key",
      confidence = 0.5 ),
    ( tacticText = "inversion 1",
      confidence = 0.5 ),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold lt_eq",
      confidence = 0.5 ) ] )
STATE
elt : Type |- (forall (x : key * elt) (k : key), elt -> elt -> lt k (fst x) -> lt k (fst x))
----
elt : Type |- (forall (x : key * elt) (k : key), elt -> elt -> lt k (fst x) -> lt k (fst x)) OUTPUT
unfold lt
intros ?
intros
auto
intuition
induction 1
red
simpl
inversion 1
unfold eq
Prediction takes 0.04867267608642578 seconds
( textPrediction = [
    (tacticText = "unfold lt", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "inversion 1",
      confidence = 0.5 ),
    (tacticText = "unfold eq", confidence = 0.5) ] )
STATE
elt : Type, x : (key * elt)%type |- (forall k : key, elt -> elt -> lt k (fst x) -> lt k (fst x))
----
elt : Type, x : (key * elt)%type |- (forall k : key, elt -> elt -> lt k (fst x) -> lt k (fst x)) OUTPUT
intros ?
intros
unfold lt
red
auto
simpl
intuition
inversion 1
unfold ltA
eauto with *
Prediction takes 0.10782980918884277 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "unfold lt", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    ( tacticText = "inversion 1",
      confidence = 0.5 ),
    ( tacticText = "unfold ltA",
      confidence = 0.5 ),
    ( tacticText = "eauto with *",
      confidence = 0.5 ) ] )
STATE
elt : Type, x : (key * elt)%type, k : key |- (elt -> elt -> lt k (fst x) -> lt k (fst x))
----
elt : Type, x : (key * elt)%type, k : key |- (elt -> elt -> lt k (fst x) -> lt k (fst x)) OUTPUT
intros ?
intros
unfold lt
simpl
red
auto
intuition
inversion 1
induction 1
unfold ltA
Prediction takes 0.06538009643554688 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "unfold lt", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    ( tacticText = "inversion 1",
      confidence = 0.5 ),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    ( tacticText = "unfold ltA",
      confidence = 0.5 ) ] )
STATE
elt : Type, x : (key * elt)%type, k : key, e : elt, e' : elt, H : (lt k (fst x)) |- (lt k (fst x))
----
elt : Type, x : (key * elt)%type, k : key, e : elt, e' : elt, H : (lt k (fst x)) |- (lt k (fst x)) OUTPUT
auto
eauto with ordered_type
auto with ordered_type
intuition
eauto
constructor
red in H
red
intros ?
apply lt_irrefl
Prediction takes 0.09733009338378906 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "eauto with ordered_type",
      confidence = 0.5 ),
    ( tacticText = "auto with ordered_type",
      confidence = 0.5 ),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "eauto", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    (tacticText = "red in H", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "apply lt_irrefl",
      confidence = 0.5 ) ] )
STATE
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct f",
      confidence = 0.5 ),
    (tacticText = "tauto", confidence = 0.5),
    ( tacticText = "unfold eval_clause",
      confidence = 0.5 ),
    ( tacticText = "unfold eval_clause in *",
      confidence = 0.5 ),
    ( tacticText = "rewrite make_conj_cons",
      confidence = 0.5 ),
    ( tacticText = "rewrite make_conj_impl in *",
      confidence = 0.5 ),
    ( tacticText = "destruct (make_conj (eval_clause env) f)",
      confidence = 0.5 ),
    ( tacticText = "destruct (make_conj_conj (eval_clause env) f)",
      confidence = 0.5 ),
    ( tacticText = "destruct (make_conj (eval_clause_clause env) f)",
      confidence = 0.5 ) ] )
STATE
Env : Type, Term : Type, Term' : Type, Annot : Type, unsat : (Term' -> bool), deduce : (Term' -> Term' -> option Term'), normalise : (Term -> Annot -> cnf), negate : (Term -> Annot -> cnf), eval' : (Env -> Term' -> Prop), no_middle_eval' : (forall (env : Env) (d : Term'), eval' env d \/ ~ eval' env d), unsat_prop : (forall t : Term', unsat t = true -> forall env : Env, eval' env t -> False), deduce_prop : (forall t t' u : Term', deduce t t' = Some u -> forall env : Env, eval' env t -> eval' env t' -> eval' env u), env : Env |- (forall (a : list (Term' * Annot)) (f : cnf), ~ make_conj (eval_tt env) a /\ eval_cnf env f <-> eval_cnf env (a :: f))
----
Env : Type, Term : Type, Term' : Type, Annot : Type, unsat : (Term' -> bool), deduce : (Term' -> Term' -> option Term'), normalise : (Term -> Annot -> cnf), negate : (Term -> Annot -> cnf), eval' : (Env -> Term' -> Prop), no_middle_eval' : (forall (env : Env) (d : Term'), eval' env d \/ ~ eval' env d), unsat_prop : (forall t : Term', unsat t = true -> forall env : Env, eval' env t -> False), deduce_prop : (forall t t' u : Term', deduce t t' = Some u -> forall env : Env, eval' env t -> eval' env t' -> eval' env u), env : Env |- (forall (a : list (Term' * Annot)) (f : cnf), ~ make_conj (eval_tt env) a /\ eval_cnf env f <-> eval_cnf env (a :: f)) OUTPUT
simpl
intros
intros until a
intros ?
split
intros until pol
induction f
tauto
destruct f
intros until cl
Prediction takes 0.058431386947631836 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "intros until a",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "intros until pol",
      confidence = 0.5 ),
    ( tacticText = "induction f",
      confidence = 0.5 ),
    (tacticText = "tauto", confidence = 0.5),
    ( tacticText = "destruct f",
      confidence = 0.5 ),
    ( tacticText = "intros until cl",
      confidence = 0.5 ) ] )
STATE
Env : Type, Term : Type, Term' : Type, Annot : Type, unsat : (Term' -> bool), deduce : (Term' -> Term' -> option Term'), normalise : (Term -> Annot -> cnf), negate : (Term -> Annot -> cnf), eval' : (Env -> Term' -> Prop), no_middle_eval' : (forall (env : Env) (d : Term'), eval' env d \/ ~ eval' env d), unsat_prop : (forall t : Term', unsat t = true -> forall env : Env, eval' env t -> False), deduce_prop : (forall t t' u : Term', deduce t t' = Some u -> forall env : Env, eval' env t -> eval' env t' -> eval' env u), env : Env, a : (list (Term' * Annot)) |- (~ make_conj (eval_tt env) a /\ eval_cnf env nil <-> eval_cnf env (a :: nil))
----
Env : Type, Term : Type, Term' : Type, Annot : Type, unsat : (Term' -> bool), deduce : (Term' -> Term' -> option Term'), normalise : (Term -> Annot -> cnf), negate : (Term -> Annot -> cnf), eval' : (Env -> Term' -> Prop), no_middle_eval' : (forall (env : Env) (d : Term'), eval' env d \/ ~ eval' env d), unsat_prop : (forall t : Term', unsat t = true -> forall env : Env, eval' env t -> False), deduce_prop : (forall t t' u : Term', deduce t t' = Some u -> forall env : Env, eval' env t -> eval' env t' -> eval' env u), env : Env, a : (list (Term' * Annot)) |- (~ make_conj (eval_tt env) a /\ eval_cnf env nil <-> eval_cnf env (a :: nil)) OUTPUT
simpl
tauto
simpl in *
unfold eval_cnf
split
intuition
unfold eval_cnf in *
intros
rewrite eval_cnf_correct
unfold eval_clause
Prediction takes 0.09288907051086426 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "tauto", confidence = 0.5),
    ( tacticText = "simpl in *",
      confidence = 0.5 ),
    ( tacticText = "unfold eval_cnf",
      confidence = 0.5 ),
    (tacticText = "split", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    ( tacticText = "unfold eval_cnf in *",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "rewrite eval_cnf_correct",
      confidence = 0.5 ),
    ( tacticText = "unfold eval_clause",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
U : Type |- (forall (A : Ensemble U) (x : U) (n n' : nat), cardinal U A n -> cardinal U (Add U A x) n' -> n' <= S n)
----
U : Type |- (forall (A : Ensemble U) (x : U) (n n' : nat), cardinal U A n -> cardinal U (Add U A x) n' -> n' <= S n) OUTPUT
intros ?
intros
auto with sets
induction 1
induction n
red
unfold cardinal
intros until n
induction n'
intros until s
Prediction takes 2.826218843460083 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "auto with sets",
      confidence = 0.5 ),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold cardinal",
      confidence = 0.5 ),
    ( tacticText = "intros until n",
      confidence = 0.5 ),
    ( tacticText = "induction n\'",
      confidence = 0.5 ),
    ( tacticText = "intros until s",
      confidence = 0.5 ) ] )
STATE
U : Type, A : (Ensemble U) |- (forall (x : U) (n n' : nat), cardinal U A n -> cardinal U (Add U A x) n' -> n' <= S n)
----
U : Type, A : (Ensemble U) |- (forall (x : U) (n n' : nat), cardinal U A n -> cardinal U (Add U A x) n' -> n' <= S n) OUTPUT
intros ?
intros
auto with sets
induction 1
induction n
red
intros until n
unfold cardinal
induction n'
simpl
Prediction takes 0.08603215217590332 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "auto with sets",
      confidence = 0.5 ),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "intros until n",
      confidence = 0.5 ),
    ( tacticText = "unfold cardinal",
      confidence = 0.5 ),
    ( tacticText = "induction n\'",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5) ] )
STATE
U : Type, A : (Ensemble U), x : U |- (forall n n' : nat, cardinal U A n -> cardinal U (Add U A x) n' -> n' <= S n)
----
U : Type, A : (Ensemble U), x : U |- (forall n n' : nat, cardinal U A n -> cardinal U (Add U A x) n' -> n' <= S n) OUTPUT
intros ?
intros
auto with sets
induction 1
clear H
clear H'
induction n
clear A
elim H'
induction n'
Prediction takes 0.08125066757202148 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "auto with sets",
      confidence = 0.5 ),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    (tacticText = "clear H", confidence = 0.5),
    (tacticText = "clear H\'", confidence = 0.5),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    (tacticText = "clear A", confidence = 0.5),
    (tacticText = "elim H\'", confidence = 0.5),
    ( tacticText = "induction n\'",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
A : Type |- (forall (n : nat) (v : t A (S n)) (H : n < S n), nth_order v H = last v)
----
A : Type |- (forall (n : nat) (v : t A (S n)) (H : n < S n), nth_order v H = last v) OUTPUT
intros ?
intros until v
induction v
auto
intros
simpl
induction n
destruct v
trivial
intros until w
Prediction takes 3.0422732830047607 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "intros until v",
      confidence = 0.5 ),
    ( tacticText = "induction v",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    ( tacticText = "destruct v",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "intros until w",
      confidence = 0.5 ) ] )
STATE
A : Type, n : nat |- (forall (v : t A (S n)) (H : n < S n), nth_order v H = last v)
----
A : Type, n : nat |- (forall (v : t A (S n)) (H : n < S n), nth_order v H = last v) OUTPUT
intros ?
intros until v
induction v
auto
intros
simpl
destruct v
trivial
induction n
intros until w
Prediction takes 0.061662912368774414 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "intros until v",
      confidence = 0.5 ),
    ( tacticText = "induction v",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct v",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    ( tacticText = "intros until w",
      confidence = 0.5 ) ] )
STATE
A : Type, n : nat, v : (t A (S n)) |- (forall H : n < S n, nth_order v H = last v)
----
A : Type, n : nat, v : (t A (S n)) |- (forall H : n < S n, nth_order v H = last v) OUTPUT
intros ?
auto
simpl
intros until v
destruct v
trivial
auto with arith
induction v
intros
intros until n
Prediction takes 0.08611941337585449 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "intros until v",
      confidence = 0.5 ),
    ( tacticText = "destruct v",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "auto with arith",
      confidence = 0.5 ),
    ( tacticText = "induction v",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "intros until n",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
n : N, m : N |- (double n = double m -> n = m)
----
n : N, m : N |- (double n = double m -> n = m) OUTPUT
intros ?
rewrite double_succ
cases n
destruct m
destruct n
apply double_succ
easy
auto
apply double_spec
apply double_odd
Prediction takes 2.739105224609375 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "rewrite double_succ",
      confidence = 0.5 ),
    (tacticText = "cases n", confidence = 0.5),
    ( tacticText = "destruct m",
      confidence = 0.5 ),
    ( tacticText = "destruct n",
      confidence = 0.5 ),
    ( tacticText = "apply double_succ",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "apply double_spec",
      confidence = 0.5 ),
    ( tacticText = "apply double_odd",
      confidence = 0.5 ) ] )
STATE
n : N, m : N, H : (double n = double m) |- (n = m)
----
n : N, m : N, H : (double n = double m) |- (n = m) OUTPUT
easy
elim H
rewrite H
rewrite double_succ in H
apply H
rewrite <- H
rewrite H in H
rewrite double_succ
rewrite <- H in H
rewrite double_double in H
Prediction takes 0.10487890243530273 seconds
( textPrediction = [
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "elim H", confidence = 0.5),
    (tacticText = "rewrite H", confidence = 0.5),
    ( tacticText = "rewrite double_succ in H",
      confidence = 0.5 ),
    (tacticText = "apply H", confidence = 0.5),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "rewrite H in H",
      confidence = 0.5 ),
    ( tacticText = "rewrite double_succ",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- H in H",
      confidence = 0.5 ),
    ( tacticText = "rewrite double_double in H",
      confidence = 0.5 ) ] )
STATE
m : N |- (double 0 = double m -> 0 = m)
----
m : N |- (double 0 = double m -> 0 = m) OUTPUT
intros ?
destruct m
simpl
easy
trivial
auto
intros
rewrite double
destruct m'
apply double
Prediction takes 0.05482292175292969 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "destruct m",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "rewrite double",
      confidence = 0.5 ),
    ( tacticText = "destruct m\'",
      confidence = 0.5 ),
    ( tacticText = "apply double",
      confidence = 0.5 ) ] )
STATE
m : N, H : (double 0 = double m) |- (0 = m)
----
m : N, H : (double 0 = double m) |- (0 = m) OUTPUT
easy
elim H
auto
apply H
rewrite H
trivial
exfalso
rewrite <- H
rewrite double
apply double
Prediction takes 0.05396866798400879 seconds
( textPrediction = [
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "elim H", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "apply H", confidence = 0.5),
    (tacticText = "rewrite H", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "exfalso", confidence = 0.5),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "rewrite double",
      confidence = 0.5 ),
    ( tacticText = "apply double",
      confidence = 0.5 ) ] )
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
A : Type, Aeq_dec : (forall x y : A, {x = y} + {x <> y}) |- (forall (a : A) (x y : set), set_In a y -> set_In a (set_union x y))
----
A : Type, Aeq_dec : (forall x y : A, {x = y} + {x <> y}) |- (forall (a : A) (x y : set), set_In a y -> set_In a (set_union x y)) OUTPUT
intros
intros ?
unfold set_In
simpl
auto with datatypes
auto
induction x
unfold set_mem
unfold set_inter
intros until x
Prediction takes 2.951918601989746 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold set_In",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "auto with datatypes",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "induction x",
      confidence = 0.5 ),
    ( tacticText = "unfold set_mem",
      confidence = 0.5 ),
    ( tacticText = "unfold set_inter",
      confidence = 0.5 ),
    ( tacticText = "intros until x",
      confidence = 0.5 ) ] )
STATE
A : Type, Aeq_dec : (forall x y : A, {x = y} + {x <> y}), a : A, x : set, y : set, H : (set_In a y) |- (set_In a (set_union x y))
----
A : Type, Aeq_dec : (forall x y : A, {x = y} + {x <> y}), a : A, x : set, y : set, H : (set_In a y) |- (set_In a (set_union x y)) OUTPUT
auto with datatypes
simpl
auto
assumption
unfold set_add
apply set_add_add
apply set_add_inter
unfold set_In
apply set_add_equal
apply set_add_cons
Prediction takes 0.09184074401855469 seconds
( textPrediction = [
    ( tacticText = "auto with datatypes",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    ( tacticText = "unfold set_add",
      confidence = 0.5 ),
    ( tacticText = "apply set_add_add",
      confidence = 0.5 ),
    ( tacticText = "apply set_add_inter",
      confidence = 0.5 ),
    ( tacticText = "unfold set_In",
      confidence = 0.5 ),
    ( tacticText = "apply set_add_equal",
      confidence = 0.5 ),
    ( tacticText = "apply set_add_cons",
      confidence = 0.5 ) ] )
STATE
A : Type, Aeq_dec : (forall x y : A, {x = y} + {x <> y}), a : A |- (forall x y : set, set_In a y -> set_In a (set_union x y))
----
A : Type, Aeq_dec : (forall x y : A, {x = y} + {x <> y}), a : A |- (forall x y : set, set_In a y -> set_In a (set_union x y)) OUTPUT
intros ?
intros
simpl
unfold set_In
auto with datatypes
unfold set_inter
induction x
auto
unfold set_add
red
Prediction takes 0.07559633255004883 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold set_In",
      confidence = 0.5 ),
    ( tacticText = "auto with datatypes",
      confidence = 0.5 ),
    ( tacticText = "unfold set_inter",
      confidence = 0.5 ),
    ( tacticText = "induction x",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold set_add",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5) ] )
elt : Type, x : (key * elt)%type |- (forall (k : key) (e e' : elt), lt (fst (k, e)) (fst x) -> lt (fst (k, e')) (fst x))
----
elt : Type, x : (key * elt)%type |- (forall (k : key) (e e' : elt), lt (fst (k, e)) (fst x) -> lt (fst (k, e')) (fst x)) OUTPUT
intros ?
simpl
intros
unfold lt
auto
intuition
unfold lt_key
red
unfold lt_eq
induction 1
Prediction takes 0.10868978500366211 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "unfold lt", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    ( tacticText = "unfold lt_key",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold lt_eq",
      confidence = 0.5 ),
    ( tacticText = "induction 1",
      confidence = 0.5 ) ] )
STATE
elt : Type, x : (key * elt)%type, k : key, e : elt, e' : elt, H : (ltk (k, e) x) |- (ltk (k, e') x)
----
elt : Type, x : (key * elt)%type, k : key, e : elt, e' : elt, H : (ltk (k, e) x) |- (ltk (k, e') x) OUTPUT
auto
auto with ordered_type
eauto with ordered_type
eauto
destruct H
red in H
compute in H
simpl
unfold eqk in H
unfold eqk in *
Prediction takes 0.10265922546386719 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "auto with ordered_type",
      confidence = 0.5 ),
    ( tacticText = "eauto with ordered_type",
      confidence = 0.5 ),
    (tacticText = "eauto", confidence = 0.5),
    ( tacticText = "destruct H",
      confidence = 0.5 ),
    (tacticText = "red in H", confidence = 0.5),
    ( tacticText = "compute in H",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold eqk in H",
      confidence = 0.5 ),
    ( tacticText = "unfold eqk in *",
      confidence = 0.5 ) ] )
STATE
elt : Type |- (forall (x : key * elt) (k : key) (e e' : elt), ltk (k, e) x -> ltk (k, e') x)
----
elt : Type |- (forall (x : key * elt) (k : key) (e e' : elt), ltk (k, e) x -> ltk (k, e') x) OUTPUT
unfold eqk
unfold ltk
unfold eqke
intros
intros ?
auto
unfold ltk in *
eauto
unfold eqke in *
unfold eqk in *
Prediction takes 0.08736038208007812 seconds
( textPrediction = [
    ( tacticText = "unfold eqk",
      confidence = 0.5 ),
    ( tacticText = "unfold ltk",
      confidence = 0.5 ),
    ( tacticText = "unfold eqke",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold ltk in *",
      confidence = 0.5 ),
    (tacticText = "eauto", confidence = 0.5),
    ( tacticText = "unfold eqke in *",
      confidence = 0.5 ),
    ( tacticText = "unfold eqk in *",
      confidence = 0.5 ) ] )
STATE
elt : Type |- (forall (x : key * elt) (k : key) (e e' : elt), lt (fst (k, e)) (fst x) -> lt (fst (k, e')) (fst x))
----
elt : Type |- (forall (x : key * elt) (k : key) (e e' : elt), lt (fst (k, e)) (fst x) -> lt (fst (k, e')) (fst x)) OUTPUT
simpl
unfold lt
intros ?
auto
intros
unfold lt_key
inversion 1
intuition
red
unfold lt_eq
Prediction takes 0.08226513862609863 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "unfold lt", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold lt_key",
      confidence = 0.5 ),
    ( tacticText = "inversion 1",
      confidence = 0.5 ),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold lt_eq",
      confidence = 0.5 ) ] )
STATE
elt : Type |- (forall (l : list (key * elt)) (x y : key) (e : elt), eq x y -> MapsTo x e l -> MapsTo y e l)
----
elt : Type |- (forall (l : list (key * elt)) (x y : key) (e : elt), eq x y -> MapsTo x e l -> MapsTo y e l) OUTPUT
intros ?
intros
unfold MapsTo
induction 1
auto
inversion 1
unfold elements
induction l
intuition
exact (Raw.Proofs.PX.MapsTo_eq_equiv)
Prediction takes 0.20007753372192383 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold MapsTo",
      confidence = 0.5 ),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "inversion 1",
      confidence = 0.5 ),
    ( tacticText = "unfold elements",
      confidence = 0.5 ),
    ( tacticText = "induction l",
      confidence = 0.5 ),
    (tacticText = "intuition", confidence = 0.5),
    ( tacticText = "exact (Raw.Proofs.PX.MapsTo_eq_equiv)",
      confidence = 0.5 ) ] )
STATE
elt : Type, l : (list (key * elt)) |- (forall (x y : key) (e : elt), eq x y -> MapsTo x e l -> MapsTo y e l)
----
elt : Type, l : (list (key * elt)) |- (forall (x y : key) (e : elt), eq x y -> MapsTo x e l -> MapsTo y e l) OUTPUT
intros ?
intros
unfold MapsTo
induction 1
auto
red
inversion 1
unfold elements
simpl
unfold elements_mapsto
Prediction takes 0.06995320320129395 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold MapsTo",
      confidence = 0.5 ),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "inversion 1",
      confidence = 0.5 ),
    ( tacticText = "unfold elements",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold elements_mapsto",
      confidence = 0.5 ) ] )
STATE
elt : Type, l : (list (key * elt)), x : key |- (forall (y : key) (e : elt), eq x y -> MapsTo x e l -> MapsTo y e l)
----
elt : Type, l : (list (key * elt)), x : key |- (forall (y : key) (e : elt), eq x y -> MapsTo x e l -> MapsTo y e l) OUTPUT
intros ?
intros
induction 1
unfold MapsTo
auto
induction l
red
unfold add
intuition
unfold add_mapsto
Prediction takes 0.0699160099029541 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    ( tacticText = "unfold MapsTo",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "induction l",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "unfold add",
      confidence = 0.5 ),
    (tacticText = "intuition", confidence = 0.5),
    ( tacticText = "unfold add_mapsto",
      confidence = 0.5 ) ] )
STATE
elt : Type, l : (list (key * elt)), x : key, y : key |- (forall e : elt, eq x y -> MapsTo x e l -> MapsTo y e l)
----
elt : Type, l : (list (key * elt)), x : key, y : key |- (forall e : elt, eq x y -> MapsTo x e l -> MapsTo y e l) OUTPUT
intros ?
intros
unfold MapsTo
auto
induction 1
inversion 1
red
simpl
unfold add
eauto with *
Prediction takes 0.05404019355773926 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold MapsTo",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    ( tacticText = "inversion 1",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold add",
      confidence = 0.5 ),
    ( tacticText = "eauto with *",
      confidence = 0.5 ) ] )
STATE
elt : Type, l : (list (key * elt)), x : key, y : key, e : elt |- (eq x y -> MapsTo x e l -> MapsTo y e l)
----
elt : Type, l : (list (key * elt)), x : key, y : key, e : elt |- (eq x y -> MapsTo x e l -> MapsTo y e l) OUTPUT
intros ?
intros
auto
unfold MapsTo
inversion 1
subst
induction 1
simpl
eauto with *
auto with *
Prediction takes 0.09238934516906738 seconds
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold MapsTo",
      confidence = 0.5 ),
    ( tacticText = "inversion 1",
      confidence = 0.5 ),
    (tacticText = "subst", confidence = 0.5),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "eauto with *",
      confidence = 0.5 ),
    ( tacticText = "auto with *",
      confidence = 0.5 ) ] )
STATE
elt : Type, l : (list (key * elt)), x : key, y : key, e : elt, H : (eq x y) |- (MapsTo x e l -> MapsTo y e l)
----
elt : Type, l : (list (key * elt)), x : key, y : key, e : elt, H : (eq x y) |- (MapsTo x e l -> MapsTo y e l) OUTPUT
intros ?
auto
intros
subst
inversion 1
rewrite InA_alt
apply MapsTo_1
unfold MapsTo
rewrite InA_cons
unfold MapsTo in *
Prediction takes 0.07313704490661621 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    ( tacticText = "inversion 1",
      confidence = 0.5 ),
    ( tacticText = "rewrite InA_alt",
      confidence = 0.5 ),
    ( tacticText = "apply MapsTo_1",
      confidence = 0.5 ),
    ( tacticText = "unfold MapsTo",
      confidence = 0.5 ),
    ( tacticText = "rewrite InA_cons",
      confidence = 0.5 ),
    ( tacticText = "unfold MapsTo in *",
      confidence = 0.5 ) ] )
STATE
elt : Type, l : (list (key * elt)), x : key, y : key, e : elt, H : (eq x y), H0 : (MapsTo x e l) |- (MapsTo y e l)
----
elt : Type, l : (list (key * elt)), x : key, y : key, e : elt, H : (eq x y), H0 : (MapsTo x e l) |- (MapsTo y e l) OUTPUT
auto
subst
exists e
intuition
eauto
red
apply MapsTo_1
eauto with *
eapply MapsTo_eq
apply MapsTo_eq
Prediction takes 0.0776669979095459 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    (tacticText = "exists e", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "eauto", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "apply MapsTo_1",
      confidence = 0.5 ),
    ( tacticText = "eauto with *",
      confidence = 0.5 ),
    ( tacticText = "eapply MapsTo_eq",
      confidence = 0.5 ),
    ( tacticText = "apply MapsTo_eq",
      confidence = 0.5 ) ] )
STATE
elt : Type, l : (list (key * elt)), x : key, y : key, e : elt, H : (eq x y), H0 : (MapsTo x e l) |- (MapsTo y e l)
----
elt : Type, l : (list (key * elt)), x : key, y : key, e : elt, H : (eq x y), H0 : (MapsTo x e l) |- (MapsTo y e l) OUTPUT
auto
subst
exists e
intuition
eauto
red
apply MapsTo_1
eauto with *
eapply MapsTo_eq
apply MapsTo_eq
Prediction takes 0.07468342781066895 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    (tacticText = "exists e", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "eauto", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "apply MapsTo_1",
      confidence = 0.5 ),
    ( tacticText = "eauto with *",
      confidence = 0.5 ),
    ( tacticText = "eapply MapsTo_eq",
      confidence = 0.5 ),
    ( tacticText = "apply MapsTo_eq",
      confidence = 0.5 ) ] )
STATE
elt : Type, l : (list (key * elt)), x : key, y : key, e : elt, H : (eq x y), H0 : (MapsTo x e l) |- (MapsTo y e l)
----
elt : Type, l : (list (key * elt)), x : key, y : key, e : elt, H : (eq x y), H0 : (MapsTo x e l) |- (MapsTo y e l) OUTPUT
auto
subst
exists e
intuition
eauto
red
apply MapsTo_1
eauto with *
eapply MapsTo_eq
apply MapsTo_eq
Prediction takes 0.0776374340057373 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    (tacticText = "exists e", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "eauto", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "apply MapsTo_1",
      confidence = 0.5 ),
    ( tacticText = "eauto with *",
      confidence = 0.5 ),
    ( tacticText = "eapply MapsTo_eq",
      confidence = 0.5 ),
    ( tacticText = "apply MapsTo_eq",
      confidence = 0.5 ) ] )
STATE
elt : Type, l : (list (key * elt)), x : key, y : key |- (forall e : elt, eq x y -> InA eqke (x, e) l -> InA eqke (y, e) l)
----
elt : Type, l : (list (key * elt)), x : key, y : key |- (forall e : elt, eq x y -> InA eqke (x, e) l -> InA eqke (y, e) l) OUTPUT
intros ?
induction 1
intros
inversion 1
unfold eqke
auto
red
induction l
unfold eqke in *
functional induction 1
Prediction takes 0.09788346290588379 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "inversion 1",
      confidence = 0.5 ),
    ( tacticText = "unfold eqke",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "induction l",
      confidence = 0.5 ),
    ( tacticText = "unfold eqke in *",
      confidence = 0.5 ),
    ( tacticText = "functional induction 1",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
n : nat, m : nat |- (Pos.of_nat (Init.Nat.min n m) = Pos.min (Pos.of_nat n) (Pos.of_nat m))
----
n : nat, m : nat |- (Pos.of_nat (Init.Nat.min n m) = Pos.min (Pos.of_nat n) (Pos.of_nat m)) OUTPUT
destruct n
destruct m
rewrite Pos2Nat.inj_succ
apply Nat.min_max_l
apply Nat.max_max_l
rewrite Pos2Nat.id
rewrite Nat.max_max_l
rewrite Pos2Nat.inj_add
rewrite Nat.add_comm
rewrite Pos2Nat.inj_wd
Prediction takes 2.9953391551971436 seconds
( textPrediction = [
    ( tacticText = "destruct n",
      confidence = 0.5 ),
    ( tacticText = "destruct m",
      confidence = 0.5 ),
    ( tacticText = "rewrite Pos2Nat.inj_succ",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.min_max_l",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.max_max_l",
      confidence = 0.5 ),
    ( tacticText = "rewrite Pos2Nat.id",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nat.max_max_l",
      confidence = 0.5 ),
    ( tacticText = "rewrite Pos2Nat.inj_add",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nat.add_comm",
      confidence = 0.5 ),
    ( tacticText = "rewrite Pos2Nat.inj_wd",
      confidence = 0.5 ) ] )
STATE
m : nat |- (Pos.of_nat (Init.Nat.min 0 m) = Pos.min (Pos.of_nat 0) (Pos.of_nat m))
----
m : nat |- (Pos.of_nat (Init.Nat.min 0 m) = Pos.min (Pos.of_nat 0) (Pos.of_nat m)) OUTPUT
destruct m
simpl
rewrite Pos2Nat.inj_succ
unfold Pos.min
easy
unfold Pos.max
rewrite Pos2Nat.inj_0
rewrite Pos.min_0_r
rewrite Pos2Nat.inj_max
rewrite Pos.max_0_r
Prediction takes 0.1277620792388916 seconds
( textPrediction = [
    ( tacticText = "destruct m",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "rewrite Pos2Nat.inj_succ",
      confidence = 0.5 ),
    ( tacticText = "unfold Pos.min",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "unfold Pos.max",
      confidence = 0.5 ),
    ( tacticText = "rewrite Pos2Nat.inj_0",
      confidence = 0.5 ),
    ( tacticText = "rewrite Pos.min_0_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Pos2Nat.inj_max",
      confidence = 0.5 ),
    ( tacticText = "rewrite Pos.max_0_r",
      confidence = 0.5 ) ] )
STATE
 |- (Pos.of_nat (Init.Nat.min 0 0) = Pos.min (Pos.of_nat 0) (Pos.of_nat 0))
----
 |- (Pos.of_nat (Init.Nat.min 0 0) = Pos.min (Pos.of_nat 0) (Pos.of_nat 0)) OUTPUT
simpl
reflexivity
simpl in *
rewrite Pos.max_0
rewrite Pos.min_0
easy
auto
trivial
rewrite Pos.of_nat
unfold Pos.min
Prediction takes 0.08656454086303711 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "simpl in *",
      confidence = 0.5 ),
    ( tacticText = "rewrite Pos.max_0",
      confidence = 0.5 ),
    ( tacticText = "rewrite Pos.min_0",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "rewrite Pos.of_nat",
      confidence = 0.5 ),
    ( tacticText = "unfold Pos.min",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
 |- (well_founded lt)
----
 |- (well_founded lt) OUTPUT
red
intros ?
split
intros
constructor
unfold lt
firstorder
auto with zarith
auto with sets
auto with *
Prediction takes 3.174156665802002 seconds
( textPrediction = [
    (tacticText = "red", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "split", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    (tacticText = "unfold lt", confidence = 0.5),
    ( tacticText = "firstorder",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    ( tacticText = "auto with sets",
      confidence = 0.5 ),
    ( tacticText = "auto with *",
      confidence = 0.5 ) ] )
STATE
 |- (forall a : nat, Acc lt a)
----
 |- (forall a : nat, Acc lt a) OUTPUT
red
intros ?
intros
constructor
firstorder
auto with *
unfold le
exact le_trans
exact le_irrefl
exact le_antisym
Prediction takes 0.06992030143737793 seconds
( textPrediction = [
    (tacticText = "red", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    ( tacticText = "firstorder",
      confidence = 0.5 ),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    (tacticText = "unfold le", confidence = 0.5),
    ( tacticText = "exact le_trans",
      confidence = 0.5 ),
    ( tacticText = "exact le_irrefl",
      confidence = 0.5 ),
    ( tacticText = "exact le_antisym",
      confidence = 0.5 ) ] )
STATE
a : nat |- (Acc lt a)
----
a : nat |- (Acc lt a) OUTPUT
constructor
apply le_trans with a
auto with *
apply lt_le_incl
apply le_antisym
exact le_trans with a
apply lt_trans with a
exact le_trans
unfold le
apply le_trans
Prediction takes 0.09326314926147461 seconds
( textPrediction = [
    ( tacticText = "constructor",
      confidence = 0.5 ),
    ( tacticText = "apply le_trans with a",
      confidence = 0.5 ),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    ( tacticText = "apply lt_le_incl",
      confidence = 0.5 ),
    ( tacticText = "apply le_antisym",
      confidence = 0.5 ),
    ( tacticText = "exact le_trans with a",
      confidence = 0.5 ),
    ( tacticText = "apply lt_trans with a",
      confidence = 0.5 ),
    ( tacticText = "exact le_trans",
      confidence = 0.5 ),
    (tacticText = "unfold le", confidence = 0.5),
    ( tacticText = "apply le_trans",
      confidence = 0.5 ) ] )
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
A : Type |- (forall l l' : list A, rev_append l l' = rev l ++ l')
----
A : Type |- (forall l l' : list A, rev_append l l' = rev l ++ l') OUTPUT
induction l
intros ?
induction 1
intros
induction l'
unfold rev
intros until l
simpl
destruct l
trivial
Prediction takes 3.125213861465454 seconds
( textPrediction = [
    ( tacticText = "induction l",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction l\'",
      confidence = 0.5 ),
    ( tacticText = "unfold rev",
      confidence = 0.5 ),
    ( tacticText = "intros until l",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct l",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5) ] )
STATE
A : Type |- (forall l' : list A, rev_append [] l' = rev [] ++ l')
----
A : Type |- (forall l' : list A, rev_append [] l' = rev [] ++ l') OUTPUT
induction l
intros ?
intros
induction 1
induction l'
simpl
unfold rev
intros until l
trivial
destruct l'
Prediction takes 0.05667734146118164 seconds
( textPrediction = [
    ( tacticText = "induction l",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    ( tacticText = "induction l\'",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold rev",
      confidence = 0.5 ),
    ( tacticText = "intros until l",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "destruct l\'",
      confidence = 0.5 ) ] )
STATE
A : Type, l' : (list A) |- (rev_append [] l' = rev [] ++ l')
----
A : Type, l' : (list A) |- (rev_append [] l' = rev [] ++ l') OUTPUT
simpl
easy
trivial
induction 1
auto
unfold rev
rewrite rev_app
rewrite rev_append
induction l'
induction l
Prediction takes 0.07054615020751953 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold rev",
      confidence = 0.5 ),
    ( tacticText = "rewrite rev_app",
      confidence = 0.5 ),
    ( tacticText = "rewrite rev_append",
      confidence = 0.5 ),
    ( tacticText = "induction l\'",
      confidence = 0.5 ),
    ( tacticText = "induction l",
      confidence = 0.5 ) ] )
STATE
A : Type, l' : (list A) |- (l' = l')
----
A : Type, l' : (list A) |- (l' = l') OUTPUT
auto
easy
reflexivity
trivial
induction l'
inversion 1
induction l
auto with arith
split
destruct l'
Prediction takes 0.060952186584472656 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "induction l\'",
      confidence = 0.5 ),
    ( tacticText = "inversion 1",
      confidence = 0.5 ),
    ( tacticText = "induction l",
      confidence = 0.5 ),
    ( tacticText = "auto with arith",
      confidence = 0.5 ),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "destruct l\'",
      confidence = 0.5 ) ] )
STATE
 |- (forall (A B C : Type) (f : A -> B) (g : B -> C) (l : list A), map g (map f l) = map (fun x : A => g (f x)) l)
----
 |- (forall (A B C : Type) (f : A -> B) (g : B -> C) (l : list A), map g (map f l) = map (fun x : A => g (f x)) l) OUTPUT
intros
induction l
unfold map
simpl
auto
induction 1
intros ?
red
firstorder
unfold map f
Prediction takes 0.055518150329589844 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction l",
      confidence = 0.5 ),
    ( tacticText = "unfold map",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "firstorder",
      confidence = 0.5 ),
    ( tacticText = "unfold map f",
      confidence = 0.5 ) ] )
STATE
A : Type, B : Type, C : Type, f : (A -> B), g : (B -> C), l : (list A) |- (map g (map f l) = map (fun x : A => g (f x)) l)
----
A : Type, B : Type, C : Type, f : (A -> B), g : (B -> C), l : (list A) |- (map g (map f l) = map (fun x : A => g (f x)) l) OUTPUT
simpl
induction l
auto
unfold map
reflexivity
trivial
intros ?
intros
rewrite map
apply map
Prediction takes 0.04390120506286621 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "induction l",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold map",
      confidence = 0.5 ),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "rewrite map",
      confidence = 0.5 ),
    (tacticText = "apply map", confidence = 0.5) ] )
STATE
A : Type, B : Type, C : Type, f : (A -> B), g : (B -> C) |- (map g (map f []) = map (fun x : A => g (f x)) [])
----
A : Type, B : Type, C : Type, f : (A -> B), g : (B -> C) |- (map g (map f []) = map (fun x : A => g (f x)) []) OUTPUT
simpl
unfold map
auto
reflexivity
induction 1
intros
trivial
intros ?
rewrite map
apply map
Prediction takes 0.04269051551818848 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold map",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "rewrite map",
      confidence = 0.5 ),
    (tacticText = "apply map", confidence = 0.5) ] )
STATE
A : Type, B : Type, C : Type, f : (A -> B), g : (B -> C) |- ([] = [])
----
A : Type, B : Type, C : Type, f : (A -> B), g : (B -> C) |- ([] = []) OUTPUT
auto
reflexivity
easy
simpl
trivial
congruence
intros ?
auto with *
auto with sets
auto with arith
Prediction takes 0.052191734313964844 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "congruence",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    ( tacticText = "auto with sets",
      confidence = 0.5 ),
    ( tacticText = "auto with arith",
      confidence = 0.5 ) ] )
STATE
A : Type, B : Type, C : Type, f : (A -> B), g : (B -> C), a : A, l : (list A), IHl : (map g (map f l) = map (fun x : A => g (f x)) l) |- (map g (map f (a :: l)) = map (fun x : A => g (f x)) (a :: l))
----
A : Type, B : Type, C : Type, f : (A -> B), g : (B -> C), a : A, l : (list A), IHl : (map g (map f l) = map (fun x : A => g (f x)) l) |- (map g (map f (a :: l)) = map (fun x : A => g (f x)) (a :: l)) OUTPUT
simpl
auto
rewrite map_map
unfold map
trivial
simpl map
reflexivity
rewrite IHl
rewrite map
rewrite map_spec
Prediction takes 0.0675802230834961 seconds
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
m : nat, n : nat |- ((n <=? m) = false -> m < n)
----
m : nat, n : nat |- ((n <=? m) = false -> m < n) OUTPUT
intros ?
rewrite Nat.leb_le
apply Nat.leb_le
auto
simpl
apply Nat.leb_lt
rewrite Nat.leb_lt
rewrite Nat.leb_eq
rewrite leb_le
apply Nat.eqb_lt
Prediction takes 2.7839579582214355 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "rewrite Nat.leb_le",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.leb_le",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "apply Nat.leb_lt",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nat.leb_lt",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nat.leb_eq",
      confidence = 0.5 ),
    ( tacticText = "rewrite leb_le",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.eqb_lt",
      confidence = 0.5 ) ] )
STATE
m : nat, n : nat, H : ((n <=? m) = false) |- (m < n)
----
m : nat, n : nat, H : ((n <=? m) = false) |- (m < n) OUTPUT
assumption
easy
auto
apply le_refl
inversion H
apply le_ngt
discriminate
apply le_lt_trans
apply Nat.leb_le
apply Nat.leb_lt
Prediction takes 0.08504295349121094 seconds
( textPrediction = [
    ( tacticText = "assumption",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "apply le_refl",
      confidence = 0.5 ),
    ( tacticText = "inversion H",
      confidence = 0.5 ),
    ( tacticText = "apply le_ngt",
      confidence = 0.5 ),
    ( tacticText = "discriminate",
      confidence = 0.5 ),
    ( tacticText = "apply le_lt_trans",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.leb_le",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.leb_lt",
      confidence = 0.5 ) ] )
STATE
m : nat, n : nat |- ((n <=? m) = false -> m < n)
----
m : nat, n : nat |- ((n <=? m) = false -> m < n) OUTPUT
intros ?
rewrite Nat.leb_le
apply Nat.leb_le
auto
simpl
apply Nat.leb_lt
rewrite Nat.leb_lt
rewrite Nat.leb_eq
rewrite leb_le
apply Nat.eqb_lt
Prediction takes 0.0871877670288086 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "rewrite Nat.leb_le",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.leb_le",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "apply Nat.leb_lt",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nat.leb_lt",
      confidence = 0.5 ),
    ( tacticText = "rewrite Nat.leb_eq",
      confidence = 0.5 ),
    ( tacticText = "rewrite leb_le",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.eqb_lt",
      confidence = 0.5 ) ] )
STATE
m : nat, n : nat, H : ((n <=? m) = false) |- (m < n)
----
m : nat, n : nat, H : ((n <=? m) = false) |- (m < n) OUTPUT
assumption
easy
auto
apply le_refl
inversion H
apply le_ngt
discriminate
apply le_lt_trans
apply Nat.leb_le
apply Nat.leb_lt
Prediction takes 0.08881855010986328 seconds
( textPrediction = [
    ( tacticText = "assumption",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "apply le_refl",
      confidence = 0.5 ),
    ( tacticText = "inversion H",
      confidence = 0.5 ),
    ( tacticText = "apply le_ngt",
      confidence = 0.5 ),
    ( tacticText = "discriminate",
      confidence = 0.5 ),
    ( tacticText = "apply le_lt_trans",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.leb_le",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.leb_lt",
      confidence = 0.5 ) ] )
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
p : positive, q : positive |- (p < q -> p <= q)
----
p : positive, q : positive |- (p < q -> p <= q) OUTPUT
intros ?
intros
easy
apply le_refl
apply le_trans
destruct 1
auto
apply lt_trans
destruct q
apply lt_incl
Prediction takes 2.9614083766937256 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply le_refl",
      confidence = 0.5 ),
    ( tacticText = "apply le_trans",
      confidence = 0.5 ),
    ( tacticText = "destruct 1",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "apply lt_trans",
      confidence = 0.5 ),
    ( tacticText = "destruct q",
      confidence = 0.5 ),
    ( tacticText = "apply lt_incl",
      confidence = 0.5 ) ] )
STATE
p : positive, q : positive, H : (p < q) |- (p <= q)
----
p : positive, q : positive, H : (p < q) |- (p <= q) OUTPUT
easy
apply lt_le_incl
auto
trivial
apply le_refl
apply le_lt_incl
assumption
subst
apply le_trans with p
apply Nat.le_trans
Prediction takes 0.09383320808410645 seconds
( textPrediction = [
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply lt_le_incl",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "apply le_refl",
      confidence = 0.5 ),
    ( tacticText = "apply le_lt_incl",
      confidence = 0.5 ),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    (tacticText = "subst", confidence = 0.5),
    ( tacticText = "apply le_trans with p",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.le_trans",
      confidence = 0.5 ) ] )
STATE
p : positive, q : positive, H : (p < q) |- (p <= q)
----
p : positive, q : positive, H : (p < q) |- (p <= q) OUTPUT
easy
apply lt_le_incl
auto
trivial
apply le_refl
apply le_lt_incl
assumption
subst
apply le_trans with p
apply Nat.le_trans
Prediction takes 0.08849692344665527 seconds
( textPrediction = [
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply lt_le_incl",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "apply le_refl",
      confidence = 0.5 ),
    ( tacticText = "apply le_lt_incl",
      confidence = 0.5 ),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    (tacticText = "subst", confidence = 0.5),
    ( tacticText = "apply le_trans with p",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.le_trans",
      confidence = 0.5 ) ] )
STATE
p : positive, q : positive |- (p < q -> p <= q)
----
p : positive, q : positive |- (p < q -> p <= q) OUTPUT
intros ?
intros
easy
apply le_refl
apply le_trans
destruct 1
auto
apply lt_trans
destruct q
apply lt_incl
Prediction takes 0.09827065467834473 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply le_refl",
      confidence = 0.5 ),
    ( tacticText = "apply le_trans",
      confidence = 0.5 ),
    ( tacticText = "destruct 1",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "apply lt_trans",
      confidence = 0.5 ),
    ( tacticText = "destruct q",
      confidence = 0.5 ),
    ( tacticText = "apply lt_incl",
      confidence = 0.5 ) ] )
STATE
p : positive, q : positive |- (p - succ q = pred (p - q))
----
p : positive, q : positive |- (p - succ q = pred (p - q)) OUTPUT
rewrite sub_diag
rewrite sub_succ_r
easy
rewrite pred_succ
rewrite sub_succ_diag
destruct q
rewrite sub_succ
simpl
rewrite sub_add
apply sub_diag
Prediction takes 0.12047505378723145 seconds
( textPrediction = [
    ( tacticText = "rewrite sub_diag",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_succ_r",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite pred_succ",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_succ_diag",
      confidence = 0.5 ),
    ( tacticText = "destruct q",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_succ",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "rewrite sub_add",
      confidence = 0.5 ),
    ( tacticText = "apply sub_diag",
      confidence = 0.5 ) ] )
STATE
p : positive, q : positive |- (p - succ q = pred (p - q))
----
p : positive, q : positive |- (p - succ q = pred (p - q)) OUTPUT
rewrite sub_diag
rewrite sub_succ_r
easy
rewrite pred_succ
rewrite sub_succ_diag
destruct q
rewrite sub_succ
simpl
rewrite sub_add
apply sub_diag
Prediction takes 0.15970420837402344 seconds
( textPrediction = [
    ( tacticText = "rewrite sub_diag",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_succ_r",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite pred_succ",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_succ_diag",
      confidence = 0.5 ),
    ( tacticText = "destruct q",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_succ",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "rewrite sub_add",
      confidence = 0.5 ),
    ( tacticText = "apply sub_diag",
      confidence = 0.5 ) ] )
STATE
p : positive, q : positive |- (p - succ q = pred (p - q))
----
p : positive, q : positive |- (p - succ q = pred (p - q)) OUTPUT
rewrite sub_diag
rewrite sub_succ_r
easy
rewrite pred_succ
rewrite sub_succ_diag
destruct q
rewrite sub_succ
simpl
rewrite sub_add
apply sub_diag
Prediction takes 0.21721673011779785 seconds
( textPrediction = [
    ( tacticText = "rewrite sub_diag",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_succ_r",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite pred_succ",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_succ_diag",
      confidence = 0.5 ),
    ( tacticText = "destruct q",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_succ",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "rewrite sub_add",
      confidence = 0.5 ),
    ( tacticText = "apply sub_diag",
      confidence = 0.5 ) ] )
STATE
p : positive, q : positive |- (p - succ q~1 = pred (p - q~1))
----
p : positive, q : positive |- (p - succ q~1 = pred (p - q~1)) OUTPUT
simpl
easy
rewrite sub_succ_r
f_equal
trivial
rewrite pred_succ
rewrite sub_diag
destruct q
rewrite sub_1_r
rewrite sub_succ_diag
Prediction takes 0.09250450134277344 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite sub_succ_r",
      confidence = 0.5 ),
    (tacticText = "f_equal", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "rewrite pred_succ",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_diag",
      confidence = 0.5 ),
    ( tacticText = "destruct q",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_1_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_succ_diag",
      confidence = 0.5 ) ] )
STATE
p : positive, q : positive |- (p - succ q = pred (p - q))
----
p : positive, q : positive |- (p - succ q = pred (p - q)) OUTPUT
rewrite sub_diag
rewrite sub_succ_r
easy
rewrite pred_succ
rewrite sub_succ_diag
destruct q
rewrite sub_succ
simpl
rewrite sub_add
apply sub_diag
Prediction takes 0.11533641815185547 seconds
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "rewrite map_map",
      confidence = 0.5 ),
    ( tacticText = "unfold map",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "simpl map", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "rewrite IHl",
      confidence = 0.5 ),
    ( tacticText = "rewrite map",
      confidence = 0.5 ),
    ( tacticText = "rewrite map_spec",
      confidence = 0.5 ) ] )
STATE
A : Type, B : Type, C : Type, f : (A -> B), g : (B -> C) |- (map g (map f []) = map (fun x : A => g (f x)) [])
----
A : Type, B : Type, C : Type, f : (A -> B), g : (B -> C) |- (map g (map f []) = map (fun x : A => g (f x)) []) OUTPUT
simpl
unfold map
auto
reflexivity
induction 1
intros
trivial
intros ?
rewrite map
apply map
Prediction takes 0.04502105712890625 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold map",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "rewrite map",
      confidence = 0.5 ),
    (tacticText = "apply map", confidence = 0.5) ] )
STATE
A : Type, B : Type, C : Type, f : (A -> B), g : (B -> C) |- ([] = [])
----
A : Type, B : Type, C : Type, f : (A -> B), g : (B -> C) |- ([] = []) OUTPUT
auto
reflexivity
easy
simpl
trivial
congruence
intros ?
auto with *
auto with sets
auto with arith
Prediction takes 0.0545353889465332 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "congruence",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    ( tacticText = "auto with sets",
      confidence = 0.5 ),
    ( tacticText = "auto with arith",
      confidence = 0.5 ) ] )
STATE
A : Type, B : Type, C : Type, f : (A -> B), g : (B -> C), a : A, l : (list A), IHl : (map g (map f l) = map (fun x : A => g (f x)) l) |- (map g (map f (a :: l)) = map (fun x : A => g (f x)) (a :: l))
----
A : Type, B : Type, C : Type, f : (A -> B), g : (B -> C), a : A, l : (list A), IHl : (map g (map f l) = map (fun x : A => g (f x)) l) |- (map g (map f (a :: l)) = map (fun x : A => g (f x)) (a :: l)) OUTPUT
simpl
auto
rewrite map_map
unfold map
trivial
simpl map
reflexivity
rewrite IHl
rewrite map
rewrite map_spec
Prediction takes 0.08024334907531738 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "rewrite map_map",
      confidence = 0.5 ),
    ( tacticText = "unfold map",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "simpl map", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "rewrite IHl",
      confidence = 0.5 ),
    ( tacticText = "rewrite map",
      confidence = 0.5 ),
    ( tacticText = "rewrite map_spec",
      confidence = 0.5 ) ] )
STATE
A : Type, B : Type, C : Type, f : (A -> B), g : (B -> C), a : A, l : (list A), IHl : (map g (map f l) = map (fun x : A => g (f x)) l) |- (g (f a) :: map g (map f l) = g (f a) :: map (fun x : A => g (f x)) l)
----
A : Type, B : Type, C : Type, f : (A -> B), g : (B -> C), a : A, l : (list A), IHl : (map g (map f l) = map (fun x : A => g (f x)) l) |- (g (f a) :: map g (map f l) = g (f a) :: map (fun x : A => g (f x)) l) OUTPUT
simpl
auto
reflexivity
rewrite map_map
unfold map
trivial
induction l
rewrite map
rewrite IHl
rewrite map_spec
Prediction takes 0.07459235191345215 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "rewrite map_map",
      confidence = 0.5 ),
    ( tacticText = "unfold map",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "induction l",
      confidence = 0.5 ),
    ( tacticText = "rewrite map",
      confidence = 0.5 ),
    ( tacticText = "rewrite IHl",
      confidence = 0.5 ),
    ( tacticText = "rewrite map_spec",
      confidence = 0.5 ) ] )
STATE
 |- (forall (A B C : Type) (f : A -> B) (g : B -> C) (l : list A), (fix map (l0 : list B) : list C := match l0 with | [] => [] | a :: t => g a :: map t end) ((fix map (l0 : list A) : list B := match l0 with | [] => [] | a :: t => f a :: map t end) l) = (fix map (l0 : list A) : list C := match l0 with | [] => [] | a :: t => g (f a) :: map t end) l)
----
 |- (forall (A B C : Type) (f : A -> B) (g : B -> C) (l : list A), (fix map (l0 : list B) : list C := match l0 with | [] => [] | a :: t => g a :: map t end) ((fix map (l0 : list A) : list B := match l0 with | [] => [] | a :: t => f a :: map t end) l) = (fix map (l0 : list A) : list C := match l0 with | [] => [] | a :: t => g (f a) :: map t end) l) OUTPUT
simpl
intros
auto
intros ?
induction l
destruct l
reflexivity
unfold map
trivial
induction l in l
Prediction takes 0.06916499137878418 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "induction l",
      confidence = 0.5 ),
    ( tacticText = "destruct l",
      confidence = 0.5 ),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "unfold map",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "induction l in l",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
n : nat, m : nat |- (even (n + m) -> odd n -> odd m)
----
n : nat, m : nat |- (even (n + m) -> odd n -> odd m) OUTPUT
intros ?
rewrite odd_spec
apply odd_spec
rewrite odd_add
revert n
unfold odd
rewrite <- odd_spec
rewrite <- negb_even
apply even_spec
rewrite odd_succ
Prediction takes 3.070753812789917 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "rewrite odd_spec",
      confidence = 0.5 ),
    ( tacticText = "apply odd_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite odd_add",
      confidence = 0.5 ),
    (tacticText = "revert n", confidence = 0.5),
    ( tacticText = "unfold odd",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- odd_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- negb_even",
      confidence = 0.5 ),
    ( tacticText = "apply even_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite odd_succ",
      confidence = 0.5 ) ] )
STATE
n : nat, m : nat, H : (even (n + m)) |- (odd n -> odd m)
----
n : nat, m : nat, H : (even (n + m)) |- (odd n -> odd m) OUTPUT
intros ?
rewrite odd_spec in H
apply odd_spec in H
rewrite odd_spec
rewrite odd_add
apply even_spec in H
apply odd_spec
rewrite even_spec in H
intros
easy
Prediction takes 0.10800552368164062 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "rewrite odd_spec in H",
      confidence = 0.5 ),
    ( tacticText = "apply odd_spec in H",
      confidence = 0.5 ),
    ( tacticText = "rewrite odd_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite odd_add",
      confidence = 0.5 ),
    ( tacticText = "apply even_spec in H",
      confidence = 0.5 ),
    ( tacticText = "apply odd_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite even_spec in H",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5) ] )
STATE
n : nat, m : nat, H : (even (n + m)), H0 : (odd n) |- (odd m)
----
n : nat, m : nat, H : (even (n + m)), H0 : (odd n) |- (odd m) OUTPUT
easy
apply odd_add
apply even_add
rewrite <- H0
rewrite H0
exists (n + m)
apply H0
trivial
apply even_spec in H
apply even_spec
Prediction takes 0.1092529296875 seconds
( textPrediction = [
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply odd_add",
      confidence = 0.5 ),
    ( tacticText = "apply even_add",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- H0",
      confidence = 0.5 ),
    ( tacticText = "rewrite H0",
      confidence = 0.5 ),
    ( tacticText = "exists (n + m)",
      confidence = 0.5 ),
    (tacticText = "apply H0", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "apply even_spec in H",
      confidence = 0.5 ),
    ( tacticText = "apply even_spec",
      confidence = 0.5 ) ] )
STATE
n : nat, m : nat |- (even (n + m) -> odd n -> odd m)
----
n : nat, m : nat |- (even (n + m) -> odd n -> odd m) OUTPUT
intros ?
rewrite odd_spec
apply odd_spec
rewrite odd_add
revert n
unfold odd
rewrite <- odd_spec
rewrite <- negb_even
apply even_spec
rewrite odd_succ
Prediction takes 0.09607887268066406 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "rewrite odd_spec",
      confidence = 0.5 ),
    ( tacticText = "apply odd_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite odd_add",
      confidence = 0.5 ),
    (tacticText = "revert n", confidence = 0.5),
    ( tacticText = "unfold odd",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- odd_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- negb_even",
      confidence = 0.5 ),
    ( tacticText = "apply even_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite odd_succ",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
n : nat |- (0 <> n -> 0 < n)
----
n : nat |- (0 <> n -> 0 < n) OUTPUT
intros ?
auto with arith
auto
trivial
auto with relations
intros until n
intros
easy
auto with real
destruct n
Prediction takes 2.9218852519989014 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "auto with arith",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "auto with relations",
      confidence = 0.5 ),
    ( tacticText = "intros until n",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "destruct n",
      confidence = 0.5 ) ] )
STATE
n : nat, H : (0 <> n) |- (0 < n)
----
n : nat, H : (0 <> n) |- (0 < n) OUTPUT
auto with real
auto with arith
auto
assumption
easy
auto with relations
trivial
auto with zarith
auto with sets
apply lt_neq
Prediction takes 0.07042932510375977 seconds
( textPrediction = [
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "auto with arith",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "auto with relations",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    ( tacticText = "auto with sets",
      confidence = 0.5 ),
    ( tacticText = "apply lt_neq",
      confidence = 0.5 ) ] )
STATE
n : nat |- (0 <> n -> 0 < n)
----
n : nat |- (0 <> n -> 0 < n) OUTPUT
intros ?
auto with arith
auto
trivial
auto with relations
intros until n
intros
easy
auto with real
destruct n
Prediction takes 0.05914115905761719 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "auto with arith",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "auto with relations",
      confidence = 0.5 ),
    ( tacticText = "intros until n",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "auto with real",
      confidence = 0.5 ),
    ( tacticText = "destruct n",
      confidence = 0.5 ) ] )
STATE
n : nat, m : nat |- (S n < m -> n < Init.Nat.pred m)
----
n : nat, m : nat |- (S n < m -> n < Init.Nat.pred m) OUTPUT
intros ?
intros
apply Nat.lt_succ_r
rewrite <- le_succ_l
apply Nat.lt_succ_l
induction n
apply Nat.le_succ_l
auto with arith
cases ltac:(m)
induction 1
Prediction takes 0.10053753852844238 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "apply Nat.lt_succ_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.lt_succ_l",
      confidence = 0.5 ),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "auto with arith",
      confidence = 0.5 ),
    ( tacticText = "cases ltac:(m)",
      confidence = 0.5 ),
    ( tacticText = "induction 1",
      confidence = 0.5 ) ] )
STATE
n : nat, m : nat, H : (S n < m) |- (n < Init.Nat.pred m)
----
n : nat, m : nat, H : (S n < m) |- (n < Init.Nat.pred m) OUTPUT
rewrite <- H
apply le_succ_l
apply lt_succ_r
rewrite <- le_succ_l
apply Nat.le_succ_l
apply Nat.lt_succ_r
apply Nat.lt_succ_l
apply lt_succ_l
easy
apply le_lt_succ_l
Prediction takes 0.10367608070373535 seconds
( textPrediction = [
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "apply le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply lt_succ_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.lt_succ_r",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.lt_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply lt_succ_l",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply le_lt_succ_l",
      confidence = 0.5 ) ] )
STATE
n : nat, m : nat, H : (S n < m) |- (n < Init.Nat.pred m)
----
n : nat, m : nat, H : (S n < m) |- (n < Init.Nat.pred m) OUTPUT
rewrite <- H
apply le_succ_l
apply lt_succ_r
rewrite <- le_succ_l
apply Nat.le_succ_l
apply Nat.lt_succ_r
apply Nat.lt_succ_l
apply lt_succ_l
easy
apply le_lt_succ_l
Prediction takes 0.10032176971435547 seconds
( textPrediction = [
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "apply le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply lt_succ_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.lt_succ_r",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.lt_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply lt_succ_l",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply le_lt_succ_l",
      confidence = 0.5 ) ] )
STATE
n : nat, m : nat |- (S n < m -> n < Init.Nat.pred m)
----
n : nat, m : nat |- (S n < m -> n < Init.Nat.pred m) OUTPUT
intros ?
intros
apply Nat.lt_succ_r
rewrite <- le_succ_l
apply Nat.lt_succ_l
induction n
apply Nat.le_succ_l
auto with arith
cases ltac:(m)
induction 1
Prediction takes 0.09778904914855957 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "apply Nat.lt_succ_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.lt_succ_l",
      confidence = 0.5 ),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "auto with arith",
      confidence = 0.5 ),
    ( tacticText = "cases ltac:(m)",
      confidence = 0.5 ),
    ( tacticText = "induction 1",
      confidence = 0.5 ) ] )
STATE
n : nat, m : nat, H : (S n < m) |- (n < Init.Nat.pred m)
----
n : nat, m : nat, H : (S n < m) |- (n < Init.Nat.pred m) OUTPUT
rewrite <- H
apply le_succ_l
apply lt_succ_r
rewrite <- le_succ_l
apply Nat.le_succ_l
apply Nat.lt_succ_r
apply Nat.lt_succ_l
apply lt_succ_l
easy
apply le_lt_succ_l
Prediction takes 0.10537505149841309 seconds
( textPrediction = [
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "apply le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply lt_succ_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.lt_succ_r",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.lt_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply lt_succ_l",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply le_lt_succ_l",
      confidence = 0.5 ) ] )
STATE
n : nat, m : nat, H : (S n < m) |- (n < Init.Nat.pred m)
----
n : nat, m : nat, H : (S n < m) |- (n < Init.Nat.pred m) OUTPUT
rewrite <- H
apply le_succ_l
apply lt_succ_r
rewrite <- le_succ_l
apply Nat.le_succ_l
apply Nat.lt_succ_r
apply Nat.lt_succ_l
apply lt_succ_l
easy
apply le_lt_succ_l
Prediction takes 0.11500668525695801 seconds
( textPrediction = [
    ( tacticText = "rewrite sub_diag",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_succ_r",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite pred_succ",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_succ_diag",
      confidence = 0.5 ),
    ( tacticText = "destruct q",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_succ",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "rewrite sub_add",
      confidence = 0.5 ),
    ( tacticText = "apply sub_diag",
      confidence = 0.5 ) ] )
STATE
p : positive, q : positive |- (p - succ q~1 = pred (p - q~1))
----
p : positive, q : positive |- (p - succ q~1 = pred (p - q~1)) OUTPUT
simpl
easy
rewrite sub_succ_r
f_equal
trivial
rewrite pred_succ
rewrite sub_diag
destruct q
rewrite sub_1_r
rewrite sub_succ_diag
Prediction takes 0.0873403549194336 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite sub_succ_r",
      confidence = 0.5 ),
    (tacticText = "f_equal", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "rewrite pred_succ",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_diag",
      confidence = 0.5 ),
    ( tacticText = "destruct q",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_1_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_succ_diag",
      confidence = 0.5 ) ] )
STATE
p : positive, q : positive |- (p - (succ q)~0 = pred (p - q~1))
----
p : positive, q : positive |- (p - (succ q)~0 = pred (p - q~1)) OUTPUT
f_equal
simpl
easy
trivial
rewrite pred_succ
rewrite sub_diag
rewrite sub_succ
reflexivity
rewrite pred_add
rewrite succ_pred
Prediction takes 0.06467747688293457 seconds
( textPrediction = [
    (tacticText = "f_equal", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "rewrite pred_succ",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_diag",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_succ",
      confidence = 0.5 ),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "rewrite pred_add",
      confidence = 0.5 ),
    ( tacticText = "rewrite succ_pred",
      confidence = 0.5 ) ] )
STATE
p : positive, q : positive |- (p - succ q = pred (p - q))
----
p : positive, q : positive |- (p - succ q = pred (p - q)) OUTPUT
rewrite sub_diag
rewrite sub_succ_r
easy
rewrite pred_succ
rewrite sub_succ_diag
destruct q
rewrite sub_succ
simpl
rewrite sub_add
apply sub_diag
Prediction takes 0.09043574333190918 seconds
( textPrediction = [
    ( tacticText = "rewrite sub_diag",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_succ_r",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite pred_succ",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_succ_diag",
      confidence = 0.5 ),
    ( tacticText = "destruct q",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_succ",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "rewrite sub_add",
      confidence = 0.5 ),
    ( tacticText = "apply sub_diag",
      confidence = 0.5 ) ] )
STATE
p : positive, q : positive |- (p - succ q~1 = pred (p - q~1))
----
p : positive, q : positive |- (p - succ q~1 = pred (p - q~1)) OUTPUT
simpl
easy
rewrite sub_succ_r
f_equal
trivial
rewrite pred_succ
rewrite sub_diag
destruct q
rewrite sub_1_r
rewrite sub_succ_diag
Prediction takes 0.11613917350769043 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite sub_succ_r",
      confidence = 0.5 ),
    (tacticText = "f_equal", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "rewrite pred_succ",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_diag",
      confidence = 0.5 ),
    ( tacticText = "destruct q",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_1_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_succ_diag",
      confidence = 0.5 ) ] )
STATE
p : positive, q : positive |- (p - (succ q)~0 = pred (p - q~1))
----
p : positive, q : positive |- (p - (succ q)~0 = pred (p - q~1)) OUTPUT
f_equal
simpl
easy
trivial
rewrite pred_succ
rewrite sub_diag
rewrite sub_succ
reflexivity
rewrite pred_add
rewrite succ_pred
Prediction takes 0.09474682807922363 seconds
( textPrediction = [
    (tacticText = "f_equal", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "rewrite pred_succ",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_diag",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_succ",
      confidence = 0.5 ),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "rewrite pred_add",
      confidence = 0.5 ),
    ( tacticText = "rewrite succ_pred",
      confidence = 0.5 ) ] )
STATE
 |- (forall (n : nat) (a b : positive), fst (ggcdn n a b) = gcdn n a b)
----
 |- (forall (n : nat) (a b : positive), fst (ggcdn n a b) = gcdn n a b) OUTPUT
intros
induction n
intros until a
intros until b
auto
simpl
intros ?
unfold gcd
intros until n
unfold ggcdn
Prediction takes 0.08864140510559082 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    ( tacticText = "intros until a",
      confidence = 0.5 ),
    ( tacticText = "intros until b",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold gcd",
      confidence = 0.5 ),
    ( tacticText = "intros until n",
      confidence = 0.5 ),
    ( tacticText = "unfold ggcdn",
      confidence = 0.5 ) ] )
STATE
n : nat, a : positive, b : positive |- (fst (ggcdn n a b) = gcdn n a b)
----
n : nat, a : positive, b : positive |- (fst (ggcdn n a b) = gcdn n a b) OUTPUT
destruct b
auto
unfold ggcdn
unfold gcd
simpl
destruct a
trivial
unfold ggcd
rewrite <- IHn
unfold gcdn
Prediction takes 0.08666634559631348 seconds
( textPrediction = [
    ( tacticText = "destruct b",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold ggcdn",
      confidence = 0.5 ),
    ( tacticText = "unfold gcd",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct a",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "unfold ggcd",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- IHn",
      confidence = 0.5 ),
    ( tacticText = "unfold gcdn",
      confidence = 0.5 ) ] )
STATE
n : nat, a : positive, b : positive |- (fst (ggcdn n a b~1) = gcdn n a b~1)
----
n : nat, a : positive, b : positive |- (fst (ggcdn n a b~1) = gcdn n a b~1) OUTPUT
simpl
destruct b
auto
unfold gcd
unfold ggcdn
trivial
induction n
f_equal
rewrite <- IHn
unfold gcdn
Prediction takes 0.060853004455566406 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct b",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold gcd",
      confidence = 0.5 ),
    ( tacticText = "unfold ggcdn",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    (tacticText = "f_equal", confidence = 0.5),
    ( tacticText = "rewrite <- IHn",
      confidence = 0.5 ),
    ( tacticText = "unfold gcdn",
      confidence = 0.5 ) ] )
STATE
n : nat, a : positive, b : positive |- (fst (ggcdn n a b~1~1) = gcdn n a b~1~1)
----
n : nat, a : positive, b : positive |- (fst (ggcdn n a b~1~1) = gcdn n a b~1~1) OUTPUT
simpl
auto
destruct b
trivial
unfold gcd
unfold ggcdn
Model Loaded
0
STATE
a : nat |- (div2 a = shiftr a 1)
----
a : nat |- (div2 a = shiftr a 1) OUTPUT
bitwise
destruct a
simpl
trivial
rewrite shiftl_pow2
unfold log2
apply log2_spec
apply log2_pow2
rewrite shiftr_spec
apply log2_unique
Prediction takes 2.940936803817749 seconds
( textPrediction = [
    (tacticText = "bitwise", confidence = 0.5),
    ( tacticText = "destruct a",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "rewrite shiftl_pow2",
      confidence = 0.5 ),
    ( tacticText = "unfold log2",
      confidence = 0.5 ),
    ( tacticText = "apply log2_spec",
      confidence = 0.5 ),
    ( tacticText = "apply log2_pow2",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftr_spec",
      confidence = 0.5 ),
    ( tacticText = "apply log2_unique",
      confidence = 0.5 ) ] )
STATE
 |- (div2 0 = shiftr 0 1)
----
 |- (div2 0 = shiftr 0 1) OUTPUT
simpl
easy
trivial
reflexivity
intros
auto
rewrite sub_0
rewrite sub_1
apply sub_small
unfold sub
Prediction takes 0.0642998218536377 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "rewrite sub_0",
      confidence = 0.5 ),
    ( tacticText = "rewrite sub_1",
      confidence = 0.5 ),
    ( tacticText = "apply sub_small",
      confidence = 0.5 ),
    ( tacticText = "unfold sub",
      confidence = 0.5 ) ] )
STATE
 |- (0 = 0)
----
 |- (0 = 0) OUTPUT
easy
trivial
reflexivity
auto
apply eq_refl
order
apply eq_sym
assumption
intros
intros ?
Prediction takes 0.06645750999450684 seconds
( textPrediction = [
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "apply eq_refl",
      confidence = 0.5 ),
    (tacticText = "order", confidence = 0.5),
    ( tacticText = "apply eq_sym",
      confidence = 0.5 ),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5) ] )
STATE
a : nat |- (div2 (S a) = shiftr (S a) 1)
----
a : nat |- (div2 (S a) = shiftr (S a) 1) OUTPUT
destruct a
simpl
unfold div2
rewrite log2_pow2
unfold log2
rewrite div2_pow2
rewrite shiftl_pow2
unfold log2_double
apply log2_spec
rewrite shiftr_div
Prediction takes 0.08491039276123047 seconds
( textPrediction = [
    ( tacticText = "destruct a",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "unfold div2",
      confidence = 0.5 ),
    ( tacticText = "rewrite log2_pow2",
      confidence = 0.5 ),
    ( tacticText = "unfold log2",
      confidence = 0.5 ),
    ( tacticText = "rewrite div2_pow2",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_pow2",
      confidence = 0.5 ),
    ( tacticText = "unfold log2_double",
      confidence = 0.5 ),
    ( tacticText = "apply log2_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftr_div",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
 |- (forall (a n : t) (a0 : bool) (l h : t), 0 <= l < 2 ^ n -> a == l + (a0 + 2 * h) * 2 ^ n -> a.[n] = a0)
----
 |- (forall (a n : t) (a0 : bool) (l h : t), 0 <= l < 2 ^ n -> a == l + (a0 + 2 * h) * 2 ^ n -> a.[n] = a0) OUTPUT
intros ?
intros
simpl
auto
auto with arith
auto with zarith
rewrite pow_0_r
unfold half_aux
destruct (a0 + h)
unfold half_aux a0
Prediction takes 2.61930513381958 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "auto with arith",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    ( tacticText = "rewrite pow_0_r",
      confidence = 0.5 ),
    ( tacticText = "unfold half_aux",
      confidence = 0.5 ),
    ( tacticText = "destruct (a0 + h)",
      confidence = 0.5 ),
    ( tacticText = "unfold half_aux a0",
      confidence = 0.5 ) ] )
STATE
a : t |- (forall (n : t) (a0 : bool) (l h : t), 0 <= l < 2 ^ n -> a == l + (a0 + 2 * h) * 2 ^ n -> a.[n] = a0)
----
a : t |- (forall (n : t) (a0 : bool) (l h : t), 0 <= l < 2 ^ n -> a == l + (a0 + 2 * h) * 2 ^ n -> a.[n] = a0) OUTPUT
intros ?
simpl
intros
destruct 2
destruct a0
auto
induction n
clear a0
destruct a
clear a
Prediction takes 0.05626225471496582 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "destruct 2",
      confidence = 0.5 ),
    ( tacticText = "destruct a0",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    (tacticText = "clear a0", confidence = 0.5),
    ( tacticText = "destruct a",
      confidence = 0.5 ),
    (tacticText = "clear a", confidence = 0.5) ] )
STATE
a : t, n : t |- (forall (a0 : bool) (l h : t), 0 <= l < 2 ^ n -> a == l + (a0 + 2 * h) * 2 ^ n -> a.[n] = a0)
----
a : t, n : t |- (forall (a0 : bool) (l h : t), 0 <= l < 2 ^ n -> a == l + (a0 + 2 * h) * 2 ^ n -> a.[n] = a0) OUTPUT
intros ?
simpl
intros
destruct 2
destruct a
clear a
clear n Hn
destruct a0
clear n
rewrite pow_add
Prediction takes 0.08103466033935547 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "destruct 2",
      confidence = 0.5 ),
    ( tacticText = "destruct a",
      confidence = 0.5 ),
    (tacticText = "clear a", confidence = 0.5),
    ( tacticText = "clear n Hn",
      confidence = 0.5 ),
    ( tacticText = "destruct a0",
      confidence = 0.5 ),
    (tacticText = "clear n", confidence = 0.5),
    ( tacticText = "rewrite pow_add",
      confidence = 0.5 ) ] )
STATE
a : t, n : t, a0 : bool |- (forall l h : t, 0 <= l < 2 ^ n -> a == l + (a0 + 2 * h) * 2 ^ n -> a.[n] = a0)
----
a : t, n : t, a0 : bool |- (forall l h : t, 0 <= l < 2 ^ n -> a == l + (a0 + 2 * h) * 2 ^ n -> a.[n] = a0) OUTPUT
intros ?
simpl
destruct 2
intros
auto
clear a0
auto with arith
rewrite pow_succ_r
auto with zarith
rewrite pow_0_r
Prediction takes 0.10705184936523438 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct 2",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "clear a0", confidence = 0.5),
    ( tacticText = "auto with arith",
      confidence = 0.5 ),
    ( tacticText = "rewrite pow_succ_r",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    ( tacticText = "rewrite pow_0_r",
      confidence = 0.5 ) ] )
STATE
 |- (forall a n : t, 0 <= n -> (lnot a).[n] = negb a.[n])
----
 |- (forall a n : t, 0 <= n -> (lnot a).[n] = negb a.[n]) OUTPUT
intros ?
intros
unfold lnot
simpl
intros until a
cases n
trivial
destruct a
cases a
unfold lnot_spec
Prediction takes 0.17217421531677246 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold lnot",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "intros until a",
      confidence = 0.5 ),
    (tacticText = "cases n", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "destruct a",
      confidence = 0.5 ),
    (tacticText = "cases a", confidence = 0.5),
    ( tacticText = "unfold lnot_spec",
      confidence = 0.5 ) ] )
STATE
a : t |- (forall n : t, 0 <= n -> (lnot a).[n] = negb a.[n])
----
a : t |- (forall n : t, 0 <= n -> (lnot a).[n] = negb a.[n]) OUTPUT
intros ?
intros
unfold lnot
simpl
destruct a
unfold lxor
rewrite lnot_spec
cases n
apply lnot_spec
case (ones n)
Prediction takes 0.09442543983459473 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold lnot",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct a",
      confidence = 0.5 ),
    ( tacticText = "unfold lxor",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec",
      confidence = 0.5 ),
    (tacticText = "cases n", confidence = 0.5),
    ( tacticText = "apply lnot_spec",
      confidence = 0.5 ),
    ( tacticText = "case (ones n)",
      confidence = 0.5 ) ] )
STATE
a : t, n : t |- (0 <= n -> (lnot a).[n] = negb a.[n])
----
a : t, n : t |- (0 <= n -> (lnot a).[n] = negb a.[n]) OUTPUT
intros ?
rewrite lnot_spec
unfold lnot
rewrite lnot_spec_high
rewrite shiftl_spec
rewrite lnot_spec_low
destruct a.[n]
rewrite shiftl_spec_low
simpl
apply lnot_spec
Prediction takes 0.0788872241973877 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "rewrite lnot_spec",
      confidence = 0.5 ),
    ( tacticText = "unfold lnot",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec_high",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec_low",
      confidence = 0.5 ),
    ( tacticText = "destruct a.[n]",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec_low",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "apply lnot_spec",
      confidence = 0.5 ) ] )
STATE
a : t, n : t, H : (0 <= n) |- ((lnot a).[n] = negb a.[n])
----
a : t, n : t, H : (0 <= n) |- ((lnot a).[n] = negb a.[n]) OUTPUT
rewrite lnot_spec_high
rewrite lnot_spec_high'
rewrite shiftl_spec_high'
rewrite shiftl_spec_high
rewrite shiftl_spec_low
rewrite lnot_spec
rewrite lnot_spec_low
easy
rewrite shiftl_spec
rewrite shiftl_pow2
Prediction takes 0.09066367149353027 seconds
( textPrediction = [
    ( tacticText = "rewrite lnot_spec_high",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec_high\'",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec_high\'",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec_high",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec_low",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec_low",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite shiftl_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_pow2",
      confidence = 0.5 ) ] )
STATE
a : t, n : t |- (0 <= n -> (P (- a)).[n] = negb a.[n])
----
a : t, n : t |- (0 <= n -> (P (- a)).[n] = negb a.[n]) OUTPUT
intros ?
apply le_refl
simpl
rewrite testbit_spec
destruct a
rewrite shiftl_spec
rewrite shiftl_spec'
rewrite testbit_spec'
apply le_antisymm
apply le_ind
Prediction takes 0.07039809226989746 seconds
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
( textPrediction = [
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "apply le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply lt_succ_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.lt_succ_r",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.lt_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply lt_succ_l",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply le_lt_succ_l",
      confidence = 0.5 ) ] )
STATE
n : nat, m : nat |- (S n < m -> n < Init.Nat.pred m)
----
n : nat, m : nat |- (S n < m -> n < Init.Nat.pred m) OUTPUT
intros ?
intros
apply Nat.lt_succ_r
rewrite <- le_succ_l
apply Nat.lt_succ_l
induction n
apply Nat.le_succ_l
auto with arith
cases ltac:(m)
induction 1
Prediction takes 0.10814595222473145 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "apply Nat.lt_succ_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.lt_succ_l",
      confidence = 0.5 ),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "auto with arith",
      confidence = 0.5 ),
    ( tacticText = "cases ltac:(m)",
      confidence = 0.5 ),
    ( tacticText = "induction 1",
      confidence = 0.5 ) ] )
STATE
n : nat, m : nat, H : (S n < m) |- (n < Init.Nat.pred m)
----
n : nat, m : nat, H : (S n < m) |- (n < Init.Nat.pred m) OUTPUT
rewrite <- H
apply le_succ_l
apply lt_succ_r
rewrite <- le_succ_l
apply Nat.le_succ_l
apply Nat.lt_succ_r
apply Nat.lt_succ_l
apply lt_succ_l
easy
apply le_lt_succ_l
Prediction takes 0.1039726734161377 seconds
( textPrediction = [
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "apply le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply lt_succ_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.lt_succ_r",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.lt_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply lt_succ_l",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply le_lt_succ_l",
      confidence = 0.5 ) ] )
STATE
n : nat, m : nat, H : (S n < m) |- (n < Init.Nat.pred m)
----
n : nat, m : nat, H : (S n < m) |- (n < Init.Nat.pred m) OUTPUT
rewrite <- H
apply le_succ_l
apply lt_succ_r
rewrite <- le_succ_l
apply Nat.le_succ_l
apply Nat.lt_succ_r
apply Nat.lt_succ_l
apply lt_succ_l
easy
apply le_lt_succ_l
Prediction takes 0.09900283813476562 seconds
( textPrediction = [
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "apply le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply lt_succ_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.le_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.lt_succ_r",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.lt_succ_l",
      confidence = 0.5 ),
    ( tacticText = "apply lt_succ_l",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply le_lt_succ_l",
      confidence = 0.5 ) ] )
STATE
m : nat |- (1 < m -> 0 < Init.Nat.pred m)
----
m : nat |- (1 < m -> 0 < Init.Nat.pred m) OUTPUT
intros ?
apply Nat.lt_0_1
intros
apply Nat.lt_0_l
apply Pos.lt_0_1
apply Nat.lt_0_succ
apply Nat.lt_0_lt
rewrite Pos.lt_0_r
rewrite Pos.lt_0_1
unfold Nat.lt
Prediction takes 0.09406447410583496 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "apply Nat.lt_0_1",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "apply Nat.lt_0_l",
      confidence = 0.5 ),
    ( tacticText = "apply Pos.lt_0_1",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.lt_0_succ",
      confidence = 0.5 ),
    ( tacticText = "apply Nat.lt_0_lt",
      confidence = 0.5 ),
    ( tacticText = "rewrite Pos.lt_0_r",
      confidence = 0.5 ),
    ( tacticText = "rewrite Pos.lt_0_1",
      confidence = 0.5 ),
    ( tacticText = "unfold Nat.lt",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
easy
induction n
rewrite <- IHn
unfold gcdn
Prediction takes 0.05643033981323242 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "destruct b",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "unfold gcd",
      confidence = 0.5 ),
    ( tacticText = "unfold ggcdn",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- IHn",
      confidence = 0.5 ),
    ( tacticText = "unfold gcdn",
      confidence = 0.5 ) ] )
STATE
n : nat, a : positive, b : positive |- (fst ((fix ggcdn (n : nat) (a b : positive) {struct n} : positive * (positive * positive) := match n with | 0%nat => (1, (a, b)) | S n0 => match a with | a'~1 => match b with | b'~1 => match a' ?= b' with | Eq => (a, (1, 1)) | Lt => let '(g, (ba, aa)) := ggcdn n0 (b' - a') a in (g, (aa, aa + ba~0)) | Gt => let '(g, (ab, bb)) := ggcdn n0 (a' - b') b in (g, (bb + ab~0, bb)) end | b0~0 => let '(g, (aa, bb)) := ggcdn n0 a b0 in (g, (aa, bb~0)) | 1 => (1, (a, 1)) end | a0~0 => match b with | _~1 => let '(g, (aa, bb)) := ggcdn n0 a0 b in (g, (aa~0, bb)) | b0~0 => let (g, p) := ggcdn n0 a0 b0 in (g~0, p) | 1 => (1, (a, 1)) end | 1 => (1, (1, b)) end end) n a b) = gcdn n a b)
----
n : nat, a : positive, b : positive |- (fst ((fix ggcdn (n : nat) (a b : positive) {struct n} : positive * (positive * positive) := match n with | 0%nat => (1, (a, b)) | S n0 => match a with | a'~1 => match b with | b'~1 => match a' ?= b' with | Eq => (a, (1, 1)) | Lt => let '(g, (ba, aa)) := ggcdn n0 (b' - a') a in (g, (aa, aa + ba~0)) | Gt => let '(g, (ab, bb)) := ggcdn n0 (a' - b') b in (g, (bb + ab~0, bb)) end | b0~0 => let '(g, (aa, bb)) := ggcdn n0 a b0 in (g, (aa, bb~0)) | 1 => (1, (a, 1)) end | a0~0 => match b with | _~1 => let '(g, (aa, bb)) := ggcdn n0 a0 b in (g, (aa~0, bb)) | b0~0 => let (g, p) := ggcdn n0 a0 b0 in (g~0, p) | 1 => (1, (a, 1)) end | 1 => (1, (1, b)) end end) n a b) = gcdn n a b) OUTPUT
auto
destruct a
trivial
destruct b
simpl
intros ?
unfold ggcdn
unfold gcd
unfold gcdn
simpl Pos.gcd
Prediction takes 0.10823345184326172 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "destruct a",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "destruct b",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold ggcdn",
      confidence = 0.5 ),
    ( tacticText = "unfold gcd",
      confidence = 0.5 ),
    ( tacticText = "unfold gcdn",
      confidence = 0.5 ),
    ( tacticText = "simpl Pos.gcd",
      confidence = 0.5 ) ] )
STATE
 |- (forall a b : positive, fst (ggcdn 0 a b) = gcdn 0 a b)
----
 |- (forall a b : positive, fst (ggcdn 0 a b) = gcdn 0 a b) OUTPUT
intros
intros until b
simpl
intros until a
unfold gcd
intros ?
auto
unfold ggcdn
destruct b
induction 1
Prediction takes 0.06765580177307129 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "intros until b",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "intros until a",
      confidence = 0.5 ),
    ( tacticText = "unfold gcd",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold ggcdn",
      confidence = 0.5 ),
    ( tacticText = "destruct b",
      confidence = 0.5 ),
    ( tacticText = "induction 1",
      confidence = 0.5 ) ] )
STATE
a : positive, b : positive |- (fst (ggcdn 0 a b) = gcdn 0 a b)
----
a : positive, b : positive |- (fst (ggcdn 0 a b) = gcdn 0 a b) OUTPUT
simpl
destruct b
trivial
unfold gcd
unfold ggcd
auto
unfold ggcdn
easy
apply gcd_unique
apply gcd_divide
Prediction takes 0.0892636775970459 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct b",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "unfold gcd",
      confidence = 0.5 ),
    ( tacticText = "unfold ggcd",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold ggcdn",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply gcd_unique",
      confidence = 0.5 ),
    ( tacticText = "apply gcd_divide",
      confidence = 0.5 ) ] )
STATE
a : positive, b : positive |- (1 = 1)
----
a : positive, b : positive |- (1 = 1) OUTPUT
auto
trivial
easy
reflexivity
auto with zarith
order'
auto with *
simpl
symmetry
destruct b
Prediction takes 0.0709846019744873 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "auto with zarith",
      confidence = 0.5 ),
    (tacticText = "order\'", confidence = 0.5),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "destruct b",
      confidence = 0.5 ) ] )
STATE
n : nat, IHn : (forall a b : positive, fst (ggcdn n a b) = gcdn n a b) |- (forall a b : positive, fst (ggcdn (S n) a b) = gcdn (S n) a b)
----
n : nat, IHn : (forall a b : positive, fst (ggcdn n a b) = gcdn n a b) |- (forall a b : positive, fst (ggcdn (S n) a b) = gcdn (S n) a b) OUTPUT
intros
intros ?
simpl
intros until a
intros until b
auto
induction a
unfold ggcdn
unfold gcd
trivial
Prediction takes 0.07334399223327637 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "intros until a",
      confidence = 0.5 ),
    ( tacticText = "intros until b",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "induction a",
      confidence = 0.5 ),
    ( tacticText = "unfold ggcdn",
      confidence = 0.5 ),
    ( tacticText = "unfold gcd",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5) ] )
STATE
n : nat, a : positive |- (forall b : positive, fst (ggcdn n a b) = gcdn n a b)
----
n : nat, a : positive |- (forall b : positive, fst (ggcdn n a b) = gcdn n a b) OUTPUT
intros until b
intros ?
intros
unfold ggcdn
induction n
induction a
unfold gcd
auto
simpl
intros until a
Prediction takes 0.06103157997131348 seconds
( textPrediction = [
    ( tacticText = "intros until b",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold ggcdn",
      confidence = 0.5 ),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    ( tacticText = "induction a",
      confidence = 0.5 ),
    ( tacticText = "unfold gcd",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "intros until a",
      confidence = 0.5 ) ] )
STATE
n : nat, a : positive, b : positive |- (fst (ggcdn n a b) = gcdn n a b)
----
n : nat, a : positive, b : positive |- (fst (ggcdn n a b) = gcdn n a b) OUTPUT
destruct b
auto
unfold ggcdn
unfold gcd
simpl
destruct a
trivial
unfold ggcd
rewrite <- IHn
unfold gcdn
Prediction takes 0.08813786506652832 seconds
( textPrediction = [
    ( tacticText = "destruct b",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "unfold ggcdn",
      confidence = 0.5 ),
    ( tacticText = "unfold gcd",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct a",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "unfold ggcd",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- IHn",
      confidence = 0.5 ),
    ( tacticText = "unfold gcdn",
      confidence = 0.5 ) ] )
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
 |- (Proper (eq ==> eqf) testbit)
----
 |- (Proper (eq ==> eqf) testbit) OUTPUT
intros ?
red
unfold eq
auto with *
unfold Equal
auto
reflexivity
unfold eqf
intros
unfold eqm
Prediction takes 2.6724846363067627 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "unfold eq", confidence = 0.5),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    ( tacticText = "unfold Equal",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "unfold eqf",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold eqm",
      confidence = 0.5 ) ] )
STATE
x : t |- (forall y : t, x == y -> testbit x === testbit y)
----
x : t |- (forall y : t, x == y -> testbit x === testbit y) OUTPUT
intros ?
intros
unfold lxor
unfold Equal
unfold eq
red
intros until y
unfold odd
unfold add
unfold same
Prediction takes 0.06103873252868652 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold lxor",
      confidence = 0.5 ),
    ( tacticText = "unfold Equal",
      confidence = 0.5 ),
    (tacticText = "unfold eq", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "intros until y",
      confidence = 0.5 ),
    ( tacticText = "unfold odd",
      confidence = 0.5 ),
    ( tacticText = "unfold add",
      confidence = 0.5 ),
    ( tacticText = "unfold same",
      confidence = 0.5 ) ] )
STATE
x : t, y : t |- (x == y -> testbit x === testbit y)
----
x : t, y : t |- (x == y -> testbit x === testbit y) OUTPUT
intros ?
intros
apply eq_true_iff
apply odd_spec
apply Equal_true_iff
trivial
apply set_spec
apply iff_Irreflexive
apply not_false_iff
apply not_true_iff
Prediction takes 0.09739542007446289 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "apply eq_true_iff",
      confidence = 0.5 ),
    ( tacticText = "apply odd_spec",
      confidence = 0.5 ),
    ( tacticText = "apply Equal_true_iff",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "apply set_spec",
      confidence = 0.5 ),
    ( tacticText = "apply iff_Irreflexive",
      confidence = 0.5 ),
    ( tacticText = "apply not_false_iff",
      confidence = 0.5 ),
    ( tacticText = "apply not_true_iff",
      confidence = 0.5 ) ] )
STATE
x : t, y : t, H : (x == y) |- (testbit x === testbit y)
----
x : t, y : t, H : (x == y) |- (testbit x === testbit y) OUTPUT
rewrite lxor_spec
apply eq_refl
rewrite odd_spec
easy
rewrite H
apply eqb_eq
apply iff_sym
apply eq_sym
rewrite <- H
apply odd_spec
Prediction takes 0.07425832748413086 seconds
( textPrediction = [
    ( tacticText = "rewrite lxor_spec",
      confidence = 0.5 ),
    ( tacticText = "apply eq_refl",
      confidence = 0.5 ),
    ( tacticText = "rewrite odd_spec",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "rewrite H", confidence = 0.5),
    ( tacticText = "apply eqb_eq",
      confidence = 0.5 ),
    ( tacticText = "apply iff_sym",
      confidence = 0.5 ),
    ( tacticText = "apply eq_sym",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "apply odd_spec",
      confidence = 0.5 ) ] )
STATE
x : t, y : t, H : (x == y) |- (testbit x === testbit y)
----
x : t, y : t, H : (x == y) |- (testbit x === testbit y) OUTPUT
rewrite lxor_spec
apply eq_refl
rewrite odd_spec
easy
rewrite H
apply eqb_eq
apply iff_sym
apply eq_sym
rewrite <- H
apply odd_spec
Prediction takes 0.07222890853881836 seconds
( textPrediction = [
    ( tacticText = "rewrite lxor_spec",
      confidence = 0.5 ),
    ( tacticText = "apply eq_refl",
      confidence = 0.5 ),
    ( tacticText = "rewrite odd_spec",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "rewrite H", confidence = 0.5),
    ( tacticText = "apply eqb_eq",
      confidence = 0.5 ),
    ( tacticText = "apply iff_sym",
      confidence = 0.5 ),
    ( tacticText = "apply eq_sym",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "apply odd_spec",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
 |- (forall a b : t, b ~= 0 -> 0 <= - (a mod b) < - b \/ - b < - (a mod b) <= 0)
----
 |- (forall a b : t, b ~= 0 -> 0 <= - (a mod b) < - b \/ - b < - (a mod b) <= 0) OUTPUT
intros
intros ?
destruct 1
left
assert (0 <= - b)
destruct (mod_bound_pos a b)
destruct (lt_ge_cases a b)
case (mod_bound_pos a b)
assert (a mod b <= 0)
destruct (lt_ge_cases b 0)
Prediction takes 2.9695851802825928 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "destruct 1",
      confidence = 0.5 ),
    (tacticText = "left", confidence = 0.5),
    ( tacticText = "assert (0 <= - b)",
      confidence = 0.5 ),
    ( tacticText = "destruct (mod_bound_pos a b)",
      confidence = 0.5 ),
    ( tacticText = "destruct (lt_ge_cases a b)",
      confidence = 0.5 ),
    ( tacticText = "case (mod_bound_pos a b)",
      confidence = 0.5 ),
    ( tacticText = "assert (a mod b <= 0)",
      confidence = 0.5 ),
    ( tacticText = "destruct (lt_ge_cases b 0)",
      confidence = 0.5 ) ] )
STATE
a : t, b : t, H : (b ~= 0) |- (0 <= - (a mod b) < - b \/ - b < - (a mod b) <= 0)
----
a : t, b : t, H : (b ~= 0) |- (0 <= - (a mod b) < - b \/ - b < - (a mod b) <= 0) OUTPUT
left
right
rewrite opp_neg_nonpos
rewrite <- opp_le_mono
rewrite opp_nonpos_nonpos
rewrite opp_0
rewrite <- opp_lt_mono
rewrite opp_involutive
rewrite opp_nonneg_nonpos
rewrite opp_le_mono
Prediction takes 0.09593367576599121 seconds
( textPrediction = [
    (tacticText = "left", confidence = 0.5),
    (tacticText = "right", confidence = 0.5),
    ( tacticText = "rewrite opp_neg_nonpos",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- opp_le_mono",
      confidence = 0.5 ),
    ( tacticText = "rewrite opp_nonpos_nonpos",
      confidence = 0.5 ),
    ( tacticText = "rewrite opp_0",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- opp_lt_mono",
      confidence = 0.5 ),
    ( tacticText = "rewrite opp_involutive",
      confidence = 0.5 ),
    ( tacticText = "rewrite opp_nonneg_nonpos",
      confidence = 0.5 ),
    ( tacticText = "rewrite opp_le_mono",
      confidence = 0.5 ) ] )
STATE
a : t, b : t, H : (b ~= 0) |- (0 <= - (a mod b) < - b)
----
a : t, b : t, H : (b ~= 0) |- (0 <= - (a mod b) < - b) OUTPUT
rewrite opp_nonneg_nonpos
apply opp_nonneg_nonpos
rewrite opp_neg_pos
apply opp_pos_bound
rewrite <- opp_nonneg_nonpos
rewrite opp_neg_nonpos
rewrite opp_neg_nonneg
apply lt_le_trans with b
apply lt_le_trans with 0
easy
Prediction takes 0.11350727081298828 seconds
( textPrediction = [
    ( tacticText = "rewrite opp_nonneg_nonpos",
      confidence = 0.5 ),
    ( tacticText = "apply opp_nonneg_nonpos",
      confidence = 0.5 ),
    ( tacticText = "rewrite opp_neg_pos",
      confidence = 0.5 ),
    ( tacticText = "apply opp_pos_bound",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- opp_nonneg_nonpos",
      confidence = 0.5 ),
    ( tacticText = "rewrite opp_neg_nonpos",
      confidence = 0.5 ),
    ( tacticText = "rewrite opp_neg_nonneg",
      confidence = 0.5 ),
    ( tacticText = "apply lt_le_trans with b",
      confidence = 0.5 ),
    ( tacticText = "apply lt_le_trans with 0",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5) ] )
STATE
 |- (forall a b : t, b ~= 0 -> a mod b / b == 0)
----
 |- (forall a b : t, b ~= 0 -> a mod b / b == 0) OUTPUT
intros
intros ?
exact Private_NZDiv.div_small
exact Private_NZDiv.mod_small
exact Private_NZDiv.div_unique
apply Private_NZDiv.div_small
exact Private_NZDiv.div_div_small
wrap Private_NZDiv.div_small
exact Private_NZDiv.div_unique with b
exact Private_NZDiv.div_str_small
Prediction takes 0.13356900215148926 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "exact Private_NZDiv.div_small",
      confidence = 0.5 ),
    ( tacticText = "exact Private_NZDiv.mod_small",
      confidence = 0.5 ),
    ( tacticText = "exact Private_NZDiv.div_unique",
      confidence = 0.5 ),
    ( tacticText = "apply Private_NZDiv.div_small",
      confidence = 0.5 ),
    ( tacticText = "exact Private_NZDiv.div_div_small",
      confidence = 0.5 ),
    ( tacticText = "wrap Private_NZDiv.div_small",
      confidence = 0.5 ),
    ( tacticText = "exact Private_NZDiv.div_unique with b",
      confidence = 0.5 ),
    ( tacticText = "exact Private_NZDiv.div_str_small",
      confidence = 0.5 ) ] )
STATE
a : t, b : t, H : (b ~= 0) |- (a mod b / b == 0)
----
a : t, b : t, H : (b ~= 0) |- (a mod b / b == 0) OUTPUT
symmetry
apply div_small
apply Private_NZDiv.div_small
apply div_unique with 0
pos_or_neg b
apply Private_NZDiv.mod_small
zero_or_not b
rewrite mod_eq
apply div_unique with b
rewrite (div_mod a b)
Prediction takes 0.10491561889648438 seconds
( textPrediction = [
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "apply div_small",
      confidence = 0.5 ),
    ( tacticText = "apply Private_NZDiv.div_small",
      confidence = 0.5 ),
    ( tacticText = "apply div_unique with 0",
      confidence = 0.5 ),
    ( tacticText = "pos_or_neg b",
      confidence = 0.5 ),
    ( tacticText = "apply Private_NZDiv.mod_small",
      confidence = 0.5 ),
    ( tacticText = "zero_or_not b",
      confidence = 0.5 ),
    ( tacticText = "rewrite mod_eq",
      confidence = 0.5 ),
    ( tacticText = "apply div_unique with b",
      confidence = 0.5 ),
    ( tacticText = "rewrite (div_mod a b)",
      confidence = 0.5 ) ] )
STATE
a : t, b : t, H : (b ~= 0) |- (0 == a mod b / b)
----
a : t, b : t, H : (b ~= 0) |- (0 == a mod b / b) OUTPUT
apply div_mod
symmetry
apply div_small
apply div_unique with 0
apply Private_NZDiv.mod_small
apply Private_NZDiv.div_small
pos_or_neg b
apply div_small_iff
apply div_str_bound
rewrite (div_mod a b)
Prediction takes 0.11436676979064941 seconds
( textPrediction = [
    ( tacticText = "apply div_mod",
      confidence = 0.5 ),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "apply div_small",
      confidence = 0.5 ),
    ( tacticText = "apply div_unique with 0",
      confidence = 0.5 ),
    ( tacticText = "apply Private_NZDiv.mod_small",
      confidence = 0.5 ),
    ( tacticText = "apply Private_NZDiv.div_small",
      confidence = 0.5 ),
    ( tacticText = "pos_or_neg b",
      confidence = 0.5 ),
    ( tacticText = "apply div_small_iff",
      confidence = 0.5 ),
    ( tacticText = "apply div_str_bound",
      confidence = 0.5 ),
    ( tacticText = "rewrite (div_mod a b)",
      confidence = 0.5 ) ] )
STATE
a : t, b : t, H : (b ~= 0) |- (a mod b / b == 0)
----
a : t, b : t, H : (b ~= 0) |- (a mod b / b == 0) OUTPUT
symmetry
apply div_small
apply Private_NZDiv.div_small
apply div_unique with 0
pos_or_neg b
apply Private_NZDiv.mod_small
zero_or_not b
rewrite mod_eq
apply div_unique with b
rewrite (div_mod a b)
Prediction takes 0.10217905044555664 seconds
( textPrediction = [
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "apply div_small",
      confidence = 0.5 ),
    ( tacticText = "apply Private_NZDiv.div_small",
      confidence = 0.5 ),
    ( tacticText = "apply div_unique with 0",
      confidence = 0.5 ),
    ( tacticText = "pos_or_neg b",
      confidence = 0.5 ),
    ( tacticText = "apply Private_NZDiv.mod_small",
      confidence = 0.5 ),
    ( tacticText = "zero_or_not b",
      confidence = 0.5 ),
    ( tacticText = "rewrite mod_eq",
      confidence = 0.5 ),
    ( tacticText = "apply div_unique with b",
      confidence = 0.5 ),
    ( tacticText = "rewrite (div_mod a b)",
      confidence = 0.5 ) ] )
STATE
a : t, b : t, H : (b ~= 0) |- (0 == a mod b / b)
----
a : t, b : t, H : (b ~= 0) |- (0 == a mod b / b) OUTPUT
apply div_mod
symmetry
apply div_small
apply div_unique with 0
apply Private_NZDiv.mod_small
apply Private_NZDiv.div_small
pos_or_neg b
apply div_small_iff
apply div_str_bound
rewrite (div_mod a b)
Prediction takes 0.10936284065246582 seconds
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
 |- (forall n m p : t, n <= m <-> n - p <= m - p)
----
 |- (forall n m p : t, n <= m <-> n - p <= m - p) OUTPUT
intros ?
intros
induct n
cases ltac:(m)
induct n m
split
induct m
clear n m H
red
clear n m
Prediction takes 2.9401121139526367 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "induct n", confidence = 0.5),
    ( tacticText = "cases ltac:(m)",
      confidence = 0.5 ),
    ( tacticText = "induct n m",
      confidence = 0.5 ),
    (tacticText = "split", confidence = 0.5),
    (tacticText = "induct m", confidence = 0.5),
    ( tacticText = "clear n m H",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "clear n m", confidence = 0.5) ] )
STATE
n : t |- (forall m p : t, n <= m <-> n - p <= m - p)
----
n : t |- (forall m p : t, n <= m <-> n - p <= m - p) OUTPUT
intros ?
intros
induct n
induct p
clear n m
induct m
induction n
induct n m
split
intros + -
Prediction takes 0.12252593040466309 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "induct n", confidence = 0.5),
    (tacticText = "induct p", confidence = 0.5),
    (tacticText = "clear n m", confidence = 0.5),
    (tacticText = "induct m", confidence = 0.5),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    ( tacticText = "induct n m",
      confidence = 0.5 ),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "intros + -",
      confidence = 0.5 ) ] )
STATE
n : t, m : t |- (forall p : t, n <= m <-> n - p <= m - p)
----
n : t, m : t |- (forall p : t, n <= m <-> n - p <= m - p) OUTPUT
intros ?
intros
induct n
induct p
induct m
induct ltac:(m)
clear n m
induct ltac:(p)
induction n
induct n m
Prediction takes 0.09617114067077637 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "induct n", confidence = 0.5),
    (tacticText = "induct p", confidence = 0.5),
    (tacticText = "induct m", confidence = 0.5),
    ( tacticText = "induct ltac:(m)",
      confidence = 0.5 ),
    (tacticText = "clear n m", confidence = 0.5),
    ( tacticText = "induct ltac:(p)",
      confidence = 0.5 ),
    ( tacticText = "induction n",
      confidence = 0.5 ),
    ( tacticText = "induct n m",
      confidence = 0.5 ) ] )
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "apply le_refl",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "rewrite testbit_spec",
      confidence = 0.5 ),
    ( tacticText = "destruct a",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec\'",
      confidence = 0.5 ),
    ( tacticText = "rewrite testbit_spec\'",
      confidence = 0.5 ),
    ( tacticText = "apply le_antisymm",
      confidence = 0.5 ),
    ( tacticText = "apply le_ind",
      confidence = 0.5 ) ] )
STATE
a : t, n : t, H : (0 <= n) |- ((lnot a).[n] = negb a.[n])
----
a : t, n : t, H : (0 <= n) |- ((lnot a).[n] = negb a.[n]) OUTPUT
rewrite lnot_spec_high
rewrite lnot_spec_high'
rewrite shiftl_spec_high'
rewrite shiftl_spec_high
rewrite shiftl_spec_low
rewrite lnot_spec
rewrite lnot_spec_low
easy
rewrite shiftl_spec
rewrite shiftl_pow2
Prediction takes 0.10016703605651855 seconds
( textPrediction = [
    ( tacticText = "rewrite lnot_spec_high",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec_high\'",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec_high\'",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec_high",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec_low",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec_low",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite shiftl_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_pow2",
      confidence = 0.5 ) ] )
STATE
a : t |- (forall n : t, 0 <= n -> (P (- a)).[n] = negb a.[n])
----
a : t |- (forall n : t, 0 <= n -> (P (- a)).[n] = negb a.[n]) OUTPUT
intros ?
intros
simpl
destruct a
cases n
unfold lnot
trivial
apply le_refl
apply le_ind
unfold opp
Prediction takes 0.07004547119140625 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct a",
      confidence = 0.5 ),
    (tacticText = "cases n", confidence = 0.5),
    ( tacticText = "unfold lnot",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "apply le_refl",
      confidence = 0.5 ),
    ( tacticText = "apply le_ind",
      confidence = 0.5 ),
    ( tacticText = "unfold opp",
      confidence = 0.5 ) ] )
STATE
a : t, n : t, H : (0 <= n) |- ((lnot a).[n] = negb a.[n])
----
a : t, n : t, H : (0 <= n) |- ((lnot a).[n] = negb a.[n]) OUTPUT
rewrite lnot_spec_high
rewrite lnot_spec_high'
rewrite shiftl_spec_high'
rewrite shiftl_spec_high
rewrite shiftl_spec_low
rewrite lnot_spec
rewrite lnot_spec_low
easy
rewrite shiftl_spec
rewrite shiftl_pow2
Prediction takes 0.1675560474395752 seconds
( textPrediction = [
    ( tacticText = "rewrite lnot_spec_high",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec_high\'",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec_high\'",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec_high",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec_low",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec_low",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite shiftl_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_pow2",
      confidence = 0.5 ) ] )
STATE
 |- (forall a n : t, 0 <= n -> (P (- a)).[n] = negb a.[n])
----
 |- (forall a n : t, 0 <= n -> (P (- a)).[n] = negb a.[n]) OUTPUT
intros ?
intros
destruct a
simpl
cases [a]
cases n
trivial
cases a
apply eq_refl
unfold opp_above
Prediction takes 0.10144543647766113 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "destruct a",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "cases [a]", confidence = 0.5),
    (tacticText = "cases n", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "cases a", confidence = 0.5),
    ( tacticText = "apply eq_refl",
      confidence = 0.5 ),
    ( tacticText = "unfold opp_above",
      confidence = 0.5 ) ] )
STATE
a : t |- (forall n : t, 0 <= n -> (P (- a)).[n] = negb a.[n])
----
a : t |- (forall n : t, 0 <= n -> (P (- a)).[n] = negb a.[n]) OUTPUT
intros ?
intros
simpl
destruct a
cases n
unfold lnot
trivial
apply le_refl
apply le_ind
unfold opp
Prediction takes 0.08929610252380371 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "destruct a",
      confidence = 0.5 ),
    (tacticText = "cases n", confidence = 0.5),
    ( tacticText = "unfold lnot",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "apply le_refl",
      confidence = 0.5 ),
    ( tacticText = "apply le_ind",
      confidence = 0.5 ),
    ( tacticText = "unfold opp",
      confidence = 0.5 ) ] )
STATE
 |- (forall a b : t, lnot (lxor a b) == lxor a (lnot b))
----
 |- (forall a b : t, lnot (lxor a b) == lxor a (lnot b)) OUTPUT
intros ?
intros
bitwise
unfold lxorwise
unfold lnot
unfold lxor
unfold lxor_lnot
unfold lxority
destr_bool
induct a
Prediction takes 0.08820962905883789 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "bitwise", confidence = 0.5),
    ( tacticText = "unfold lxorwise",
      confidence = 0.5 ),
    ( tacticText = "unfold lnot",
      confidence = 0.5 ),
    ( tacticText = "unfold lxor",
      confidence = 0.5 ),
    ( tacticText = "unfold lxor_lnot",
      confidence = 0.5 ),
    ( tacticText = "unfold lxority",
      confidence = 0.5 ),
    ( tacticText = "destr_bool",
      confidence = 0.5 ),
    (tacticText = "induct a", confidence = 0.5) ] )
STATE
a : t |- (forall b : t, lnot (lxor a b) == lxor a (lnot b))
----
a : t |- (forall b : t, lnot (lxor a b) == lxor a (lnot b)) OUTPUT
intros ?
intros
unfold lxor
induct a
unfold lnot
bitwise
destr_bool
destr_ Hm
apply lxor_unique
destr_spec
Prediction takes 0.08975434303283691 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold lxor",
      confidence = 0.5 ),
    (tacticText = "induct a", confidence = 0.5),
    ( tacticText = "unfold lnot",
      confidence = 0.5 ),
    (tacticText = "bitwise", confidence = 0.5),
    ( tacticText = "destr_bool",
      confidence = 0.5 ),
    (tacticText = "destr_ Hm", confidence = 0.5),
    ( tacticText = "apply lxor_unique",
      confidence = 0.5 ),
    ( tacticText = "destr_spec",
      confidence = 0.5 ) ] )
STATE
a : t, b : t |- (lnot (lxor a b) == lxor a (lnot b))
----
a : t, b : t |- (lnot (lxor a b) == lxor a (lnot b)) OUTPUT
bitwise
unfold lnot
rewrite lxor_comm
unfold lxor
rewrite lxor_lnot_lnot
rewrite lnot_spec
intros ?
rewrite lnot_lnot_lnot
apply lxor_lnot_lnot
rewrite lnot_comm
Prediction takes 0.09047913551330566 seconds
( textPrediction = [
    (tacticText = "bitwise", confidence = 0.5),
    ( tacticText = "unfold lnot",
      confidence = 0.5 ),
    ( tacticText = "rewrite lxor_comm",
      confidence = 0.5 ),
    ( tacticText = "unfold lxor",
      confidence = 0.5 ),
    ( tacticText = "rewrite lxor_lnot_lnot",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "rewrite lnot_lnot_lnot",
      confidence = 0.5 ),
    ( tacticText = "apply lxor_lnot_lnot",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_comm",
      confidence = 0.5 ) ] )
STATE
a : t, b : t, m : t, Hm : (0 <= m) |- ((lnot (lxor a b)).[m] = xorb a.[m] (lnot b).[m])
----
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
x : t, y : t, z : t |- (x <= y -> y == z -> x <= z)
----
x : t, y : t, z : t |- (x <= y -> y == z -> x <= z) OUTPUT
rewrite Private_OrderTac.IsTotal.le_lteq
rewrite le_lteq
rewrite Private_Tac.le_lteq
rewrite lt_eq_cases
rewrite OT.le_lteq
rewrite TO.le_lteq
rewrite Private_OrderTac.Tac.le_lteq
rewrite OrderTac.IsTotal.le_lteq
rewrite P.le_lteq
rewrite Private_IsTotal.le_lteq
Prediction takes 2.996708631515503 seconds
( textPrediction = [
    ( tacticText = "rewrite Private_OrderTac.IsTotal.le_lteq",
      confidence = 0.5 ),
    ( tacticText = "rewrite le_lteq",
      confidence = 0.5 ),
    ( tacticText = "rewrite Private_Tac.le_lteq",
      confidence = 0.5 ),
    ( tacticText = "rewrite lt_eq_cases",
      confidence = 0.5 ),
    ( tacticText = "rewrite OT.le_lteq",
      confidence = 0.5 ),
    ( tacticText = "rewrite TO.le_lteq",
      confidence = 0.5 ),
    ( tacticText = "rewrite Private_OrderTac.Tac.le_lteq",
      confidence = 0.5 ),
    ( tacticText = "rewrite OrderTac.IsTotal.le_lteq",
      confidence = 0.5 ),
    ( tacticText = "rewrite P.le_lteq",
      confidence = 0.5 ),
    ( tacticText = "rewrite Private_IsTotal.le_lteq",
      confidence = 0.5 ) ] )
STATE
x : t, y : t |- (x == y -> x <= y)
----
x : t, y : t |- (x == y -> x <= y) OUTPUT
intros ?
symmetry
rewrite lt_eq_cases
order
apply lt_eq_cases
rewrite le_lteq
trivial
apply eq_le_incl
apply eq_sym
apply lt_le_incl
Prediction takes 0.08736205101013184 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "rewrite lt_eq_cases",
      confidence = 0.5 ),
    (tacticText = "order", confidence = 0.5),
    ( tacticText = "apply lt_eq_cases",
      confidence = 0.5 ),
    ( tacticText = "rewrite le_lteq",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "apply eq_le_incl",
      confidence = 0.5 ),
    ( tacticText = "apply eq_sym",
      confidence = 0.5 ),
    ( tacticText = "apply lt_le_incl",
      confidence = 0.5 ) ] )
STATE
x : t, y : t, H : (x == y) |- (x <= y)
----
x : t, y : t, H : (x == y) |- (x <= y) OUTPUT
easy
rewrite le_lteq
auto
rewrite H
trivial
rewrite <- H
apply irreflexivity
apply le_refl
rewrite <- le_lteq
apply le_antisym
Prediction takes 0.08667874336242676 seconds
( textPrediction = [
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite le_lteq",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "rewrite H", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "rewrite <- H",
      confidence = 0.5 ),
    ( tacticText = "apply irreflexivity",
      confidence = 0.5 ),
    ( tacticText = "apply le_refl",
      confidence = 0.5 ),
    ( tacticText = "rewrite <- le_lteq",
      confidence = 0.5 ),
    ( tacticText = "apply le_antisym",
      confidence = 0.5 ) ] )
( textPrediction = [
    ( tacticText = "apply div_mod",
      confidence = 0.5 ),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "apply div_small",
      confidence = 0.5 ),
    ( tacticText = "apply div_unique with 0",
      confidence = 0.5 ),
    ( tacticText = "apply Private_NZDiv.mod_small",
      confidence = 0.5 ),
    ( tacticText = "apply Private_NZDiv.div_small",
      confidence = 0.5 ),
    ( tacticText = "pos_or_neg b",
      confidence = 0.5 ),
    ( tacticText = "apply div_small_iff",
      confidence = 0.5 ),
    ( tacticText = "apply div_str_bound",
      confidence = 0.5 ),
    ( tacticText = "rewrite (div_mod a b)",
      confidence = 0.5 ) ] )
STATE
a : t, b : t, H : (b ~= 0) |- (0 <= a mod b < b)
----
a : t, b : t, H : (b ~= 0) |- (0 <= a mod b < b) OUTPUT
destruct (mod_bound_pos a b)
apply mod_bound_pos
auto'
destruct (mod_pos_bound a b)
destruct (lt_ge_cases b 0)
apply le_0_l
destruct (lt_ge_cases a b)
destruct (mod_neg_bound a b)
destruct (mod_bound_pos b)
destruct (mod_bound_pos b b)
Prediction takes 0.12591886520385742 seconds
( textPrediction = [
    ( tacticText = "destruct (mod_bound_pos a b)",
      confidence = 0.5 ),
    ( tacticText = "apply mod_bound_pos",
      confidence = 0.5 ),
    (tacticText = "auto\'", confidence = 0.5),
    ( tacticText = "destruct (mod_pos_bound a b)",
      confidence = 0.5 ),
    ( tacticText = "destruct (lt_ge_cases b 0)",
      confidence = 0.5 ),
    ( tacticText = "apply le_0_l",
      confidence = 0.5 ),
    ( tacticText = "destruct (lt_ge_cases a b)",
      confidence = 0.5 ),
    ( tacticText = "destruct (mod_neg_bound a b)",
      confidence = 0.5 ),
    ( tacticText = "destruct (mod_bound_pos b)",
      confidence = 0.5 ),
    ( tacticText = "destruct (mod_bound_pos b b)",
      confidence = 0.5 ) ] )
STATE
a : t, b : t, H : (b ~= 0) |- (0 <= a mod b < b)
----
a : t, b : t, H : (b ~= 0) |- (0 <= a mod b < b) OUTPUT
destruct (mod_bound_pos a b)
apply mod_bound_pos
auto'
destruct (mod_pos_bound a b)
destruct (lt_ge_cases b 0)
apply le_0_l
destruct (lt_ge_cases a b)
destruct (mod_neg_bound a b)
destruct (mod_bound_pos b)
destruct (mod_bound_pos b b)
Prediction takes 0.1322798728942871 seconds
( textPrediction = [
    ( tacticText = "destruct (mod_bound_pos a b)",
      confidence = 0.5 ),
    ( tacticText = "apply mod_bound_pos",
      confidence = 0.5 ),
    (tacticText = "auto\'", confidence = 0.5),
    ( tacticText = "destruct (mod_pos_bound a b)",
      confidence = 0.5 ),
    ( tacticText = "destruct (lt_ge_cases b 0)",
      confidence = 0.5 ),
    ( tacticText = "apply le_0_l",
      confidence = 0.5 ),
    ( tacticText = "destruct (lt_ge_cases a b)",
      confidence = 0.5 ),
    ( tacticText = "destruct (mod_neg_bound a b)",
      confidence = 0.5 ),
    ( tacticText = "destruct (mod_bound_pos b)",
      confidence = 0.5 ),
    ( tacticText = "destruct (mod_bound_pos b b)",
      confidence = 0.5 ) ] )
STATE
a : t, b : t, H : (b ~= 0) |- (0 <= a)
----
a : t, b : t, H : (b ~= 0) |- (0 <= a) OUTPUT
auto'
easy
trivial
intuition
order
nzsimpl
auto
trivial'
auto' H
auto' with *
Prediction takes 0.07378315925598145 seconds
( textPrediction = [
    (tacticText = "auto\'", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "order", confidence = 0.5),
    (tacticText = "nzsimpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "trivial\'", confidence = 0.5),
    (tacticText = "auto\' H", confidence = 0.5),
    ( tacticText = "auto\' with *",
      confidence = 0.5 ) ] )
STATE
a : t, b : t, H : (b ~= 0) |- (0 <= a)
----
a : t, b : t, H : (b ~= 0) |- (0 <= a) OUTPUT
auto'
easy
trivial
intuition
order
nzsimpl
auto
trivial'
auto' H
auto' with *
Prediction takes 0.06830501556396484 seconds
( textPrediction = [
    (tacticText = "auto\'", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "order", confidence = 0.5),
    (tacticText = "nzsimpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "trivial\'", confidence = 0.5),
    (tacticText = "auto\' H", confidence = 0.5),
    ( tacticText = "auto\' with *",
      confidence = 0.5 ) ] )
STATE
a : t, b : t, H : (b ~= 0) |- (0 <= a mod b < b)
----
a : t, b : t, H : (b ~= 0) |- (0 <= a mod b < b) OUTPUT
destruct (mod_bound_pos a b)
apply mod_bound_pos
auto'
destruct (mod_pos_bound a b)
destruct (lt_ge_cases b 0)
apply le_0_l
destruct (lt_ge_cases a b)
destruct (mod_neg_bound a b)
destruct (mod_bound_pos b)
destruct (mod_bound_pos b b)
Prediction takes 0.1322026252746582 seconds
( textPrediction = [
    ( tacticText = "destruct (mod_bound_pos a b)",
      confidence = 0.5 ),
    ( tacticText = "apply mod_bound_pos",
      confidence = 0.5 ),
    (tacticText = "auto\'", confidence = 0.5),
    ( tacticText = "destruct (mod_pos_bound a b)",
      confidence = 0.5 ),
    ( tacticText = "destruct (lt_ge_cases b 0)",
      confidence = 0.5 ),
    ( tacticText = "apply le_0_l",
      confidence = 0.5 ),
    ( tacticText = "destruct (lt_ge_cases a b)",
      confidence = 0.5 ),
    ( tacticText = "destruct (mod_neg_bound a b)",
      confidence = 0.5 ),
    ( tacticText = "destruct (mod_bound_pos b)",
      confidence = 0.5 ),
    ( tacticText = "destruct (mod_bound_pos b b)",
      confidence = 0.5 ) ] )
starting proving server with connection through their stdin
using textmode optiontext
starting proving server with connection through their stdin
using textmode optiontext
Model Loaded
0
STATE
 |- (forall x y : t, leb x y <-> x <= y)
----
 |- (forall x y : t, leb x y <-> x <= y) OUTPUT
intros
unfold leb x
intros ?
unfold leb
unfold leb x y
red
split
unfold leb y
auto with *
unfold Equal
Prediction takes 2.8207130432128906 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold leb x",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "unfold leb",
      confidence = 0.5 ),
    ( tacticText = "unfold leb x y",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "split", confidence = 0.5),
    ( tacticText = "unfold leb y",
      confidence = 0.5 ),
    ( tacticText = "auto with *",
      confidence = 0.5 ),
    ( tacticText = "unfold Equal",
      confidence = 0.5 ) ] )
STATE
x : t, y : t |- (leb x y <-> x <= y)
----
x : t, y : t |- (leb x y <-> x <= y) OUTPUT
unfold leb
apply leb_le
symmetry
unfold eqb
rewrite leb_le
unfold compare
unfold eq
unfold lt
rewrite <- leb_le
apply leb_eq
Prediction takes 0.0741128921508789 seconds
( textPrediction = [
    ( tacticText = "unfold leb",
      confidence = 0.5 ),
    ( tacticText = "apply leb_le",
      confidence = 0.5 ),
    (tacticText = "symmetry", confidence = 0.5),
    ( tacticText = "unfold eqb",
      confidence = 0.5 ),
    ( tacticText = "rewrite leb_le",
      confidence = 0.5 ),
    ( tacticText = "unfold compare",
      confidence = 0.5 ),
    (tacticText = "unfold eq", confidence = 0.5),
    (tacticText = "unfold lt", confidence = 0.5),
    ( tacticText = "rewrite <- leb_le",
      confidence = 0.5 ),
    ( tacticText = "apply leb_eq",
      confidence = 0.5 ) ] )
STATE
x : t, y : t |- (match x ?= y with | Gt => false | _ => true end <-> x <= y)
----
x : t, y : t |- (match x ?= y with | Gt => false | _ => true end <-> x <= y) OUTPUT
case compare_spec
destruct compare
rewrite compare_le_iff
destruct compare_spec
rewrite compare_eq_iff
apply compare_le_iff
rewrite leb_le
destruct (compare x y)
rewrite eqb_eq
apply leb_le
Prediction takes 0.12622809410095215 seconds
( textPrediction = [
    ( tacticText = "case compare_spec",
      confidence = 0.5 ),
    ( tacticText = "destruct compare",
      confidence = 0.5 ),
    ( tacticText = "rewrite compare_le_iff",
      confidence = 0.5 ),
    ( tacticText = "destruct compare_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite compare_eq_iff",
      confidence = 0.5 ),
    ( tacticText = "apply compare_le_iff",
      confidence = 0.5 ),
    ( tacticText = "rewrite leb_le",
      confidence = 0.5 ),
    ( tacticText = "destruct (compare x y)",
      confidence = 0.5 ),
    ( tacticText = "rewrite eqb_eq",
      confidence = 0.5 ),
    ( tacticText = "apply leb_le",
      confidence = 0.5 ) ] )
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
starting proving server with connection through their stdin
using textmode optiontext
a : t, b : t, m : t, Hm : (0 <= m) |- ((lnot (lxor a b)).[m] = xorb a.[m] (lnot b).[m]) OUTPUT
rewrite lnot_spec
rewrite lnot_spec_low
rewrite lnot_spec_high
rewrite lxor_spec
rewrite shiftl_spec_low
rewrite shiftr_spec
rewrite lxor_spec_low
rewrite shiftl_spec_high
rewrite shiftl_spec
easy
Prediction takes 0.08675813674926758 seconds
( textPrediction = [
    ( tacticText = "rewrite lnot_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec_low",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec_high",
      confidence = 0.5 ),
    ( tacticText = "rewrite lxor_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec_low",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftr_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite lxor_spec_low",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec_high",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5) ] )
STATE
a : t, b : t, m : t, Hm : (0 <= m) |- (negb (lxor a b).[m] = xorb a.[m] (lnot b).[m])
----
a : t, b : t, m : t, Hm : (0 <= m) |- (negb (lxor a b).[m] = xorb a.[m] (lnot b).[m]) OUTPUT
rewrite lnot_spec
rewrite lnot_spec_low
rewrite lnot_spec_high
rewrite lxor_spec
easy
rewrite shiftl_spec_low
rewrite lxor_spec_low
rewrite shiftr_spec
rewrite shiftl_spec
rewrite lnot_spec'
Prediction takes 0.08913516998291016 seconds
( textPrediction = [
    ( tacticText = "rewrite lnot_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec_low",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec_high",
      confidence = 0.5 ),
    ( tacticText = "rewrite lxor_spec",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite shiftl_spec_low",
      confidence = 0.5 ),
    ( tacticText = "rewrite lxor_spec_low",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftr_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec\'",
      confidence = 0.5 ) ] )
STATE
a : t, b : t, m : t, Hm : (0 <= m) |- (negb (lxor a b).[m] = xorb a.[m] (negb b.[m]))
----
a : t, b : t, m : t, Hm : (0 <= m) |- (negb (lxor a b).[m] = xorb a.[m] (negb b.[m])) OUTPUT
rewrite lnot_spec
easy
rewrite lxor_spec
rewrite shiftl_spec
rewrite lnot_spec_high
rewrite lnot_spec_low
rewrite shiftr_spec
rewrite lor_spec
rewrite lnot_spec'
rewrite shiftl_spec_low
Prediction takes 0.08589339256286621 seconds
( textPrediction = [
    ( tacticText = "rewrite lnot_spec",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite lxor_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec_high",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec_low",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftr_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite lor_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec\'",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec_low",
      confidence = 0.5 ) ] )
STATE
a : t, b : t |- (P (- lxor a b) == lxor a (P (- b)))
----
a : t, b : t |- (P (- lxor a b) == lxor a (P (- b))) OUTPUT
bitwise
rewrite lxor_comm
unfold lxor
rewrite opp_involutive
rewrite lxor_0_l
rewrite lxor_0
rewrite lnot_involutive
rewrite lnot_opp
apply lxor_0_l
rewrite lxor_0_r
Prediction takes 0.08559894561767578 seconds
( textPrediction = [
    (tacticText = "bitwise", confidence = 0.5),
    ( tacticText = "rewrite lxor_comm",
      confidence = 0.5 ),
    ( tacticText = "unfold lxor",
      confidence = 0.5 ),
    ( tacticText = "rewrite opp_involutive",
      confidence = 0.5 ),
    ( tacticText = "rewrite lxor_0_l",
      confidence = 0.5 ),
    ( tacticText = "rewrite lxor_0",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_involutive",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_opp",
      confidence = 0.5 ),
    ( tacticText = "apply lxor_0_l",
      confidence = 0.5 ),
    ( tacticText = "rewrite lxor_0_r",
      confidence = 0.5 ) ] )
STATE
a : t, b : t, m : t, Hm : (0 <= m) |- ((P (- lxor a b)).[m] = xorb a.[m] (P (- b)).[m])
----
a : t, b : t, m : t, Hm : (0 <= m) |- ((P (- lxor a b)).[m] = xorb a.[m] (P (- b)).[m]) OUTPUT
rewrite lnot_spec
rewrite shiftr_spec
rewrite shiftl_spec
rewrite shiftl_spec_low
rewrite lnot_spec_low
easy
rewrite lxor_spec
rewrite shiftl_spec_high
rewrite lnot_spec_high
rewrite ones_spec
Prediction takes 0.09110593795776367 seconds
( textPrediction = [
    ( tacticText = "rewrite lnot_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftr_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec_low",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec_low",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "rewrite lxor_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite shiftl_spec_high",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec_high",
      confidence = 0.5 ),
    ( tacticText = "rewrite ones_spec",
      confidence = 0.5 ) ] )
STATE
a : t, b : t |- (P (- lxor b a) == lxor a (P (- b)))
----
a : t, b : t |- (P (- lxor b a) == lxor a (P (- b))) OUTPUT
bitwise
rewrite lxor_comm
unfold lxor
rewrite opp_involutive
rewrite lxor_0_l
rewrite lxor_0
rewrite lnot_involutive
rewrite lnot_opp
apply lxor_0_l
rewrite lxor_0_r
Prediction takes 0.09602546691894531 seconds
( textPrediction = [
    (tacticText = "bitwise", confidence = 0.5),
    ( tacticText = "rewrite lxor_comm",
      confidence = 0.5 ),
    ( tacticText = "unfold lxor",
      confidence = 0.5 ),
    ( tacticText = "rewrite opp_involutive",
      confidence = 0.5 ),
    ( tacticText = "rewrite lxor_0_l",
      confidence = 0.5 ),
    ( tacticText = "rewrite lxor_0",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_involutive",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_opp",
      confidence = 0.5 ),
    ( tacticText = "apply lxor_0_l",
      confidence = 0.5 ),
    ( tacticText = "rewrite lxor_0_r",
      confidence = 0.5 ) ] )
STATE
a : t, b : t |- (lnot (lxor b a) == lxor a (lnot b))
----
a : t, b : t |- (lnot (lxor b a) == lxor a (lnot b)) OUTPUT
bitwise
unfold lnot
rewrite lxor_comm
unfold lxor
rewrite lxor_lnot_lnot
rewrite lnot_spec
rewrite lnot_lnot_lnot
intros ?
rewrite lnot_comm
apply lxor_comm
Prediction takes 0.16881775856018066 seconds
( textPrediction = [
    (tacticText = "bitwise", confidence = 0.5),
    ( tacticText = "unfold lnot",
      confidence = 0.5 ),
    ( tacticText = "rewrite lxor_comm",
      confidence = 0.5 ),
    ( tacticText = "unfold lxor",
      confidence = 0.5 ),
    ( tacticText = "rewrite lxor_lnot_lnot",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_spec",
      confidence = 0.5 ),
    ( tacticText = "rewrite lnot_lnot_lnot",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "rewrite lnot_comm",
      confidence = 0.5 ),
    ( tacticText = "apply lxor_comm",
      confidence = 0.5 ) ] )
Model Loaded
0
STATE
b : bool |- ((b : bool) -> ~~ b = false)
----
b : bool |- ((b : bool) -> ~~ b = false) OUTPUT
intros ?
destruct b
auto
case : b
simpl
intros until b
case b
unfold b
by case b
apply b
Prediction takes 2.943636417388916 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "destruct b",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "case : b", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "intros until b",
      confidence = 0.5 ),
    (tacticText = "case b", confidence = 0.5),
    (tacticText = "unfold b", confidence = 0.5),
    (tacticText = "by case b", confidence = 0.5),
    (tacticText = "apply b", confidence = 0.5) ] )
STATE
b : bool, H : (is_true (b : bool)) |- (~~ b = false)
----
b : bool, H : (is_true (b : bool)) |- (~~ b = false) OUTPUT
intros ?
destruct b
auto
discriminate
apply H
simpl
by case : b
apply H in H
case : b
case : a
Prediction takes 0.08234596252441406 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "destruct b",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "discriminate",
      confidence = 0.5 ),
    (tacticText = "apply H", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "by case : b",
      confidence = 0.5 ),
    ( tacticText = "apply H in H",
      confidence = 0.5 ),
    (tacticText = "case : b", confidence = 0.5),
    (tacticText = "case : a", confidence = 0.5) ] )
STATE
H : (is_true true) |- (~~ true = false)
----
H : (is_true true) |- (~~ true = false) OUTPUT
auto
intros ?
discriminate
destruct H
simpl
easy
intuition
exfalso
apply H
destruct H as
Prediction takes 0.05495095252990723 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "discriminate",
      confidence = 0.5 ),
    ( tacticText = "destruct H",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "intuition", confidence = 0.5),
    (tacticText = "exfalso", confidence = 0.5),
    (tacticText = "apply H", confidence = 0.5),
    ( tacticText = "destruct H as",
      confidence = 0.5 ) ] )
STATE
b1 : bool, b2 : bool, b3 : bool, b4 : bool, b5 : bool |- (reflect (~ b1) (~~ b1))
----
b1 : bool, b2 : bool, b3 : bool, b4 : bool, b5 : bool |- (reflect (~ b1) (~~ b1)) OUTPUT
intros ?
by case b1; constructor
by case b1; constructor; constructor
constructor
destruct b1
red
case b1
by case b1; constructor; constructor; constructor
by case b1; constructor; constructor; constructor; constructor
by case b1; constructor; case : b1
Prediction takes 0.1569991111755371 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "by case b1; constructor",
      confidence = 0.5 ),
    ( tacticText = "by case b1; constructor; constructor",
      confidence = 0.5 ),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    ( tacticText = "destruct b1",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "case b1", confidence = 0.5),
    ( tacticText = "by case b1; constructor; constructor; constructor",
      confidence = 0.5 ),
    ( tacticText = "by case b1; constructor; constructor; constructor; constructor",
      confidence = 0.5 ),
    ( tacticText = "by case b1; constructor; case : b1",
      confidence = 0.5 ) ] )
STATE
T1 : predArgType, T2 : predArgType, T3 : predArgType, D1 : {pred T1}, D2 : {pred T2}, D3 : {pred T3}, d1 : (mem_pred T1), d1' : (mem_pred T1), d2 : (mem_pred T2), d2' : (mem_pred T2), d3 : (mem_pred T3), d3' : (mem_pred T3), f : (T1 -> T2), f' : (T1 -> T2), g : (T2 -> T1), h : T3, P1 : (T1 -> Prop), P2 : (T1 -> T2 -> Prop), P3 : (T1 -> T2 -> T3 -> Prop), Q1 : ((T1 -> T2) -> T1 -> Prop), Q1l : ((T1 -> T2) -> T3 -> T1 -> Prop), Q2 : ((T1 -> T2) -> T1 -> T1 -> Prop), sub1 : (sub_mem d1 d1'), sub2 : (sub_mem d2 d2'), sub3 : (sub_mem d3 d3') |- ({ all1 P1} -> {in D1, { all1 P1}})
----
T1 : predArgType, T2 : predArgType, T3 : predArgType, D1 : {pred T1}, D2 : {pred T2}, D3 : {pred T3}, d1 : (mem_pred T1), d1' : (mem_pred T1), d2 : (mem_pred T2), d2' : (mem_pred T2), d3 : (mem_pred T3), d3' : (mem_pred T3), f : (T1 -> T2), f' : (T1 -> T2), g : (T2 -> T1), h : T3, P1 : (T1 -> Prop), P2 : (T1 -> T2 -> Prop), P3 : (T1 -> T2 -> T3 -> Prop), Q1 : ((T1 -> T2) -> T1 -> Prop), Q1l : ((T1 -> T2) -> T3 -> T1 -> Prop), Q2 : ((T1 -> T2) -> T1 -> T1 -> Prop), sub1 : (sub_mem d1 d1'), sub2 : (sub_mem d2 d2'), sub3 : (sub_mem d3 d3') |- ({ all1 P1} -> {in D1, { all1 P1}}) OUTPUT
intros ?
auto
by move  =>ove  =>fKfKfK2; apply :
by move  =>ove  =>fK fK; apply : ; apply :
by move  =>ove  =>ove ; apply : ; apply :  =>
by move  =>ove  =>fK fK; apply : ; apply :  =>
by move  =>ove  =>fK fK fK; apply : ; apply :  =>
by move  =>ove  =>fK fK; apply : ; apply : ; apply :
by move  =>ove  =>fK fK; apply :  =>fK fK2; apply :
by move  =>ove  =>fK fK fK; apply : ; apply :  =>fK
Prediction takes 0.30318164825439453 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "by move  =>ove  =>fKfKfK2; apply :",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  =>fK fK; apply : ; apply :",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  =>ove ; apply : ; apply :  =>",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  =>fK fK; apply : ; apply :  =>",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  =>fK fK fK; apply : ; apply :  =>",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  =>fK fK; apply : ; apply : ; apply :",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  =>fK fK; apply :  =>fK fK2; apply :",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  =>fK fK fK; apply : ; apply :  =>fK",
      confidence = 0.5 ) ] )
STATE
T1 : predArgType, T2 : predArgType, T3 : predArgType, D1 : {pred T1}, D2 : {pred T2}, D3 : {pred T3}, d1 : (mem_pred T1), d1' : (mem_pred T1), d2 : (mem_pred T2), d2' : (mem_pred T2), d3 : (mem_pred T3), d3' : (mem_pred T3), f : (T1 -> T2), f' : (T1 -> T2), g : (T2 -> T1), h : T3, P1 : (T1 -> Prop), P2 : (T1 -> T2 -> Prop), P3 : (T1 -> T2 -> T3 -> Prop), Q1 : ((T1 -> T2) -> T1 -> Prop), Q1l : ((T1 -> T2) -> T3 -> T1 -> Prop), Q2 : ((T1 -> T2) -> T1 -> T1 -> Prop), sub1 : (sub_mem d1 d1'), sub2 : (sub_mem d2 d2'), sub3 : (sub_mem d3 d3'), H : { all1 P1} |- {in D1, { all1 P1}}
----
T1 : predArgType, T2 : predArgType, T3 : predArgType, D1 : {pred T1}, D2 : {pred T2}, D3 : {pred T3}, d1 : (mem_pred T1), d1' : (mem_pred T1), d2 : (mem_pred T2), d2' : (mem_pred T2), d3 : (mem_pred T3), d3' : (mem_pred T3), f : (T1 -> T2), f' : (T1 -> T2), g : (T2 -> T1), h : T3, P1 : (T1 -> Prop), P2 : (T1 -> T2 -> Prop), P3 : (T1 -> T2 -> T3 -> Prop), Q1 : ((T1 -> T2) -> T1 -> Prop), Q1l : ((T1 -> T2) -> T3 -> T1 -> Prop), Q2 : ((T1 -> T2) -> T1 -> T1 -> Prop), sub1 : (sub_mem d1 d1'), sub2 : (sub_mem d2 d2'), sub3 : (sub_mem d3 d3'), H : { all1 P1} |- {in D1, { all1 P1}} OUTPUT
intros ?
auto
congruence
trivial
apply
by move  => hove  => hove  => hg2; apply : ; apply :  =>
by move  =>ove  => hove  => hgK2; apply : ; apply :  =>
by move  => hove  => hove  =>fK2; apply : ; apply :  =>
by move  => hove  => hove  => hg2; apply : ; apply :  =>fK
by move  =>ove  => hove  => hgK2; apply : ; apply :  =>fK
Prediction takes 0.31804537773132324 seconds
starting proving server with connection through their stdin
using textmode optiontext
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
 |- (forall (A : Type) (R : crelation A), Symmetric R -> forall f : A -> Type, Proper (R ==> arrow) f -> Proper (R ==> iffT) f)
----
 |- (forall (A : Type) (R : crelation A), Symmetric R -> forall f : A -> Type, Proper (R ==> arrow) f -> Proper (R ==> iffT) f) OUTPUT
intros ?
intros
firstorder
red
auto
induction 1
unfold Proper
unfold crelation
unfold Proper (Acc R)
unfold Proper (Proper (R ==> R))
Prediction takes 2.993543863296509 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "firstorder",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    ( tacticText = "unfold Proper",
      confidence = 0.5 ),
    ( tacticText = "unfold crelation",
      confidence = 0.5 ),
    ( tacticText = "unfold Proper (Acc R)",
      confidence = 0.5 ),
    ( tacticText = "unfold Proper (Proper (R ==> R))",
      confidence = 0.5 ) ] )
STATE
A : Type |- (forall R : crelation A, Symmetric R -> forall f : A -> Type, Proper (R ==> arrow) f -> Proper (R ==> iffT) f)
----
A : Type |- (forall R : crelation A, Symmetric R -> forall f : A -> Type, Proper (R ==> arrow) f -> Proper (R ==> iffT) f) OUTPUT
intros ?
intros
unfold Proper
red
induction 1
firstorder
induction 2
intros until f
exact (fun _ _
exact (fun _
Prediction takes 0.08253741264343262 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold Proper",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    ( tacticText = "firstorder",
      confidence = 0.5 ),
    ( tacticText = "induction 2",
      confidence = 0.5 ),
    ( tacticText = "intros until f",
      confidence = 0.5 ),
    ( tacticText = "exact (fun _ _",
      confidence = 0.5 ),
    ( tacticText = "exact (fun _",
      confidence = 0.5 ) ] )
STATE
A : Type, R : (crelation A) |- (Symmetric R -> forall f : A -> Type, Proper (R ==> arrow) f -> Proper (R ==> iffT) f)
----
A : Type, R : (crelation A) |- (Symmetric R -> forall f : A -> Type, Proper (R ==> arrow) f -> Proper (R ==> iffT) f) OUTPUT
intros ?
intros
firstorder
unfold Proper
red
induction 1
auto
simpl
functional induction
functional induction 2
Prediction takes 0.06903553009033203 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "firstorder",
      confidence = 0.5 ),
    ( tacticText = "unfold Proper",
      confidence = 0.5 ),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "functional induction",
      confidence = 0.5 ),
    ( tacticText = "functional induction 2",
      confidence = 0.5 ) ] )
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "congruence",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "apply", confidence = 0.5),
    ( tacticText = "by move  => hove  => hove  => hg2; apply : ; apply :  =>",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  => hove  => hgK2; apply : ; apply :  =>",
      confidence = 0.5 ),
    ( tacticText = "by move  => hove  => hove  =>fK2; apply : ; apply :  =>",
      confidence = 0.5 ),
    ( tacticText = "by move  => hove  => hove  => hg2; apply : ; apply :  =>fK",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  => hove  => hgK2; apply : ; apply :  =>fK",
      confidence = 0.5 ) ] )
STATE
T1 : predArgType, T2 : predArgType, T3 : predArgType, D1 : {pred T1}, D2 : {pred T2}, D3 : {pred T3}, d1 : (mem_pred T1), d1' : (mem_pred T1), d2 : (mem_pred T2), d2' : (mem_pred T2), d3 : (mem_pred T3), d3' : (mem_pred T3), f : (T1 -> T2), f' : (T1 -> T2), g : (T2 -> T1), h : T3, P1 : (T1 -> Prop), P2 : (T1 -> T2 -> Prop), P3 : (T1 -> T2 -> T3 -> Prop), Q1 : ((T1 -> T2) -> T1 -> Prop), Q1l : ((T1 -> T2) -> T3 -> T1 -> Prop), Q2 : ((T1 -> T2) -> T1 -> T1 -> Prop), sub1 : (sub_mem d1 d1'), sub2 : (sub_mem d2 d2'), sub3 : (sub_mem d3 d3'), H : { all1 P1}, x : T1 |- (x \in D1 -> P1 x)
----
T1 : predArgType, T2 : predArgType, T3 : predArgType, D1 : {pred T1}, D2 : {pred T2}, D3 : {pred T3}, d1 : (mem_pred T1), d1' : (mem_pred T1), d2 : (mem_pred T2), d2' : (mem_pred T2), d3 : (mem_pred T3), d3' : (mem_pred T3), f : (T1 -> T2), f' : (T1 -> T2), g : (T2 -> T1), h : T3, P1 : (T1 -> Prop), P2 : (T1 -> T2 -> Prop), P3 : (T1 -> T2 -> T3 -> Prop), Q1 : ((T1 -> T2) -> T1 -> Prop), Q1l : ((T1 -> T2) -> T3 -> T1 -> Prop), Q2 : ((T1 -> T2) -> T1 -> T1 -> Prop), sub1 : (sub_mem d1 d1'), sub2 : (sub_mem d2 d2'), sub3 : (sub_mem d3 d3'), H : { all1 P1}, x : T1 |- (x \in D1 -> P1 x) OUTPUT
intros ?
auto
intros
by move  =>ove  => =>fK2)
by move  =>ove  =>ffK2)
by move  =>ove  =>ffK2)  => hgK
by move  =>ove  => =>fK2)  => hgK
by move  =>ove  =>fK2; apply :  =>fK2)
by move  =>ove  => =>fK2)  =>fKfK2)
by move  =>ove  =>ffK2)  =>fKfK2)
Prediction takes 0.30112743377685547 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "by move  =>ove  => =>fK2)",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  =>ffK2)",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  =>ffK2)  => hgK",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  => =>fK2)  => hgK",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  =>fK2; apply :  =>fK2)",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  => =>fK2)  =>fKfK2)",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  =>ffK2)  =>fKfK2)",
      confidence = 0.5 ) ] )
STATE
T1 : predArgType, T2 : predArgType, T3 : predArgType, D1 : {pred T1}, D2 : {pred T2}, D3 : {pred T3}, d1 : (mem_pred T1), d1' : (mem_pred T1), d2 : (mem_pred T2), d2' : (mem_pred T2), d3 : (mem_pred T3), d3' : (mem_pred T3), f : (T1 -> T2), f' : (T1 -> T2), g : (T2 -> T1), h : T3, P1 : (T1 -> Prop), P2 : (T1 -> T2 -> Prop), P3 : (T1 -> T2 -> T3 -> Prop), Q1 : ((T1 -> T2) -> T1 -> Prop), Q1l : ((T1 -> T2) -> T3 -> T1 -> Prop), Q2 : ((T1 -> T2) -> T1 -> T1 -> Prop), sub1 : (sub_mem d1 d1'), sub2 : (sub_mem d2 d2'), sub3 : (sub_mem d3 d3'), H : { all1 P1}, x : T1, H0 : (is_true (x \in D1)) |- (P1 x)
----
T1 : predArgType, T2 : predArgType, T3 : predArgType, D1 : {pred T1}, D2 : {pred T2}, D3 : {pred T3}, d1 : (mem_pred T1), d1' : (mem_pred T1), d2 : (mem_pred T2), d2' : (mem_pred T2), d3 : (mem_pred T3), d3' : (mem_pred T3), f : (T1 -> T2), f' : (T1 -> T2), g : (T2 -> T1), h : T3, P1 : (T1 -> Prop), P2 : (T1 -> T2 -> Prop), P3 : (T1 -> T2 -> T3 -> Prop), Q1 : ((T1 -> T2) -> T1 -> Prop), Q1l : ((T1 -> T2) -> T3 -> T1 -> Prop), Q2 : ((T1 -> T2) -> T1 -> T1 -> Prop), sub1 : (sub_mem d1 d1'), sub2 : (sub_mem d2 d2'), sub3 : (sub_mem d3 d3'), H : { all1 P1}, x : T1, H0 : (is_true (x \in D1)) |- (P1 x) OUTPUT
auto
assumption
apply
easy
trivial
subst
apply all
by move  =>ove  => => h2)
by move  =>ove  => => hg2)
by move  =>ove  => => hg1)
Prediction takes 0.21094942092895508 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    (tacticText = "apply", confidence = 0.5),
    (tacticText = "easy", confidence = 0.5),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "subst", confidence = 0.5),
    (tacticText = "apply all", confidence = 0.5),
    ( tacticText = "by move  =>ove  => => h2)",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  => => hg2)",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  => => hg1)",
      confidence = 0.5 ) ] )
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...
To disable this warning, you can either:
	- Avoid using `tokenizers` before the fork if possible
	- Explicitly set the environment variable TOKENIZERS_PARALLELISM=(true | false)
Model Loaded
0
STATE
A : Type, B : Type, C : Type, f : (B -> A), g : (B -> A) |- (eqfun f g -> eqfun g f)
----
A : Type, B : Type, C : Type, f : (B -> A), g : (B -> A) |- (eqfun f g -> eqfun g f) OUTPUT
intros ?
red
auto
congruence
intros
by move
unfold eq_dep
unfold eq_ind
by split
by case
Prediction takes 2.810450315475464 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "congruence",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "by move", confidence = 0.5),
    ( tacticText = "unfold eq_dep",
      confidence = 0.5 ),
    ( tacticText = "unfold eq_ind",
      confidence = 0.5 ),
    (tacticText = "by split", confidence = 0.5),
    (tacticText = "by case", confidence = 0.5) ] )
STATE
A : Type, B : Type, C : Type, f : (B -> A), g : (B -> A), H : (eqfun f g) |- (eqfun g f)
----
A : Type, B : Type, C : Type, f : (B -> A), g : (B -> A), H : (eqfun f g) |- (eqfun g f) OUTPUT
auto
congruence
trivial
red
reflexivity
easy
apply eq_ind
apply eq_refl
apply eq_sym
apply g
Prediction takes 0.07190895080566406 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "congruence",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    (tacticText = "red", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    (tacticText = "easy", confidence = 0.5),
    ( tacticText = "apply eq_ind",
      confidence = 0.5 ),
    ( tacticText = "apply eq_refl",
      confidence = 0.5 ),
    ( tacticText = "apply eq_sym",
      confidence = 0.5 ),
    (tacticText = "apply g", confidence = 0.5) ] )
Model Loaded
0
STATE
 |- (forall (A : Type) (R : A -> A -> Prop) (Rwf : well_founded R) (P : A -> Type) (F_sub : forall x : A, (forall y : {y : A | R y x}, P (` y)) -> P x) (x : A), Fix_sub A R Rwf P F_sub x = F_sub x (fun y : {y : A | R y x} => Fix_sub A R Rwf P F_sub (` y)))
----
 |- (forall (A : Type) (R : A -> A -> Prop) (Rwf : well_founded R) (P : A -> Type) (F_sub : forall x : A, (forall y : {y : A | R y x}, P (` y)) -> P x) (x : A), Fix_sub A R Rwf P F_sub x = F_sub x (fun y : {y : A | R y x} => Fix_sub A R Rwf P F_sub (` y))) OUTPUT
intros
intros ?
induction 1
simpl
intros until y
destruct 1
intros until P
unfold Fix_sub
unfold F_sub
unfold F_inv
Prediction takes 3.2390120029449463 seconds
( textPrediction = [
    (tacticText = "intros", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "intros until y",
      confidence = 0.5 ),
    ( tacticText = "destruct 1",
      confidence = 0.5 ),
    ( tacticText = "intros until P",
      confidence = 0.5 ),
    ( tacticText = "unfold Fix_sub",
      confidence = 0.5 ),
    ( tacticText = "unfold F_sub",
      confidence = 0.5 ),
    ( tacticText = "unfold F_inv",
      confidence = 0.5 ) ] )
STATE
A : Type, R : (A -> A -> Prop), Rwf : (well_founded R), P : (A -> Type), F_sub : (forall x : A, (forall y : {y : A | R y x}, P (` y)) -> P x), x : A |- (Fix_sub A R Rwf P F_sub x = F_sub x (fun y : {y : A | R y x} => Fix_sub A R Rwf P F_sub (` y)))
----
A : Type, R : (A -> A -> Prop), Rwf : (well_founded R), P : (A -> Type), F_sub : (forall x : A, (forall y : {y : A | R y x}, P (` y)) -> P x), x : A |- (Fix_sub A R Rwf P F_sub x = F_sub x (fun y : {y : A | R y x} => Fix_sub A R Rwf P F_sub (` y))) OUTPUT
simpl
reflexivity
unfold Fix_sub
intros
unfold Fix_Factor
unfold Fix
apply Acc_intro
apply Acc_inv
unfold Fix_F_sub
unfold Fix_F
Prediction takes 0.10357856750488281 seconds
( textPrediction = [
    (tacticText = "simpl", confidence = 0.5),
    ( tacticText = "reflexivity",
      confidence = 0.5 ),
    ( tacticText = "unfold Fix_sub",
      confidence = 0.5 ),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "unfold Fix_Factor",
      confidence = 0.5 ),
    ( tacticText = "unfold Fix",
      confidence = 0.5 ),
    ( tacticText = "apply Acc_intro",
      confidence = 0.5 ),
    ( tacticText = "apply Acc_inv",
      confidence = 0.5 ),
    ( tacticText = "unfold Fix_F_sub",
      confidence = 0.5 ),
    ( tacticText = "unfold Fix_F",
      confidence = 0.5 ) ] )
Model Loaded
0
STATE
A : Type, R : (relation A) |- (forall x y : A, clos_refl_trans R x y -> clos_refl_trans_n1 R x y)
----
A : Type, R : (relation A) |- (forall x y : A, clos_refl_trans R x y -> clos_refl_trans_n1 R x y) OUTPUT
induction 1
intros ?
intros
auto with sets
simpl
auto
intros until 1
intros until y
intros until y z
intros until x
Prediction takes 2.7252657413482666 seconds
( textPrediction = [
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "auto with sets",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "intros until 1",
      confidence = 0.5 ),
    ( tacticText = "intros until y",
      confidence = 0.5 ),
    ( tacticText = "intros until y z",
      confidence = 0.5 ),
    ( tacticText = "intros until x",
      confidence = 0.5 ) ] )
STATE
A : Type, R : (relation A), x : A, y : A, H : (R x y) |- (clos_refl_trans_n1 R x y)
----
A : Type, R : (relation A), x : A, y : A, H : (R x y) |- (clos_refl_trans_n1 R x y) OUTPUT
left
auto with sets
right
constructor 2
auto
assumption
constructor
constructor 1
elim H
auto with y
Prediction takes 0.05286979675292969 seconds
( textPrediction = [
    (tacticText = "left", confidence = 0.5),
    ( tacticText = "auto with sets",
      confidence = 0.5 ),
    (tacticText = "right", confidence = 0.5),
    ( tacticText = "constructor 2",
      confidence = 0.5 ),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    ( tacticText = "constructor",
      confidence = 0.5 ),
    ( tacticText = "constructor 1",
      confidence = 0.5 ),
    (tacticText = "elim H", confidence = 0.5),
    ( tacticText = "auto with y",
      confidence = 0.5 ) ] )
STATE
A : Type, R : (relation A), x : A |- (forall y : A, clos_refl_trans R x y -> clos_refl_trans_n1 R x y)
----
A : Type, R : (relation A), x : A |- (forall y : A, clos_refl_trans R x y -> clos_refl_trans_n1 R x y) OUTPUT
intros ?
intros
induction 1
auto with sets
simpl
auto
intros until y z
intros until y
intros until 1
apply clos_rstst
Prediction takes 0.08010077476501465 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "intros", confidence = 0.5),
    ( tacticText = "induction 1",
      confidence = 0.5 ),
    ( tacticText = "auto with sets",
      confidence = 0.5 ),
    (tacticText = "simpl", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "intros until y z",
      confidence = 0.5 ),
    ( tacticText = "intros until y",
      confidence = 0.5 ),
    ( tacticText = "intros until 1",
      confidence = 0.5 ),
    ( tacticText = "apply clos_rstst",
      confidence = 0.5 ) ] )
Model Loaded
0
STATE
T1 : predArgType, T2 : predArgType, T3 : predArgType, D1 : {pred T1}, D2 : {pred T2}, D3 : {pred T3}, d1 : (mem_pred T1), d1' : (mem_pred T1), d2 : (mem_pred T2), d2' : (mem_pred T2), d3 : (mem_pred T3), d3' : (mem_pred T3), f : (T1 -> T2), f' : (T1 -> T2), g : (T2 -> T1), h : T3, P1 : (T1 -> Prop), P2 : (T1 -> T2 -> Prop), P3 : (T1 -> T2 -> T3 -> Prop), Q1 : ((T1 -> T2) -> T1 -> Prop), Q1l : ((T1 -> T2) -> T3 -> T1 -> Prop), Q2 : ((T1 -> T2) -> T1 -> T1 -> Prop), sub1 : (sub_mem d1 d1'), sub2 : (sub_mem d2 d2'), sub3 : (sub_mem d3 d3') |- ({in T1, { all1 P1}} -> { all1 P1})
----
T1 : predArgType, T2 : predArgType, T3 : predArgType, D1 : {pred T1}, D2 : {pred T2}, D3 : {pred T3}, d1 : (mem_pred T1), d1' : (mem_pred T1), d2 : (mem_pred T2), d2' : (mem_pred T2), d3 : (mem_pred T3), d3' : (mem_pred T3), f : (T1 -> T2), f' : (T1 -> T2), g : (T2 -> T1), h : T3, P1 : (T1 -> Prop), P2 : (T1 -> T2 -> Prop), P3 : (T1 -> T2 -> T3 -> Prop), Q1 : ((T1 -> T2) -> T1 -> Prop), Q1l : ((T1 -> T2) -> T3 -> T1 -> Prop), Q2 : ((T1 -> T2) -> T1 -> T1 -> Prop), sub1 : (sub_mem d1 d1'), sub2 : (sub_mem d2 d2'), sub3 : (sub_mem d3 d3') |- ({in T1, { all1 P1}} -> { all1 P1}) OUTPUT
intros ?
auto
by move  =>ove  => hove  =>fK2)
by move  =>ove  =>fK fK; apply by move ; apply by move  =>fK; apply by move; apply by move; apply by move ; apply by move  =>
by move  =>ove  =>fK fK; apply by move ; apply by move  =>fK; apply by move; apply by move; apply by move; by move; by move
by move  =>ove  =>fK fK; apply by move ; apply by move  =>fK; apply by move; apply by move; apply by move; apply by move  =>f
by move  =>ove  =>fK fK; apply by move ; apply by move  =>fK; apply by move; apply by move; apply by move; apply by move  => =>
by move  =>ove  =>fK fK; apply by move ; apply by move  =>fK; apply by move; apply by move; apply by move; apply by move; by m
by move  =>ove  =>fK fK; apply by move ; apply by move  =>fK; apply by move; apply by move; apply by move; apply by move  =>ove
by move  =>ove  =>fK fK; apply by move ; apply by move  =>fK; apply by move; apply by move; apply by move; by move; apply by m
Prediction takes 3.198634147644043 seconds
( textPrediction = [
    (tacticText = "intros ?", confidence = 0.5),
    (tacticText = "auto", confidence = 0.5),
    ( tacticText = "by move  =>ove  => hove  =>fK2)",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  =>fK fK; apply by move ; apply by move  =>fK; apply by move; apply by move; apply by move ; apply by move  =>",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  =>fK fK; apply by move ; apply by move  =>fK; apply by move; apply by move; apply by move; by move; by move",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  =>fK fK; apply by move ; apply by move  =>fK; apply by move; apply by move; apply by move; apply by move  =>f",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  =>fK fK; apply by move ; apply by move  =>fK; apply by move; apply by move; apply by move; apply by move  => =>",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  =>fK fK; apply by move ; apply by move  =>fK; apply by move; apply by move; apply by move; apply by move; by m",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  =>fK fK; apply by move ; apply by move  =>fK; apply by move; apply by move; apply by move; apply by move  =>ove",
      confidence = 0.5 ),
    ( tacticText = "by move  =>ove  =>fK fK; apply by move ; apply by move  =>fK; apply by move; apply by move; apply by move; by move; apply by m",
      confidence = 0.5 ) ] )
STATE
T1 : predArgType, T2 : predArgType, T3 : predArgType, D1 : {pred T1}, D2 : {pred T2}, D3 : {pred T3}, d1 : (mem_pred T1), d1' : (mem_pred T1), d2 : (mem_pred T2), d2' : (mem_pred T2), d3 : (mem_pred T3), d3' : (mem_pred T3), f : (T1 -> T2), f' : (T1 -> T2), g : (T2 -> T1), h : T3, P1 : (T1 -> Prop), P2 : (T1 -> T2 -> Prop), P3 : (T1 -> T2 -> T3 -> Prop), Q1 : ((T1 -> T2) -> T1 -> Prop), Q1l : ((T1 -> T2) -> T3 -> T1 -> Prop), Q2 : ((T1 -> T2) -> T1 -> T1 -> Prop), sub1 : (sub_mem d1 d1'), sub2 : (sub_mem d2 d2'), sub3 : (sub_mem d3 d3'), H : {in T1, { all1 P1}} |- { all1 P1}
----
T1 : predArgType, T2 : predArgType, T3 : predArgType, D1 : {pred T1}, D2 : {pred T2}, D3 : {pred T3}, d1 : (mem_pred T1), d1' : (mem_pred T1), d2 : (mem_pred T2), d2' : (mem_pred T2), d3 : (mem_pred T3), d3' : (mem_pred T3), f : (T1 -> T2), f' : (T1 -> T2), g : (T2 -> T1), h : T3, P1 : (T1 -> Prop), P2 : (T1 -> T2 -> Prop), P3 : (T1 -> T2 -> T3 -> Prop), Q1 : ((T1 -> T2) -> T1 -> Prop), Q1l : ((T1 -> T2) -> T3 -> T1 -> Prop), Q2 : ((T1 -> T2) -> T1 -> T1 -> Prop), sub1 : (sub_mem d1 d1'), sub2 : (sub_mem d2 d2'), sub3 : (sub_mem d3 d3'), H : {in T1, { all1 P1}} |- { all1 P1} OUTPUT
auto
intros ?
congruence
assumption
trivial
by move  => hove  => hove ; apply by move ; apply by move; apply by move; apply by move  =>ove ; apply by move; apply by move  =>f
by move  => hove  => hove ; apply by move ; apply by move; apply by move; apply by move  =>ove ; apply by move; apply by move  => =>
by move  => hove  => hove ; apply by move ; apply by move; apply by move; apply by move  =>ove; apply by move; apply by move  =>fK
by move  => hove  => hove ; apply by move  =>ove ; apply by move ; apply by move  =>ove ; apply by move; apply by move  =>fK
by move  => hove  => hove ; apply by move ; apply by move; apply by move; apply by move  =>ove ; apply by move; apply by move ; apply
Prediction takes 0.4959595203399658 seconds
( textPrediction = [
    (tacticText = "auto", confidence = 0.5),
    (tacticText = "intros ?", confidence = 0.5),
    ( tacticText = "congruence",
      confidence = 0.5 ),
    ( tacticText = "assumption",
      confidence = 0.5 ),
    (tacticText = "trivial", confidence = 0.5),
    ( tacticText = "by move  => hove  => hove ; apply by move ; apply by move; apply by move; apply by move  =>ove ; apply by move; apply by move  =>f",
      confidence = 0.5 ),
    ( tacticText = "by move  => hove  => hove ; apply by move ; apply by move; apply by move; apply by move  =>ove ; apply by move; apply by move  => =>",
      confidence = 0.5 ),
    ( tacticText = "by move  => hove  => hove ; apply by move ; apply by move; apply by move; apply by move  =>ove; apply by move; apply by move  =>fK",
      confidence = 0.5 ),
    ( tacticText = "by move  => hove  => hove ; apply by move  =>ove ; apply by move ; apply by move  =>ove ; apply by move; apply by move  =>fK",
      confidence = 0.5 ),
    ( tacticText = "by move  => hove  => hove ; apply by move ; apply by move; apply by move; apply by move  =>ove ; apply by move; apply by move ; apply",
      confidence = 0.5 ) ] )
